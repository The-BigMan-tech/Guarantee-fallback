!Learn how to whitelist ip address to fix the handshake error when connecting to mongo atlas
?Learn about package managers in detail:npm,pnpm and also npx
?Learn how version control works in detail
?SWC compiler,tsc compiler,Babel compiler,llvm
?Understand the inner workings of electron,tauri and node js and the various browser components that makes them work
?Time series data and time scale db
?There is transcrypt compiler

?Automatic refresh in rtk query
?I should use pinno in redux middleware for logging app interactions
?Deno has native support for ts and prevents npm module vulnerabilities by allowing code to access what you allow and also,it is faster than node js.With deno,there is no need to setup typescript with the tsc or swc compiler but because type checking in deno costs a lot of time,ts files dont get type checked before

*The docker run command runs a container from an image
*There is docker hub which is like github but for docker containers

^Dont forget about mcmodels website for minecraft
^Lagging background processes of an app can prevent the desktop app from opening

^anime power:you can only touch a shell or decoy of the person.His power hides him from any physical intercations and can only be interacted through a function that returns a decoy of him.Him and the decoy exist in the same space coordinates but only one can be seen at a time.Any attempt to attack him only attacks the decoy or shell and it shatters off when the character garbage collects it revealing the true character.Visually,it will look like how a character dies and respawns in a video game


^table tennis,pen spinning,air hockey

*In docker,we install dependencies first before src code so that we dont install our modules on every src code change.It allows for caching

*react favours functional programming

*Function constructor evaluation is safer than pure eval because the string is only evaluated as a return from a function but Math js provides safer and more complicated evaluations for math expressions.

*Feature based architecture aims to solve the problems from tight coupling of components

*Tauri uses native web views.Native webviews are software components that allows an app to display web content without a browser.It is like a tiny browser
*NW js packages a node js server and chromium together in a single runtime allowing you to leverage node modules and broswer apis in one place
*Electron packages chromium to execute your app.


*In javascript,using lamba functions is highly common because of its async and functional nature.Javascript has the largest ecosystem of frameworks,packages and libraries

*Databases,compilers and game engines are written in languages like C++ 

*There are package managers and the files you use to define package and dependency data.Js uses package.json.With python,we use toml with poetry.py manager and for js,maven

*You add the api key to the headers which is where we store metadata
*Scaffolding utility is a more professional way of saying template builder

*Pino allows you to dynamically set the log level at runtime to control the verbosity of logging or reduce log noise

*In a request,you can ship payload through query parameters for get and delete and a request body for put and post.You can also use path parameters for dynamic routing

*Axios can be ran on a node js server

*learn about ts utility types
*Path parameters starts with : while query parameters starts with ?
*tailwind allows you to know what styles applies to a tag at first glance
*Sass-css,Ts-Js,Mojo-python,C++-C

*css in js,preprocessor
*loops are procedural while recursion is functional
*Svgs are images as code and lottie files are animations as code.

*Declarative ui syntax is compiled to dom manipulation

*loop rendering in react requires a unique identifier like using the uuid package

*For dynamic rendering i.e loop and conditional,react uses template syntax,vue uses directives and sveltes uses control blocks


*Scalability of a software solution refers to its ability to handle an increasing amount of work or itscapacity to accommodate growth in various factors‚Äîsuch as maintainability, performance, robustness, andsafety‚Äîwithout requiring a complete redesign or significant changes to the architecture.

*Complexity in software refers to the increasing demand for a more ideal or sophisticated solution as the software grows. This complexity arises from the need to manage more features, integrate with other systems, and accommodate changing requirements.


*Primitives are immutable types meaning that they are explicitly copied on each modification while objects and arrays are directly mutable since they are modified using their references meaning that performing operations on primitives in functions will always be free of side effects unlike arrays and objects.To prevent side effects or direct mutation,we copy the array or the object.In js,we use the spread operator.*Spreading is an operation that allows you to selectively modify arrays and objects and keeping the rest of it unchanged.React requires that state updates should be immutable and thats why use the spread operator for objects and arrays.Arrays and objects are passed by reference because they can consume lots of memory when they are deeply nested but immutability brings safety and predicatbility.


*Eslint is the official linter for javascript
*meta frameworks brings a mini server to your frontend
*Directives in frontend components are attributes with a semantic meaning

?vscode uses monaco code editor as its text engine

*so for object destructuring, i have to use the exact names of the properties i want to unpack and if i want to rename it,i have to use colons but for array destructuring,i can unpack it with any variable name i want since it uses indexing and not properties for unpacking.For array destructuring,to selectively unpack what you need,you use empty spaces separated by commas but for objects,we use the direct property name

*endpoints are operations to a server.It can be a query for reading data or a mutation to update data on the server.Endpoint by default use get unless explicitly overriden.For every endpoint defined in a slice,rtk query will generate a hook for that

*In rtk query,it is one api slice per application.An rtk query is consisted of the base query and enpoints.The base query is a function that knows how to communicate with the server.We use the fetchbasequery which is like a superset of the fetch function.We pass in the base url there which is the main url of our server

?New anime power:A character that can reproduce favourable conditions which may be helpful
?New anime power:version control like git to revert to any state to recover from damage
?New anime power:pipes:The only use of this is to temporary create flexible pipes in his body that can act as blood vessels and control the pressure of those pipes to pulse blood without a heart
?New anime power:Characters can create paradoxes that can protect them because anybody that forces their way through a paradox will tear the universe.

*The first argument to the async thunk is the action payload.The second argument to the async thunk is an object that provides utilities like dispatch and get state and for normal thunks,they also only accept one payload

*reducers decides how the state changes in response to actions meaning that they are the only ones allowed to modify state

*The action string for async thunks is just a unique identifier for it only used by rtk for generating the action objects for the async states

*Extra reducers is for adding a function that can create reducer cases.The builder object in this function is used to add cases for creating direct mappings of action strings to arrow functions which are anonymous reducers.In an async thunk,createAsyncThunk automatically creates the pending,fulfilled and rejected properties which holds the action objects for those life cycle parts.These gets dispatched depending on the state of the promise.

*Async thunks are action creators that returns promises.They are used for dispatching actions based on the life cycle of promises.The action string used in async thunks is a unique identifier that rtk will use for the pending,fullfileed and failed life cycle states.

*A thunk can dispatch multiple actions

*null and ? like operations:null coalescing,logical or operator,optional chaining,ternary operator
?state retention,persistence,management,binding,mutation

*local state management
*Parent state management
*Context
*Atomic state management
*Redux 

*Url state management is for state persistence across page reloads

*Each of these paradigms have an sigmoid scalability-complexity curve.I think of a scalability as an imaginary function that takes into account of factors liek ease of use,capability,practical uses,etc

*local state management has a scalability curve of 100 till the complexity demands a global scope for state

*Atomic state management is where shared state is split into atoms which are independent state units that can be read and written to directly by components.They are decentralized meaning that they do not need to be provided by a parent to be used in the app

*The best part of context is that it prevents prop drilling.Contexts and redux store are provided almost the same way except that you can have many contexts but only one redux store.In redux,the store is separate from the component tree,meaning that components can subscribe to the particular state that they need from the store and they can be unaware of the state tree but for context,the components must be aware of the context data they are consuming and change in context data will lead to re-renders thus,impacting performance.For contexts,you are forced to create multiple contexts leaving some state management to the individual parents that provide it because if we use a single object as the context that holds all the global state for our app,change in one state will cause a full re-render of the others since they are in the same object that has changed leading to more performance issues

*In contexts,global data has to be splitted into many contexts and provided by separate parent components but for redux,the store can be provided to the root component.The higher the complexity of sharing context,the more the context has to be lifted up which will cause performance issues and tight coupling of components

*RTK query,RTK listeners,async thunks

context api is used with useReducers
?Teardown,lay of the lands,lego fortnite

*There are creators and the obejcet itself.A creator returns that object.So an action creator can return a plain action object or a thunk which is a function that allows us to perform side effect operations and computations.

*Middlewares can be chained

*A thunk is a term for a function that delays a computation till its needed and in the case of redux,it can delay the dispatch of an action based on computations.A thunk can allow you to accept arguments besides plain action objects like promises which will then later on dispatch real action object and create side effects

*Redux thunks are used for writing async logic.Redux Thunks are action creators that returns a function instead of a plain action object called a thunk.It is a middleware that sits in between a dispatched action and a reducer

*Reducers have the rule of being pure functions to always create predicatble behaviour
*When you dispatch an action to a store,redux uses the prefix of the action's type to determine which slice to map the action to.Thats why the key of the slice must match the name of the slice

*An action is just an object with a type and payload.They are implicitly created by redux toolkit with the name convention of their type being slice name/reducer for that action.An action craetor returns an action object and th dispatch submits that action object to the store

*reducers under the hood dont mutate state but rather use the immer library to do immutable operations

*A slice is like a route for a server.it represents a share in the store's state.Therefore,a reducer is like a controller

*so when we say counter:counterReducer in our store setup,we say that it should assign all state managment of that section to the reducer

*Each feature with its own slice and reducers
*A selector is a function that extracts a particular state from a store

*A reducer is a function that calculates the new state using the old state and an action.They must be pure meaning that they always produce the same output for the same action input given that the old state is the same.Therefore,no side effects,no random values,no async operations

*An action creator is a function that returns an action object and thus,using dispatch creates an action object using the action creator and send that action to the store

*Redux uses immutability with the immer library to ensure operation safety and preducatbility
*Redux uses the global state paradigm where state is separated from the component tree in a place called the store

*The context paradigm,the global state paradigm


*before state management,state was lifted up to parents and passed down as props to children and then use context api to prevent prop drilling

*next js adds server side logic to your react.
*Url state management also prevents the need for complex state management

*The term reducer as used in redux comes from the reduce function in functional programming.
^Learn more about functional programming

*The difference between context and store is that in context,the components that wants to use its state must be inside the context but for global state management,the store is separate from the component allowing you to access its state regardless of where your components are located

*Local state,props,prop drilling for shared state,context api,useReducer for reducers

*Context api is a low level version of global state management in react,svelete and other frontend frameworks.For svelete,the modern way is stores

*Use Service.msc to start mongo db locally and you can change the port by using mongod.cf in the bin of the mongosb folder on the disk and for the atlas,go to monog db compass then paste your connection tsring and change the password to the right one and then scroll down to advanced options and in there,you will see an authroization heading.scroll down and also change the password field there.Copy the connection string and use it in mongoose to fix that authentication error

*the name of the slice object is used to prefix the actions
*default imports can be named anything you like on import

*The actions property maps reducers to actions.The reducer property wraps all the reducers into one root reducer

*A store is an object containing the applications state which is a key-value collection of every state in the app or a slice of the app's state.You can write multiple reducers that combines into one single root reducer.The reducer is the one that directly modifies the state.The action object is like a request that tells the reducer what to do with the state.

*Action,reducer and state

*So for pure hosting,focus on both hardware and software.for Iaas,focus on everything software.for Paas,only focus on coding and forget about setup and for Baas,focus on frontend more as the provider handles common backend chores

*Iaas-infrastructure service
*Paas--app development service
*self hosting,pure hosting service,cloud hosting

*The developer is separate from the provider.The provider is responsible for managing the infrastructure while the developer is responsible for the app itself.A pure service doesnt offer things like scalability.When a provider delivers services to the povider like scalability,it becomes a cloud service

*A regular service is a fixed service that doesnt increase on demand


*web app and a cloud app.A web app like a cloud app is hosted by a provider and can only be accessed online but a web app only becomes a cloud app when it delivers services within the scope of cloud principles

?Paas,Iaas,Baas,Saas

*Session data consists of all the inpersitent data stored in the frontend throughout its use and some of it can be persisted through cookies,session apis,etc

*frontend uses two types of state:ui and variable state.in general,ui states are mainly reflected in the ui but can also influence rendering while variable states arent reflected in the ui but are used for the frontend's logic and can influence ui rendering


*backend requires a full restart per change as it is stateless but the frontend doesnt since it retains state and thus uses hmr.This is because frontend is stateful but not persistent and backend is both stateless and not persistent.So a db is the only solution for a persitent storage of state and im guessing the reason why frontend state isnt persistent is that it is only used for updating the ui and only end data is stored in the db

*Hmr in web bundlers works with the file watcher by not requiring a full page reload per change.It does this by only updating the modules that were edited leading to performance boost and reservation of state

*Nodemon and tsc compiler are file watchers.File watchers--compiler,browser refresher,rerun a script.

*so bundlers package all your frontend code and its dependencies into a single file with extra features like code optimization,real time refreshes and tree shaking.

*live server
*Context api and use reducer hooks are like low level verions of Redux

*Frontend frameworks use a compiler to convert their code into vanilla js.For react,it is babel although babel is primarily for compiling js to a backwards compatible version while others use their own compilers.The compilers convert Component written code to DOM manipulation which is its superset.Component written code is just html in javascript where js can directly manipulate that html


^Dont forget about user stories

*a template builder is a tool that scaffolds an application for developmen like svelte kit,next js
*a module,library,framework,template builder

^Tech stack quality check.It gives a score gotten from comparing how good your custom tech stack is to how good it will fulfill a project idea using user-defined metrics for the project through using data submitted from a detailed form about the project and using predefined metrics for the tech stack quality against fulfilling that project using data about each technology against the context it is being used for and how well it works with the others for fullfilling a task and secondly.Users can also emphasize which part of the form data is the most important for checking against the stack and another feature is the kanban board which will be used for the developer's skill assessment to check if he has the skills to fullfill the stack.The purpose of this app is to complement decision making

?Vite or next js installer for react

*mongo db is document oriented

*graph ql allows you to control how the response object should look like and merge multiple request sinto one meaning you can request for what you specifically ask for over allowing an http server decide the response object for you which typically sends you the whole data leaving it to the fronyend to filter out the data it needs.With a normal http server,you have to create separate api endpoints for every precise data you wnt like how i have load all boards and load a board as separate requests which is inefficient.with graphql you can freakin batch requests unlike rest.graph ql ships errors in the response object and not through status codes and as such,errors can be treated as value.Rest apis deliver static responses but graphql allows us to make that dynamic but the dynamism of  graphq can lead to inconsistent responses per request body unlike rest apis that are indempotent which guves the same response for the same request regarless of how many times it is requested.  

*in rest apis/http servers,urls are used to define resources on the cloud
I want to research on the app i want to make,use ai software designer,watch yt videos on how to work about the app

vercel them are infrastructure as a service
electron,deployment and hosting,docker

Docker and kubernetes,graphql,Terraform with Azure,hostinger

Azure for various cloud services

docker is for containerizing backend services and its dependencies in an isolated environment allowing you to use it on another machine without ever worrying about reinstalling dependencies,environment setup and whether it works on your machine and not on others.it will make it work on any machine the same way as yours regardless of os.


*sessions are just a way to manage temprorary state in a server
*Because servers dont retain states,the request has to contain the full data to ensure requests are independent
*servers are completely statless and they need a database to retain state while components are stateful but lose their state once they are destroyed unless stored in a database

?LAN setup.listen on all ports,allow node js through firewall,use local ip on external machine

*use flex shrink-0 to ensure images dont shrink
*In a boolean array holding selected values,only one can be selected at a time but more than one can be deselected at a time

Client bounding rect returns the element's surface area and relative position to the viewport
*The dimensionality of data increases as the app becomes more complex
?pick tool,time,burn down charts,custom columns

*react uses functional component structure while svelte uses sfcs
*Ill only use python for app intelligence using data science and machine learning

*In js,logical operators unlike python returns the original values rather than the boolean values.They only get implicitly converted to boolean values in condition checks.The and operator returns the first falsy value it finds and for or,the first truthy value it finds and they both return the last values if all operands are truthy or falsy which allows for short circuiting condition checks.And there are logical assignment operator which does both assignment and logical evaluation in a shorter expression

*ill use stores and a one push and pull architecture

Normal people when they see it: ü•±
Developers when they see it: üßêü§îü´°üòÆ‚Äçüí®üóø


*svelte binding and stores
The most independent parts of the program must be coded first before the dependent ones
The server should be operationally feature based while the frontend shouldbe visually feature based
Use a boolean array to check for selected values and apply styles based on them
ai--utility snippet maker
I have to use indexed db as a fallback to the server.immediately there is connection,the data is synced with the server
!Not so scalable architecture:Refresh cycle and lever system
so my architecture is this:for A:pull initial data(data that was saved from using the app previously),push new data and dynamically tag data based on interactions while for component B:load intitial data,pull the tagged data and using an effect hook to always pull data whenever A pushes.The parent uses a store.i call the store a lever because it only flicks between true or false.So when A pushes data,it flicks it on or set the store's value to true,then the parent will then pass a state that is subscribed to the lever as a prop to B which uses the effect hook to always listen for when the prop changes to always pull data whenever A pushes.The only prop a component will listen to is the one that will notify it whenver A has pushed to the server and also,after A pushes and sets the lever to true,it then immediately on the next line toggle it to false so that the next push will toggle it again for B to listen to.I am also going to use stores for more than just levers.Anything shareable at this point should use one.The point of levers is to sync components an other stores like numbers or strings for sharing values wuth other components in real time.

component based architecture uses reactive and event driven programming

class: directive in svelte
You can only read the response body text
Operation safety can increase performance by preventing unecessary computations
Request safety and operation safety

Not adhering to the interface when sending request data can lead to errors
*Types of storage:cookies,sessions,local storage,database
GET and DELETE: Use query strings and path parameters.
POST and PUT: Use the request body to send data.
Operation safety
nest js is based on angular and is opionated while express is unopinionated

so there is a difference between using the downloaded and the deployed version of an app.In the deployed version,the client doesnt download anything,the frontend is deployed on something like vercel and the backend is hosted on a hosting playform like hostinger and the data can be stored on a cloud service while in the downloaded version,it can be fully contained but the backend must use a local storage db like sql lite or indexed db i.e both the front and backend or a mix where the frontend is downloaded but the backend is hosted on a hosting platform

Mongodb atlas,Aws,google cloud services,Azure

?API versioning
?Communicating api version between client and server
?Version control middleware
?Service worker for update checks

Object vs relational database 
Document vs Table database

Deploy the frontend
Host the backend
Cloud service to store backend's data

You can use logical operators,guard clauses and early returns to shorten if statements

render for hosting backend and vercel for frontend
canvas tag for drawing graphics in an html page using js

graphiql
get exactly what you want
Dgraph database
?we use npm install to install project dependencies as dictated by the package.json
myG1thu61234$$#

shiny object syndrome
Python--forensics,data science,machine learning,cyber security,networking

Auto save
watch compiler
live runner

HTML notebook--a notebook but you write the notes with html which allows yoy to make a webpage as a notebook
zod schema validation library.Schema defines the structure and constraint of data for validation and integrity--validation logic
DTO is for shaping the data structure sent over a request/response 
type interfaces doesnt enforce runtime validation--purely type checking

the unknown type is safer than the any type because you have to narrow it down to a type before using the value unlike the any.We use it fo rvalue sthat we dont know at compile time
nest js decorators
null safety
havent learnt regex yet
HTTP protocol and mvc architecture,component based architecture
the process module for controlling the lifdecycle of a program
package.json
*FOLDER STRUCTURE OF FRONTEND
*FOLDER STRUCTURE OF BACKEND


copy my tsconfig.json from the mongoose-ref folder across all ts projects

Router--mounts/maps controllers to a route
view
controller--routehandlers and middleware
model

http server vs tcp server
obsidian,codieum,beehive,heatmap ai,readme.so
perplexity ai

*local  and pinno for js
json.stringify tells js to covert an object to its json string and not the string as dictated by the string dunder method
Dynamic import only imports code when the user needs it
coolors
Check on pinno

Environments
-------------
Browser
Interpreted environments
System environment
Db engine
game engine

*After this web dev,ill go back tp python---C# and Java---low level ones

!There is PyPy,Cython and now Mojo
cursor code editor
coolors.co web


Mongo db environments
----------------------
Mongo db Atlas--cloud service for mongo db
Mongo db entreprise edition
Mongo db community edition


UI--atlas ui,compass ui
Shell---mongosh,Mongo db vs code playground
script--Mongo db shell contained in a js file
Mongo db drivers---mongodb npm package,mongoose


invincible 
murder drones


typo error
Hard drive,laptop
jsdom
markdown for docs like readme files
.env files are for declaring environment variables 
glob pattern
cookies are already in express js
In my online shop,if you want to add an item visually and not through the json file,i can connect my frontend with my backend using a post request.The server will then parse it into the json file


for ts in code runner:tsc & node
: typeof import('http')
etc,api protocols,authentication,api security.HTTP request are done through apis like fetch api for js and request for python
Svelte is much more declarative than react
in svelte,we use stores for shared state,check on jotai for react
state,props,two way data binding,context,stores,modules

null coalescing operator prevents errors that come from null objects in advance
Typescript scales Javascript because you can craft a type system
Typescript just makes js type safe and thherefore preventing errors before running the code

sync code,microtasks,macrotask,callbacks,promises--executor and consumers,os operations,async functions,await keyword
online delivery analogy for api
Remake my file sender using web sockets and async code
awaited ops are microtasks
The promise itself has its own function
abstraction
A promise maintains state.it takes an executor function that modifies a state

Async functions always return a promise and are non blocking and allow the use of the wait keyword
synchronous code,micro tasks,macro tasks

are functions with the async keyword a micro task

HTTP requests,Rest,CRUD,100,200,300,an inempotent operation is like a pure function but for crud ops,stateless ops.
Pagination,GraphQL
Web sockets are the web implementation of the sockets i used in python.It means that once i learn web sockets,i can create a full blown file sender app with gui and everything anot to mention promises.
sockets and apis are easier implementations of establishing communication between different softwares
GraphQL is like SQL but for APIS

Hard coded vs dynamic
Algol--C--the rest liek python
Install ts compiler through npm and use this cmd in pkg.json:
{
    "scripts": {
        "watch":"tsc --watch",
        "ts": "node script.js"
    }
}
use the at method to access negative indexes in arrays in js
install concurrently to run multiple cmd at the same time
Dvh
Svelte has two way data binding using the bind dirtective--GG

Svelte's routing is the best of both worlds:seamless SPA experience but ssr
Quick snippets--like tailwind but utility snippets that is just as customizable
node js is like nest js for node
express js

page server is the same as page client buit for operations that shouldnt be exposed to the client. ie only on the server
The page server loads first and returns whatever data it has to the client.
OMO!!Use all my codes as ref

position relative doesnt remove the space the element takes in it container
context,script modules,page and layout data
use this: data-sveltekit-noscroll to maintain scroll position when routing

+page.svelte--for data in a page and +layout.svelte for common stuffs between webpages
Array.from method for the each block in svelte

Can write a storybook--use .js extension
no error highlighting--dont install eslint
made fonts possible---used preview-head.html and paste the font links and select the font name class
props--i forgot to interpolate props in back ticks
staticDirs: ['../static'] and a restart.to make images work
import '../src/app.css'; for tailwind classes to work
Default.parameters = {
  layout: 'centered', // Center this specific story
}; for centering your stories


for using tailwind styles in storybook,i have to import the global css styles into it and for font in svelte,paste the link in page.html and extend tailwinds them to include the fonts
custom css and js extension for vs code
dribble.com for web designs

We use maps for loop rendering in react
Anything that has the length property in js is treated as an array
The same way images in react can only be placed in the public folder,for svelte it is in the static folder
gitignore file.
knowing how to get to somewhere from somewhere
I have to learn cyber security
study pattern--using notes---Ill move to obsidian notes very soon---OBSIDIAN,JUPYTER NOTEBOOK
Reading for Jamb


So svelte files use SFCs
script type=module
jsx is syntatic sugar for js function calls

retrace

I can use post css to get styled components to use the @apply rule creating tailwind vue styled components
I can create a styled component that inherits from multiple onres through string interpolation
Separation of concerns.All my styled components go in one dir,text content in another dir while the markup and script in one component place.Ill use json for the text content
ill use front end js lib for my games ui
A bot that can beat reCaptcha

<!--
For mobie,it is all about prioritizing content over ui
min width and max width
Imperative vs Declarative

Tailsasscss--For responsive designs
I use react for form validation over normal js
Tailwind uses atomic classes
Semantic html
Ill export my styled components all into a buffer so that i can reuse components i have made before.It will be my own bootstrap.
Tailwind dark theme
git revert

flex grow,shrink and wrap to be used with responsive design
extend and override themes for responsive design
query strings formy multi step form
hamburger menu
free pik
I love 4k astronaut wallpapers
-->


tailwind container tag
meta frameworks
session,cookies storage
A very interactive jupyter notebook doc of web dev



spa--client side rendering
interactive ui--two way flow of information
CDN,web sever
view layer,back end layer


STATIC RENDERED WEB APPS 
--------------------------
Pre generated
No server requests
Can not change dynamically.Changes involves a rebuild process
storage bucket--point a domain name
use huggo,jekyll


MULTI-PAGE WEB APPS
--------------------
Server side requests
Content can change dynamically
Use django,ruby on rails


SINGLE PAGE APPS
----------------
One html shell page.
js updates the page through http requests
big js bundle and higher initial load times
poor seo

SSR
----
Initial request is on the server and the page is made dynamically and js takes over to render it to the client.
MPA + SPA =SSR


SSG
----
pre render all html pages and hydrate to js after initial page loads.Redeploy whenever your site changes
Static + SPA

Hydration,Partial hydration,Island


NOTEBOOK-DAD AND PHYSICAL
Variations of the same image
there is an error when reloading the page because of a variable in order +page being initially undefined

snippet js--a syntatic sugar for function calls using comments tagged with todo

states
props
two way data binding
context
stores

dribble.com for web designs

WHAT I LEARNT IN DETAIL
Apis 
Async programming
Typescript
errors
feature based folder structure


ERRORS STUFF
Type checking
Linting

Exception handling blocks

Well Documented functions
Proper prep of the algorithm
Deep knowledge about the pl,framework and coding environment
Testing
logging
debugging

reproducing errors


OTHER STUFFS
commit message types:chore,fix,docs,feat
technical and features folder structure with directory diagram

Scaling

the build process
provide a coloring 


so abstracted from reality that you can only interact with them via a proxy
behave test for js

