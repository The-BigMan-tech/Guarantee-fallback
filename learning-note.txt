*Use Service.msc to start mongo db locally and you can change the port by using mongod.cf in the bin of the mongosb folder on the disk and for the atlas,go to monog db compass then paste your connection tsring and change the password to the right one and then scroll down to advanced options and in there,you will see an authroization heading.scroll down and also change the password field there.Copy the connection string and use it in mongoose

*the name of the slice object is used to prefix the actions
*default imports can be named anything you like on import

*The actions property maps reducers to actions.The reducer property wraps all the reducers into one root reducer

*A store is an object containing the applications state which is a key-value collection of every state in the app or a slice of the app's state.You can write multiple reducers that combines into one single root reducer.The reducer is the one that directly modifies the state.The action object is like a request that tells the reducer what to do with the state.

*Action,reducer and state


*So for pure hosting,focus on both hardware and software.for Iaas,focus on everything software.for Paas,only focus on coding and forget about setup and for Baas,focus on frontend more as the provider handles common backend chores

*Iaas-infrastructure service
*Paas--app development service
*self hosting,pure hosting service,cloud hosting

*The developer is separate from the provider.The provider is responsible for managing the infrastructure while the developer is responsible for the app itself.A pure service doesnt offer things like scalability.When a provider delivers services to the povider like scalability,it becomes a cloud service

*A regular service is a fixed service that doesnt increase on demand


*web app and a cloud app.A web app like a cloud app is hosted by a provider and can only be accessed online but a web app only becomes a cloud app when it delivers services within the scope of cloud principles

?Paas,Iaas,Baas,Saas

*Session data consists of all the inpersitent data stored in the frontend throughout its use and some of it can be persisted through cookies,session apis,etc

*frontend uses two types of state:ui and variable state.in general,ui states are mainly reflected in the ui but can also influence rendering while variable states arent reflected in the ui but are used for the frontend's logic and can influence ui rendering


*backend requires a full restart per change as it is stateless but the frontend doesnt since it retains state and thus uses hmr.This is because frontend is stateful but not persistent and backend is both stateless and not persistent.So a db is the only solution for a persitent storage of state and im guessing the reason why frontend state isnt persistent is that it is only used for updating the ui and only end data is stored in the db

*Hmr in web bundlers works with the file watcher by not requiring a full page reload per change.It does this by only updating the modules that were edited leading to performance boost and reservation of state

*File watchers--compile,refresh the browser,rerun a script

*so bundlers package all your frontend code and its dependencies into a single file with extra features like code optimization,real time refreshes and tree shaking.

*live server
*Context api and use reducer hooks are like low level verions of Redux

*Frontend frameworks use a compiler to convert their code into vanilla js.For react,it is babel although babel is primarily for compiling js to a backwards compatible version while others use their own compilers.The compilers convert Component written code to DOM manipulation which is its superset.

^Dont forget about user stories

*a template builder is a tool that scaffolds an application for developmen like svelte kit,next js
*a module,library,framework,template builder

^Tech stack quality check.It gives a score gotten from comparing how good your custom tech stack is to how good it will fulfill a project idea using user-defined metrics for the project through using data submitted from a detailed form about the project and using predefined metrics for the tech stack quality against fulfilling that project using data about each technology against the context it is being used for and how well it works with the others for fullfilling a task and secondly.Users can also emphasize which part of the form data is the most important for checking against the stack and another feature is the kanban board which will be used for the developer's skill assessment to check if he has the skills to fullfill the stack.The purpose of this app is to complement decision making

?Vite or next js installer for react

*mongo db is document oriented

*graph ql allows you to control how the response object should look like and merge multiple request sinto one meaning you can request for what you specifically ask for over allowing an http server decide the response object for you which typically sends you the whole data leaving it to the fronyend to filter out the data it needs.With a normal http server,you have to create separate api endpoints for every precise data you wnt like how i have load all boards and load a board as separate requests which is inefficient.with graphql you can freakin batch requests unlike rest.graph ql ships errors in the response object and not through status codes and as such,errors can be treated as value.Rest apis deliver static responses but graphql allows us to make that dynamic but the dynamism of  graphq can lead to inconsistent responses per request body unlike rest apis that are indempotent which guves the same response for the same request regarless of how many times it is requested.  

*in rest apis/http servers,urls are used to define resources on the cloud
I want to research on the app i want to make,use ai software designer,watch yt videos on how to work about the app

vercel them are infrastructure as a service
electron,deployment and hosting,docker

Docker and kubernetes,graphql,Terraform with Azure,hostinger

Azure for various cloud services

docker is for containerizing backend services and its dependencies in an isolated environment allowing you to use it on another machine without ever worrying about reinstalling dependencies,environment setup and whether it works on your machine and not on others.it will make it work on any machine the same way as yours regardless of os.


*sessions are just a way to manage temprorary state in a server
*Because servers dont retain states,the request has to contain the full data to ensure requests are independent
*servers are completely statless and they need a database to retain state while components are stateful but lose their state once they are destroyed unless stored in a database

?LAN setup.listen on all ports,allow node js through firewall,use local ip on external machine

*use flex shrink-0 to ensure images dont shrink
*In a boolean array holding selected values,only one can be selected at a time but more than one can be deselected at a time

Client bounding rect returns the element's surface area and relative position to the viewport
*The dimensionality of data increases as the app becomes more complex
?pick tool,time,burn down charts,custom columns

*react uses functional component structure while svelte uses sfcs
*Ill only use python for app intelligence using data science and machine learning

*In js,logical operators unlike python returns the original values rather than the boolean values.They only get implicitly converted to boolean values in condition checks.The and operator returns the first falsy value it finds and for or,the first truthy value it finds and they both return the last values if all operands are truthy or falsy which allows for short circuiting condition checks.And there are logical assignment operator which does both assignment and logical evaluation in a shorter expression

*ill use stores and a one push and pull architecture

Normal people when they see it: ü•±
Developers when they see it: üßêü§îü´°üòÆ‚Äçüí®üóø


*svelte binding and stores
The most independent parts of the program must be coded first before the dependent ones
The server should be operationally feature based while the frontend shouldbe visually feature based
Use a boolean array to check for selected values and apply styles based on them
ai--utility snippet maker
I have to use indexed db as a fallback to the server.immediately there is connection,the data is synced with the server
!Not so scalable architecture:Refresh cycle and lever system
so my architecture is this:for A:pull initial data(data that was saved from using the app previously),push new data and dynamically tag data based on interactions while for component B:load intitial data,pull the tagged data and using an effect hook to always pull data whenever A pushes.The parent uses a store.i call the store a lever because it only flicks between true or false.So when A pushes data,it flicks it on or set the store's value to true,then the parent will then pass a state that is subscribed to the lever as a prop to B which uses the effect hook to always listen for when the prop changes to always pull data whenever A pushes.The only prop a component will listen to is the one that will notify it whenver A has pushed to the server and also,after A pushes and sets the lever to true,it then immediately on the next line toggle it to false so that the next push will toggle it again for B to listen to.I am also going to use stores for more than just levers.Anything shareable at this point should use one.The point of levers is to sync components an other stores like numbers or strings for sharing values wuth other components in real time.

component based architecture uses reactive and event driven programming

class: directive in svelte
You can only read the response body text
Operation safety can increase performance by preventing unecessary computations
Request safety and operation safety

Not adhering to the interface when sending request data can lead to errors
*Types of storage:cookies,sessions,local storage,database
GET and DELETE: Use query strings and path parameters.
POST and PUT: Use the request body to send data.
Operation safety
nest js is based on angular and is opionated while express is unopinionated

so there is a difference between using the downloaded and the deployed version of an app.In the deployed version,the client doesnt download anything,the frontend is deployed on something like vercel and the backend is hosted on a hosting playform like hostinger and the data can be stored on a cloud service while in the downloaded version,it can be fully contained but the backend must use a local storage db like sql lite or indexed db i.e both the front and backend or a mix where the frontend is downloaded but the backend is hosted on a hosting platform

Mongodb atlas,Aws,google cloud services,Azure

?API versioning
?Communicating api version between client and server
?Version control middleware
?Service worker for update checks

Object vs relational database 
Document vs Table database

Deploy the frontend
Host the backend
Cloud service to store backend's data

You can use logical operators,guard clauses and early returns to shorten if statements

render for hosting backend and vercel for frontend
canvas tag for drawing graphics in an html page using js

graphiql
get exactly what you want
Dgraph database
?we use npm install to install project dependencies as dictated by the package.json
myG1thu61234$$#

shiny object syndrome
Python--forensics,data science,machine learning,cyber security,networking

Auto save
watch compiler
live runner

HTML notebook--a notebook but you write the notes with html which allows yoy to make a webpage as a notebook
zod schema validation library.Schema defines the structure and constraint of data for validation and integrity--validation logic
DTO is for shaping the data structure sent over a request/response 
type interfaces doesnt enforce runtime validation--purely type checking

the unknown type is safer than the any type because you have to narrow it down to a type before using the value unlike the any.We use it fo rvalue sthat we dont know at compile time
nest js decorators
null safety
havent learnt regex yet
HTTP protocol and mvc architecture,component based architecture
the process module for controlling the lifdecycle of a program
package.json
*FOLDER STRUCTURE OF FRONTEND
*FOLDER STRUCTURE OF BACKEND


copy my tsconfig.json from the mongoose-ref folder across all ts projects

Router--mounts/maps controllers to a route
view
controller--routehandlers and middleware
model

http server vs tcp server
obsidian,codieum,beehive,heatmap ai,readme.so
perplexity ai

*local  and pinno for js
json.stringify tells js to covert an object to its json string and not the string as dictated by the string dunder method
Dynamic import only imports code when the user needs it
coolors
Check on pinno

Environments
-------------
Browser
Interpreted environments
System environment
Db engine
game engine

*After this web dev,ill go back tp python---C# and Java---low level ones

!There is PyPy,Cython and now Mojo
cursor code editor
coolors.co web


Mongo db environments
----------------------
Mongo db Atlas--cloud service for mongo db
Mongo db entreprise edition
Mongo db community edition


UI--atlas ui,compass ui
Shell---mongosh,Mongo db vs code playground
script--Mongo db shell contained in a js file
Mongo db drivers---mongodb npm package,mongoose


invincible 
murder drones


typo error
Hard drive,laptop
jsdom
markdown for docs like readme files
.env files are for declaring environment variables 
glob pattern
cookies are already in express js
In my online shop,if you want to add an item visually and not through the json file,i can connect my frontend with my backend using a post request.The server will then parse it into the json file


for ts in code runner:tsc & node
: typeof import('http')
etc,api protocols,authentication,api security.HTTP request are done through apis like fetch api for js and request for python
Svelte is much more declarative than react
in svelte,we use stores for shared state,check on jotai for react
state,props,two way data binding,context,stores,modules

null coalescing operator prevents errors that come from null objects in advance
Typescript scales Javascript because you can craft a type system
Typescript just makes js type safe and thherefore preventing errors before running the code

sync code,microtasks,macrotask,callbacks,promises--executor and consumers,os operations,async functions,await keyword
online delivery analogy for api
Remake my file sender using web sockets and async code
awaited ops are microtasks
The promise itself has its own function
abstraction
A promise maintains state.it takes an executor function that modifies a state

Async functions always return a promise and are non blocking and allow the use of the wait keyword
synchronous code,micro tasks,macro tasks

are functions with the async keyword a micro task

HTTP requests,Rest,CRUD,100,200,300,an inempotent operation is like a pure function but for crud ops,stateless ops.
Pagination,GraphQL
Web sockets are the web implementation of the sockets i used in python.It means that once i learn web sockets,i can create a full blown file sender app with gui and everything anot to mention promises.
sockets and apis are easier implementations of establishing communication between different softwares
GraphQL is like SQL but for APIS

Hard coded vs dynamic
Algol--C--the rest liek python
Install ts compiler through npm and use this cmd in pkg.json:
{
    "scripts": {
        "watch":"tsc --watch",
        "ts": "node script.js"
    }
}
use the at method to access negative indexes in arrays in js
install concurrently to run multiple cmd at the same time
Dvh
Svelte has two way data binding using the bind dirtective--GG

Svelte's routing is the best of both worlds:seamless SPA experience but ssr
Quick snippets--like tailwind but utility snippets that is just as customizable
node js is like nest js for node
express js

page server is the same as page client buit for operations that shouldnt be exposed to the client. ie only on the server
The page server loads first and returns whatever data it has to the client.
OMO!!Use all my codes as ref

position relative doesnt remove the space the element takes in it container
context,script modules,page and layout data
use this: data-sveltekit-noscroll to maintain scroll position when routing

+page.svelte--for data in a page and +layout.svelte for common stuffs between webpages
Array.from method for the each block in svelte

Can write a storybook--use .js extension
no error highlighting--dont install eslint
made fonts possible---used preview-head.html and paste the font links and select the font name class
props--i forgot to interpolate props in back ticks
staticDirs: ['../static'] and a restart.to make images work
import '../src/app.css'; for tailwind classes to work
Default.parameters = {
  layout: 'centered', // Center this specific story
}; for centering your stories


for using tailwind styles in storybook,i have to import the global css styles into it and for font in svelte,paste the link in page.html and extend tailwinds them to include the fonts
custom css and js extension for vs code
dribble.com for web designs

We use maps for loop rendering in react
Anything that has the length property in js is treated as an array
The same way images in react can only be placed in the public folder,for svelte it is in the static folder
gitignore file.
knowing how to get to somewhere from somewhere
I have to learn cyber security
study pattern--using notes---Ill move to obsidian notes very soon---OBSIDIAN,JUPYTER NOTEBOOK
Reading for Jamb


So svelte files use SFCs
script type=module
jsx is syntatic sugar for js function calls

retrace

I can use post css to get styled components to use the @apply rule creating tailwind vue styled components
I can create a styled component that inherits from multiple onres through string interpolation
Separation of concerns.All my styled components go in one dir,text content in another dir while the markup and script in one component place.Ill use json for the text content
ill use front end js lib for my games ui
A bot that can beat reCaptcha

<!--
For mobie,it is all about prioritizing content over ui
min width and max width
Imperative vs Declarative

Tailsasscss--For responsive designs
I use react for form validation over normal js
Tailwind uses atomic classes
Semantic html
Ill export my styled components all into a buffer so that i can reuse components i have made before.It will be my own bootstrap.
Tailwind dark theme
git revert

flex grow,shrink and wrap to be used with responsive design
extend and override themes for responsive design
query strings formy multi step form
hamburger menu
free pik
I love 4k astronaut wallpapers
-->


tailwind container tag
meta frameworks
session,cookies storage
A very interactive jupyter notebook doc of web dev



spa--client side rendering
interactive ui--two way flow of information
CDN,web sever
view layer,back end layer


STATIC RENDERED WEB APPS 
--------------------------
Pre generated
No server requests
Can not change dynamically.Changes involves a rebuild process
storage bucket--point a domain name
use huggo,jekyll


MULTI-PAGE WEB APPS
--------------------
Server side requests
Content can change dynamically
Use django,ruby on rails


SINGLE PAGE APPS
----------------
One html shell page.
js updates the page through http requests
big js bundle and higher initial load times
poor seo

SSR
----
Initial request is on the server and the page is made dynamically and js takes over to render it to the client.
MPA + SPA =SSR


SSG
----
pre render all html pages and hydrate to js after initial page loads.Redeploy whenever your site changes
Static + SPA

Hydration,Partial hydration,Island


NOTEBOOK-DAD AND PHYSICAL
Variations of the same image
there is an error when reloading the page because of a variable in order +page being initially undefined

snippet js--a syntatic sugar for function calls using comments tagged with todo

states
props
two way data binding
context
stores

dribble.com for web designs

WHAT I LEARNT IN DETAIL
Apis 
Async programming
Typescript
errors
feature based folder structure


ERRORS STUFF
Type checking
Linting

Exception handling blocks

Well Documented functions
Proper prep of the algorithm
Deep knowledge about the pl,framework and coding environment
Testing
logging
debugging

reproducing errors


OTHER STUFFS
commit message types:chore,fix,docs,feat
technical and features folder structure with directory diagram

Scaling

the build process
provide a coloring 


so abstracted from reality that you can only interact with them via a proxy
behave test for js

