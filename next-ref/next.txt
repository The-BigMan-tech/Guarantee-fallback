*Web apps are instantly accessible unlike desktop apps and for desktop apps,you have to think of how you will handle updates

todo:Know how to automatically handle desktop app updates

*Tauri is react and rust for the backend

*Tauri does not run a node js environment but rather,it uses a web view and rust for its backend and as such,it can only a client side react app and not a next js app.It instead uses rust for its backend while electron js can run full next js apps cuz it uses the node js environemnt as well as chromium to make desktop apps

*Tauri compiles your app to binaries that are only target the machine its compiling on and uses the sytem's built in webview and as such,the users dont need to download anything to run the app while electron uses the chromium and an in built node js env making users to install the app without any additional packages

*Docker container,web app,desktop app

todo:NodeGUI
todo:Fix my syntax coloring.it sucks a little bit

*blockbench is made with vue,three js and electron
*The await keyword is for telling an async operation to run only when another async operation has finished

*concurrently is for running cmds in separate terminals
*Tauri for react apps and electron for next js apps

*I used concurrently to start my electron app window

*WHen building your desktop web app,you have to build the web app using the bundler and connect it to either electron or tauri

todo:electron builder

*admin dashboards are best done with next js

*No rendering strategy is a superset of the other.They just borrow techniques from each other to make their own pattern

todo:DOM purify
todo:Marked js

*Next js is a complimentary set to react while typescript is a superset of js.Complimentary and supersets are different.

*In next js,the page is the entry point.Any component that isnt a page or a folder that is prefixed with underscore to be declared as private isnt routable.

^Im separating my component logic into hooks in private folders only if it warrants doing so and leave my components to only render the ui

*Route groups are folders that wont be part of the route.its only for organizational purposes


^I'll use the app directory for storing the page files aka for routing purposes,the lib folder for shared logic like hooks and components and the components folder for the components in a feature based style.The app folder will have a corresponding fetaure based structure where each page.tsx is an entry point for assembling the raw components from the components folder from the respective feature into a single route.So my app folder is purely for routing and assembly point purposes.

*A layout is a component that takes another component as a prop and it can be accessed via the children property of its prop.It automatically takes a page as child and its for consistent styling across pages.


*Understanding someone else's codebase
Comments
Docstrings
Good variable names
Type Safety:Type annotations and Linter like eslint and error lens


*Understanding the behaviour of the codebase
Error messages:through error handlers or the stack trace
Logs
Step through debugging
Tests

*You can pass a state,a state setter or a component to another component but only the layout can accept another component

*The Image component from next js is lazy loaded,has size optimizations for every type of device by using the  webp format which is a format for reducing the file size of images by compressing it with or without loss of quality depending on the device and avif for super high compression quality that also supports a higher range of colors without compromising any significant image quality and prevents layout shifts which happens when elements are added dynamically to the dom which spoils the user experience by causing the user to interact with the wrong element

*Jpeg
*png
*gifr
*Webp
*Svg images are for preserving the quality of images


*There are two ways to load fonts:
By cloud importing fonts from google in an html document using the font's cdn or by using next js/fonts 
By local imports using the global css or next js/local


And then optionally use tailwind


*Next js didnt import the globals css file into the layout.tsx when it scaffolded the project which is required for applying tailwind and locally imported fonts that use font face to the components.Honestly dissapointing for a meta framework.Mistake,that was me.IM the one that messed up.When i removed the fonts,i also wiped out the globals.css by mistake.

*im ending up using mockbin to simulate fetch requests cuz i dont have the time to scaffold a new nest js server like i thought

todo:mockbin.io

*Next js is really an ssr.It has mpa and spa in one

*Next js apps can directly communicate with a database

*In ssrs,fetches to an api or a database happens on the server meaning it happens before the html document is sent to the client

*In next js,a server component is like an mpa cuz its content is dynamically rendred either through a fetch api,a database or dynamic route data but it doesnt allow client side interactivity

*The difference between a client component and a server component is where they are rendered in the app.By default,all components in next js are server components unless explicitly stated.For both,html documents are pre-rendered on the server before its shipped to the client except that for server components,the entire html document is generated and rendered on the server before its shipped to the client meaning that it cant be client side interactive and it functions just like an mpa but for client components,a skeleton html document is rendered on the server and shipped to the client where js will then hydrate the document.

*in next js,each page gets their own html document so you dont have to import them in a main jsx file as an assembly point

^dont forget to use cypress for full e2e tests and story book for isolation
^Be careful of routing errors

*Server side components use fetch and axios to make api calls while client components use rtk query or react query and a local database like pouch db.Server component fetching is better when fully rendrered html is required to render on the server for improved seo and performance and rtk query in client components where high interactivity is required.

*Server side components is like the view layer in the mvc architecture where the view would have been carried by the server.

^Death battle goku vs superman,the two Yuji raps,Sukuna rap,la la la,skyfall,switching vocals megamix by skylest,arcane music,funk in blue lock edits


todo:Big O
?For code along,watch the entire video and take notes and how they do it.Js mastery

*Next js is a backend that primarily focuses on the view layer using react while nest js is a full blown entreprise grade backend framework.

Javascript,Typescript,React,Next js
Javascript,Typescript,node js,Express js,nest js


todo:New name:Droplet

*Next js runs in a server environment like any node js server where it serves html documents to the client but when bundled in electron as a desktop app,it creates a local server for each installatio

*Astro js is a static site generator which is a framework that compiles your component code into static html at build time and selectively hydrates certain components with js

*js is very powerful in handling network request because it is asynchronous in nature

^I'll make next js desktop apps by using electron to create a window that is just a layer over the website so that it can be used as a separate app rather than in the browser because ill like my app to be used as a desktop app.This will make the app an online app which will be just be the same thing as accessing it in the browser which questions why i will then make it as a desktop app but preferences matter to me.I could have just used tauri for this instead since I prefer to use tauri to make desktop apps with react and i don't have to worry about the impossibility of packaging a node env with tauri to make my next js app to work since the app is just a layer and not an app itself but i chose electron because using tauri to scaffold a project is an overkill when i can just use one electron.js file to tell electron to build such an app plus since the app is just a layer,i believe it wont be a memory hog.If i then want to make my desktop app offline,ill package the whole next js app into the electron app since electron has node to support next js except that the offline one will be heavier since it packages the whole next js server with it.So there is an option for a lightweight but an online one and a heavy but offline one.

^All my next js apps will be online but with some offline capabilities while my react apps will be fully offline using pouch db as the database.Once the app is opened,every client component will cached in advance even before the user loads them so that an interenet connection is only needed in the initial load and any subsequent responses from the server will also be cached.All client components will use pouch db so that they can work offline but any request from the client request will be batched till there is internet connection where it will be pushed to the server.My fully offline react apps that relies on data fetching as well will also batch requests till there is internet connection

^The markup languages
*Html,Xml,Xhtml,Yaml,Mathml,Dbml,Saml,svg
*Svg is just xml

*Ngrok is for exposing your website publicly only for development

*Objects can create graph data structures for either relationships or space co-ordinates

*tunnelling service,hosting service,deployment service/platform as a service

*tauri's rust backend

todo:That animated sign up page bolaji sent to me on whatsapp that came form dribbble654

*cache storage api,service workers,local storage

*loopback interface means a computer communicating with itself over a network and its just a fancy term for local host

*web search engine and distributed search engine
*timestamp is for data versioning
*In object oriented databases,the data and methods required to operate on that data are encapsulated in the object meaning that you cant perform pre defined crud methods or sql queries to perform operations on the data like other databases.


*kv database,wide column/column oriented db,row/table/sql oriented/relational db,document oriented db,graph db,multimodel databse like surreal db and redis,vector db

*Elastic search is more accurately described as a distributed search engine
*Elastic search is best for scaling highly unstructured data like text based data

*Vector databases unlike other dbs that gives you exactly what you queried for,returns similar data by using similar search.It is used for ai/ml technologies and recommendaton systems

*Vector databases is best used to power machine learning models so ill use one with python
*i can use vector databases to imprive my ai model and other ones like chatgpt

*Array--matrix,vector

^Ill use react alone with tauri when building offline or 90% offline web apps,next js with electron for online web apps and react with astro for websites

todo:Understand elastic search inverted indexing
todo:How vector databases work in detail down to the maths
todo:what the hell are web components and how does lit use it

todo:Magic regexp
todo:motion canvas
