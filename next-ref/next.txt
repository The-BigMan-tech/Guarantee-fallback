!All the notes below are my thoughts during the learning process of particular technologies and the later ones in and even outside this text file might contradict older ones as a result of corrections along the way so not all of them are accurate and all might be subject to correction but as a safe bet on accuracy,trust the later ones over the older ones.

*Web apps are instantly accessible unlike desktop apps and for desktop apps,you have to think of how you will handle updates

todo:Know how to automatically handle desktop app updates

*Tauri is react and rust for the backend

*Tauri does not run a node js environment but rather,it uses a web view and rust for its backend and as such,it can only a client side react app and not a next js app.It instead uses rust for its backend while electron js can run full next js apps cuz it uses the node js environemnt as well as chromium to make desktop apps

*Tauri compiles your app to binaries that are only target the machine its compiling on and uses the sytem's built in webview and as such,the users dont need to download anything to run the app while electron uses the chromium and an in built node js env making users to install the app without any additional packages

*Docker container,web app,desktop app

todo:NodeGUI

*blockbench is made with vue,three js and electron
*The await keyword is for telling an async operation to run only when another async operation has finished

*concurrently is for running cmds in separate terminals
*Tauri for react apps and electron for next js apps

*I used concurrently to start my electron app window

*WHen building your desktop web app,you have to build the web app using the bundler and connect it to either electron or tauri

todo:electron builder

*admin dashboards are best done with next js

*No rendering strategy is a superset of the other.They just borrow techniques from each other to make their own pattern

todo:DOM purify
todo:Marked js

*Next js is a complimentary set to react while typescript is a superset of js.Complimentary and supersets are different.

*In next js,the page is the entry point.Any component that isnt a page or a folder that is prefixed with underscore to be declared as private isnt routable.

^Im separating my component logic into hooks in private folders only if it warrants doing so and leave my components to only render the ui

*Route groups are folders that wont be part of the route.its only for organizational purposes


^I'll use the app directory for storing the page files aka for routing purposes,the lib folder for shared logic like hooks and components and the components folder for the components in a feature based style.The app folder will have a corresponding fetaure based structure where each page.tsx is an entry point for assembling the raw components from the components folder from the respective feature into a single route.So my app folder is purely for routing and assembly point purposes.

*A layout is a component that takes another component as a prop and it can be accessed via the children property of its prop.It automatically takes a page as child and its for consistent styling across pages.


*Understanding someone else's codebase
Comments
Docstrings
Good variable names
Type Safety:Type annotations and Linter like eslint and error lens


*Understanding the behaviour of the codebase
Error messages:through error handlers or the stack trace
Logs
Step through debugging
Tests

*You can pass a state,a state setter or a component to another component but only the layout can accept another component

*The Image component from next js is lazy loaded,has size optimizations for every type of device by using the  webp format which is a format for reducing the file size of images by compressing it with or without loss of quality depending on the device and avif for super high compression quality that also supports a higher range of colors without compromising any significant image quality and prevents layout shifts which happens when elements are added dynamically to the dom which spoils the user experience by causing the user to interact with the wrong element

*Jpeg
*png
*gifr
*Webp
*Svg images are for preserving the quality of images


*There are two ways to load fonts:
By cloud importing fonts from google in an html document using the font's cdn or by using next js/fonts 
By local imports using the global css or next js/local


And then optionally use tailwind


*Next js didnt import the globals css file into the layout.tsx when it scaffolded the project which is required for applying tailwind and locally imported fonts that use font face to the components.Honestly dissapointing for a meta framework.Mistake,that was me.IM the one that messed up.When i removed the fonts,i also wiped out the globals.css by mistake.

*im ending up using mockbin to simulate fetch requests cuz i dont have the time to scaffold a new nest js server like i thought


*Next js is really an ssr.It has mpa and spa in one

*Next js apps can directly communicate with a database

*In ssrs,fetches to an api or a database happens on the server meaning it happens before the html document is sent to the client

*In next js,a server component is like an mpa cuz its content is dynamically rendred either through a fetch api,a database or dynamic route data but it doesnt allow client side interactivity

*The difference between a client component and a server component is where they are rendered in the app.By default,all components in next js are server components unless explicitly stated.For both,html documents are pre-rendered on the server before its shipped to the client except that for server components,the entire html document is generated and rendered on the server before its shipped to the client meaning that it cant be client side interactive and it functions just like an mpa but for client components,a skeleton html document is rendered on the server and shipped to the client where js will then hydrate the document.

*in next js,each page gets their own html document so you dont have to import them in a main jsx file as an assembly point

^dont forget to use cypress for full e2e tests and story book for isolation
^Be careful of routing errors

*Server side components use fetch and axios to make api calls while client components use rtk query or react query and a local database like pouch db.Server component fetching is better when fully rendrered html is required to render on the server for improved seo and performance and rtk query in client components where high interactivity is required.

*Server side components is like the view layer in the mvc architecture where the view would have been carried by the server.

^Death battle goku vs superman,the two Yuji raps,Sukuna rap,la la la,skyfall,switching vocals megamix by skylest,arcane music,funk in blue lock edits


todo:Big O
?For code along,watch the entire video and take notes and how they do it.Js mastery

*Next js is a backend that primarily focuses on the view layer using react while nest js is a full blown entreprise grade backend framework.

Javascript,Typescript,React,Next js
Javascript,Typescript,node js,Express js,nest js


todo:New name:Droplet

*Next js runs in a server environment like any node js server where it serves html documents to the client but when bundled in electron as a desktop app,it creates a local server for each installatio

*Astro js is a static site generator which is a framework that compiles your component code into static html at build time and selectively hydrates certain components with js

*js is very powerful in handling network request because it is asynchronous in nature

^I'll make next js desktop apps by using electron to create a window that is just a layer over the website so that it can be used as a separate app rather than in the browser because ill like my app to be used as a desktop app.This will make the app an online app which will be just be the same thing as accessing it in the browser which questions why i will then make it as a desktop app but preferences matter to me.I could have just used tauri for this instead since I prefer to use tauri to make desktop apps with react and i don't have to worry about the impossibility of packaging a node env with tauri to make my next js app to work since the app is just a layer and not an app itself but i chose electron because using tauri to scaffold a project is an overkill when i can just use one electron.js file to tell electron to build such an app plus since the app is just a layer,i believe it wont be a memory hog.If i then want to make my desktop app offline,ill package the whole next js app into the electron app since electron has node to support next js except that the offline one will be heavier since it packages the whole next js server with it.So there is an option for a lightweight but an online one and a heavy but offline one.

^All my next js apps will be online but with some offline capabilities while my react apps will be fully offline using pouch db as the database.Once the app is opened,every client component will cached in advance even before the user loads them so that an interenet connection is only needed in the initial load and any subsequent responses from the server will also be cached.All client components will use pouch db so that they can work offline but any request from the client request will be batched till there is internet connection where it will be pushed to the server.My fully offline react apps that relies on data fetching as well will also batch requests till there is internet connection

^The markup languages
*Html,Xml,Xhtml,Yaml,Mathml,Dbml,Saml,svg
*Svg is just xml

*Ngrok is for exposing your website publicly only for development

*Objects can create graph data structures for either relationships or space co-ordinates

*tunnelling service,hosting service,deployment service/platform as a service

*tauri's rust backend

todo:That animated sign up page bolaji sent to me on whatsapp that came form dribbble654

*cache storage api,service workers,local storage

*loopback interface means a computer communicating with itself over a network and its just a fancy term for local host

*web search engine and distributed search engine
*timestamp is for data versioning
*In object oriented databases,the data and methods required to operate on that data are encapsulated in the object meaning that you cant perform pre defined crud methods or sql queries to perform operations on the data like other databases.


*kv database,wide column/column oriented db,row/table/sql oriented/relational db,document oriented db,graph db,multimodel databse like surreal db and redis,vector db

*Elastic search is more accurately described as a distributed search engine
*Elastic search is best for scaling highly unstructured data like text based data

*Vector databases unlike other dbs that gives you exactly what you queried for,returns similar data by using similar search.It is used for ai/ml technologies and recommendaton systems

*Vector databases is best used to power machine learning models so ill use one with python
*i can use vector databases to imprive my ai model and other ones like chatgpt

*Array--matrix,vector

*Javascript is an event driven and async programming language

^Ill use react alone with tauri when building offline or 90% offline web apps,next js with electron for online web apps and react with astro for websites

todo:Understand elastic search inverted indexing
todo:How vector databases work in detail down to the maths
todo:what the hell are web components and how does lit use it

todo:Magic regexp
todo:motion canvas

*pypy to python is like million js to react.its just a different implementation of the interpreter and renderer respectively that runs the code faster.Mypy is to Eslint.its a static type checker for python

*Hosting service.Cloud services:Iaas,Paas,Faas,Baas,Saas,Authentication as a service,Storage as a service,Database as a service.

*Faas and Baas,API.When building our api,you just dont make endpoints but you also manage everything else like routing,authentication,middleware and other management and architectural concerns while in faas,you can only focus on making your endpoint function and how it responds to user events while the cloud provider handles everything else for you.So using Faas and making your own api achieve the same thing but with different approaches

*Tauri is more powerful for desktop apps while electron is more powerful for web apps
*Desktop apps,web and mobile apps are tailored to a single or team user experience while entreprise level appas are for a whole organization.Java is the strongest for entreprise level apps

*Desktop,mobile,web,entreprise level,Saas app

*In next js,api routes and server actions are serveless functions because once deployed,they are handled by the faas of the deployment service 

*next js is server based when it comes to serving components with its ssr and its serverless when it comes to server actions and api routes

*Next js for the view layer,api routes and server actions for faas and a baas

*Postgres models relationships with tables while graph dbs uses nodes and edges

*assets in games are just data not code like in arrays
*Thats why lottie animations is represented in json because assets are stored in serialized data formats like json or yaml

*Ill use postgres to store data retrieved from forms while mongo db for storing user created data in the server

*token based auth is like when you go to an office or a school,they give you a clearance card that you must show every time you go to the school to authenticate yourself and it will expire after some time before you then get another one
*session based auth is like a school exam record.Upon writing the exam for the first time,you are given an exam number that you must show to write the exam each time and collect your result later as they will check it against the students that have sat for the exam.The diff between this and token auth is that token auth doesnt store any of your data on the server to check against.It just checks if the token is valid like how a school will check if your clearance card is valid while for session,the server checks your id against the database like how a school uses your exam number to check against the db to ensure you are writing the exam


todo:Real estate project
todo:Demo day
todo:Domestic skills i need to learn

?vscode terminal cant go full screen
?inline fold isnt working
?Its possible that attackers can bring up credential or auth windows when using public wifi so,i shoudnt use them unless im using mine

*Next js can communicate with dbs
*Frontend,MetaFramework,Backend

*server actions,api routes and server components

*Forms--button with form action or form element

*A saas product is a software offered on a subscription basis that is hosted in the cloud
*Three js has now made js able to create 3d scenes in web browsers.Js can do anything to deliver a good ux across all kinds of apps

*tunnelling is a way for others to test your web app on a local server outside of your network while its still in development

*Rest,graph ql,rpc,web socket

*Server actions are just like an rpc server but tailored to frontend web apps

*server components,server actions and api routes are all different implementations of server functions

*I should use server components for pages that have to be fully rendered on the server into static html before its sent to the client for better seo,faster load times and where little interactivity is required.Server actions are ideal for performing operations in response to client side interactions/client triggered actions that will require server side processing such as form submissions while api routes are for creating rest endpoints mainly for data retrieval and manipulation like client side state that is dependent on data from a database

*client side queries

*Caching and revalidation,batching

*When i make changes to my src code,vercel automatically redeploys the latest version for me.Thats called a continuous deployment pipeline.SSG sites are just static html but i can update the content by editing the src files and pushing the changes which will trigger a redeployment but it differs from isr because in this,pages are rebuilt each time the data changes

*spas,mpa,ssrs are hosted on deployment while ssgs are built on deployment
*Spas use an empty html shell that is then hydrated by js
*mpas 

*so partially hydrated pages are built and hosted on deployment.Its similar to spa except that it isnt an empty html shell that has a single div which is the place where the whole page content goes as controlled by js but rather a page with content where js contains only one or two divs isolated from themselves and the rest of the page content.

*SSG pages are built on deployment unlike others that are hosted on deployment
*long lived process

*Client side Js code is executed once the page loads and only reruns when attatched to event listeners,observers or called by another script.

*web socket allows for persistent connection between the client and the server unlike the other protocols that only connect when the client makes a request to the server

*ISR

*The dom is static and js only runs once.The dom can only be updated by js and it will only update as said by the script meaning that dom manipulation doesnt implicitly update the dom.
*The ability of js to automatically update the dom is called reactivity.Mutation observer can allosw for reactivity
*server side js only run in resoonse to user requests unless its a web socket

*In every rendering pattern,the content is hosted on a web server and at least,one html document is delivered to the client.The only difference is when and where the document is built.

*Web servers serve html documents and scripts to be used in the browser
*Application/backend server serves json documents to be used in the frontend app

*web servers are implicitly built and managed by tools while application servers are built explicitly using frameworks like nest js or express

*Next js and other meta frameworks have a dual nature of being both a web server and an application server

*Everything in a desktop app is bundled locally and as such when you build a web app as a desktop app,it no longer needs access to the web server to function.

*If you build a static site with only some parts of the documet made interactive by js,it is a partially hydrated page and as such,partial hydration can be seen as an extension to static rendering

*Isr is an extension of static rendered pages where the pages are regenerated after a revalidation period rather then rebuilding it on change through a cd pipeline

*Apache,nginx and the live server vs code extension all come with built in web servers

*CD pipelines are used to continuously deploy changes to production whenever changes are made to a repository and most modern cd solutions dont require a web server restart and as such,they provide zero downtimes

*Ill use a search engine like elastic search for all of this high volume of note data

partial hydration
Github pages is a hosting service
github actions
