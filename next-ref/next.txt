*Web apps are instantly accessible unlike desktop apps and for desktop apps,you have to think of how you will handle updates

todo:Know how to automatically handle desktop app updates

*Tauri is react and rust for the backend

*Tauri does not run a node js environment but rather,it uses a web view and rust for its backend and as such,it can only a client side react app and not a next js app.It instead uses rust for its backend while electron js can run full next js apps cuz it uses the node js environemnt as well as chromium to make desktop apps

*Tauri compiles your app to binaries that are only target the machine its compiling on and uses the sytem's built in webview and as such,the users dont need to download anything to run the app while electron uses the chromium and an in built node js env making users to install the app without any additional packages

*Docker container,web app,desktop app

todo:NodeGUI
todo:Fix my syntax coloring.it sucks a little bit

*blockbench is made with vue,three js and electron
*The await keyword is for telling an async operation to run only when another async operation has finished

*concurrently is for running cmds in separate terminals
*Tauri for react apps and electron for next js apps

*I used concurrently to start my electron app window

*WHen building your desktop web app,you have to build the web app using the bundler and connect it to either electron or tauri

todo:electron builder

*admin dashboards are best done with next js

*No rendering strategy is a superset of the other.They just borrow techniques from each other to make their own pattern

todo:DOM purify
todo:Marked js

*Next js is a complimentary set to react while typescript is a superset of js.Complimentary and supersets are different.

*In next js,the page is the entry point.Any component that isnt a page or a folder that is prefixed with underscore to be declared as private isnt routable.

^Im separating my component logic into hooks in private folders only if it warrants doing so and leave my components to only render the ui

*Route groups are folders that wont be part of the route.its only for organizational purposes


^I'll use the app directory for storing the page files aka for routing purposes,the lib folder for shared logic like hooks and components and the components folder for the components in a feature based style.The app folder will have a corresponding fetaure based structure where each page.tsx is an entry point for assembling the raw components from the components folder from the respective feature into a single route.So my app folder is purely for routing and assembly point purposes.

*A layout is a component that takes another component as a prop and it can be accessed via the children property of its prop.It automatically takes a page as child and its for consistent styling across pages.


*Understanding someone else's codebase
Comments
Docstrings
Good variable names
Type Safety:Type annotations and Linter like eslint and error lens


*Understanding the behaviour of the codebase
Error messages:through error handlers or the stack trace
Logs
Step through debugging
Tests

*You can pass a state,a state setter or a component to another component but only the layout can accept another component

*The Image component from next js is lazy loaded,has size optimizations for every type of device by using the  webp format which is a format for reducing the file size of images by compressing it with or without loss of quality depending on the device and avif for super high compression quality that also supports a higher range of colors without compromising any significant image quality and prevents layout shifts which happens when elements are added dynamically to the dom which spoils the user experience by causing the user to interact with the wrong element

*Jpeg
*png
*gifr
*Webp
*Svg images are for preserving the quality of images


*There are two ways to load fonts:
By cloud importing fonts from google in an html document using the font's cdn or by using next js/fonts 
By local imports using the global css or next js/local


And then optionally use tailwind


*Next js didnt import the globals css file into the layout.tsx when it scaffolded the project which is required for applying tailwind and locally imported fonts that use font face to the components.Honestly dissapointing for a meta framework.Mistake,that was me.IM the one that messed up.When i removed the fonts,i also wiped out the globals.css by mistake.

*im ending up using mockbin to simulate fetch requests cuz i dont have the time to scaffold a new nest js server like i thought

todo:mockbin.io

*Next js is really an ssr.It has mpa and spa in one

*Next js apps can directly communicate with a database

*In ssrs,fetches to an api or a database happens on the server meaning it happens before the html document is sent to the client

*In next js,a server component is like an mpa cuz its content is dynamically rendred either through a fetch api,a database or dynamic route data but it doesnt allow client side interactivity

*The difference between a client component and a server component is where they are rendered in the app.By default,all components in next js are server components unless explicitly stated.For both,html documents are pre-rendered on the server before its shipped to the client except that for server components,the entire html document is generated and rendered on the server before its shipped to the client meaning that it cant be client side interactive and it functions just like an mpa but for client components,a skeleton html document is rendered on the server and shipped to the client where js will then hydrate the document.

*in next js,each page gets their own html document so you dont have to import them in a main jsx file as an assembly point

^dont forget to use cypress for full e2e tests and story book for isolation
^Be careful of routing errors

*Server side components use fetch and axios to make api calls while client components use rtk query or react query and a local database like pouch db.Server component fetching is better when fully rendrered html is required to render on the server for improved seo and performance and rtk query in client components where high interactivity is required.

*Server side components is like the view layer in the mvc architecture where the view would have been carried by the server.

^Death battle goku vs superman,the two Yuji raps,Sukuna rap,la la la,skyfall,switching vocals megamix by skylest,arcane music,funk in blue lock edits


todo:Big O
?For code along,watch the entire video and take notes and how they do it.Js mastery

*Next js is a backend that primarily focuses on the view layer using react while nest js is a full blown entreprise grade backend framework.

Javascript,Typescript,React,Next js
Javascript,Typescript,node js,Express js,nest js


todo:New name:Droplet

*Next js runs in a server environment like any node js server where it serves html documents to the client but when bundled in electron as a desktop app,it creates a local server for each installatio

*Astro js is a static site generator which is a framework that compiles your component code into static html at build time and selectively hydrates certain components with js

*js is very powerful in handling network request because it is asynchronous in nature