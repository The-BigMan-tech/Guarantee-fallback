so macros are like functions for reusable blocks of code but macro genrates the reusable blocks at compile time unlike functions that gets called at runtime.this allows for compile time optimizations and can generate different code structures based on the input unlike functions that have a fixed structure

When a macro is invoked, it expands into code at the call site. This means the generated code can be different for each invocation, leading to more efficient and tailored output.

Functions: Always call the same block of code regardless of how they are invoked, which can lead to performance penalties if the function is called frequently.

macros give a more expressive syntax

functions have a fixed signature while macros signature are flexible to syntax patterns although function overloading in langs like ts,make function signatures flexible based on input and generics with union types makes return types and input types very flexible

functions can also take a varible number of args by using the spread operator

function overloads are resolved at runtime while macros expand into code at compile time allowing optimizations

Macros are generated at compile time which can prevent errors early rather than functions throwing errors at run time when the wrong args are passed

cargo is the package manager for rust and its cargo.toml and cargo.lock as oppossed to package.json and pnpm-lock.yaml or packagelock.json as it is for js files.This is called local project management.Its better to install dependencies for a particuar project rather than globally on the file system.pip does this globally i believe and thats why there is somthing called virtual environment

the dependency file is for specifying the packages and the versions a project uses while the lock file is for ensuring that the versions of the dependencies remains consistent regardless of the environment

toml and json files are for project management
cfg files are for settings for an app or a tool
yaml and json files are for serializin data

dependencies in rust are called crates as it is called node modules in javascript

lock files are managed by the package manager while the dependency files acn be manged manualy

*ill use rust to convert the size of my compressed array to a smaller size by representing chunks in the smallest byte representation possible for that chunk rtaher than having a consistent size across all chunks

*Dont need pinno for logging,the vscode turbo console log extension is far superior as it automatically creates detailed log messages and can adap it when the code refactors.Its a log manager

js is interpreted by the browser,so it can run directly in the browser
js in frontend frameworks have to be compiled by the frontend framework into regular js dom manipulation and then bundled into on js file with a web bundler like vite before running it on the browser.
running js standalone requires node js 
ts needs to be compiled to js files before its ran in the browser or node js envirnonment

since rust is a compiled language language,it has to get compiled into an executable before it gets ran

cargo build
cargo run
cargo clean
cargo check

cargo build emits the executable in the target/debug folder for quick re-editing while cargo build --release builds it as a final program for use so its slower so only use it when the final build of the program is ready.

"General learning material for Language X" is a completely different scope from "Teaching the basics of programming using Language X". The former is suitable when you are a beginner to the specific programming language but not to programming in general, whereas the latter is required when you are a beginner to programming in general.

react requires that states must be immutable and editing them should return a new value which reps the current state and not directly modify the state itself the same as rust

*rust is one of those languages that uses an entry point function called main.It also uses curly braces to create blocks over indentation and it uses semi colons as a line terminator

*intellisense is provided by a language server

*compile time erros means that the program isnt safely doing what its suppose to do yet.

*In js and python,variables are mutable until explicitly declared immutable stated while in rust,variables are immutable by default unless they are explicitly declared mutable

*in c++ and rust,printing to the std output must be in a string literal.I belive that python and js do this under the hood by an abstraction

*constants are immutable together with the fact that they must be annotated and they can be declared in any scope and the value of constants must be known at compile time instead of run time like immutable values meaing that the values of constants must be hardcoded while immutable variables can be assigned the values of other variables upon declaration

*constants are best for having a single source of truth for all the hardcoded values that will be used in your program and it also makes them more readable while immutable variables are for enforcing safety

*You cannot change the type of a mutable variable

*Shadowing is redeclaring a new variable with the same name as a previous variable.This means that the new declaration shadows the old one and takes precedence.It is used when trying to change the value and type of an immutable variable without actually mutating it because its actually declaring a new varible but with the same name.This ensures that the variable always remains immutable across changes and it also prevents the need for creating many similar variables but with just different names.Its a false sense of mutation.It can be considered as a safer alternative to mutation

*Mutation means changing the value of a variable after its declaration while shadowing doesnt.

*Immutability leads to predictablility as seen in react and redux and its the same for rust.

*integer,float,boolean and character

*Unsigned integers are guaranteed positive integers while signed integers may be positive or negative
*You can use _ as a separator for long integer values and you can suffix the type of a variabe that holds an integer with the type in front of the integer

*when an integer overflows,it can cause two things:if its in debug mode,it will panic and throw an error but if its in release mode,it will wrap around the given range which is also an error.

*i,u,f

2^(n-1) is the formula for calculating how many numbers can be produced with n bits.

*boolean values in rust are one byte
*there is unicode and ascii way of representing strings or characters just like python because unicode can represent a vast array of characters including emojis

*chars use single quotes in rust while strings use double quotes

*tuples can be unoacked in pythin and rust as arrays can be destructured in javascript

*arrays,tuples and vectors.Tuples can be composed of any types while arrays cant and arrays are fixed in length

*an array is a fixed large chunk of memory allocated to the stack

*in python functions arent hoisted but they are in js and rust

^Change the folding strategy in vs code to indentation

*expressions and statements.expressions return a value while statements are a series of functions.defining a functions is a statement while calling a function is an expression.

*you can create scopes in rust

*statements use semicolons to terminate the end of it while expressions dont.if you use a semi colon to terminate an expression,it will become a statement

*rust is expression first meaning numbers and arithmetic operations themselves are implicitly treated as expressions.

*in js,anything truthy value can be used in a condition check while in rust,only expressions that evaluates to bool values can be used.

*in js,paranthesis are required for blocks
*in rust,they must be removed
*in pythin,they are optional

*switch case statements are just syntatic sugar over if-elif ladders

*Blocks of code evaluates to the last expression in them and they are denoted by curly braces.

*In ternary statements,each block must return the same type and this is because rust needs to know the type of a variable at compile time and not at run time.If they allowed it,the compiler will be more complex and will provide less reliable type checks if it relied on possible values of a variable.

*do while loop,while loop,loop
*iterators and range constructs.
*range constructs are made up of a loop counter,end and a step and it can be forward or backward

*The loop keyword is like the while loop except that it doest check for any condition before it enters the loop and it only terminates when explicitly stated in the program with the break keyword

*variables are only visible within the scope they are declared meaing they are not visible to sibling scopes.They are also visible to child scopes but parent scopes cant access the variable in child scopes unless the scope returns the variable.Child scopes cant shadow the variables in the parent scope and can only modify it if the variable is declared muatbable in the parent scope.This is an intentional design choice to allow for predictable code.

*Blocks are made using {}

*Because lines have to be terminated by a semicolon in rust,only the last line of any scope in a rust program can be implicitly made as an expression.

*Running a program in debug mode will only work when there are breakpoints as a debugger is just a detailed step through for a program.

*Break is for breaking loops while continue is to skip the current iteration of the loop

*Scopes are valid blocks like if statements,loops and functions.They are used for scoping code.the last line is implicitly the return statement for scopes meaning scopes can also be used as expressions

*the loop keyword just tells a scope block to repeat itself indefintely until there is a break.You can return a value from a loop block by writing the value you want to return after it

*in rust,before an element from an array is accessed,the compiler takes the extra step of checking if the index is valid.

*You cannot type annotate the loop counter in a for loop

*arrays can be generated by [1;5].The former generates one five times.

*To do range constructs,you iterate over a special array type particularly for this through:[1..5]

*You can also use the rev() method to do a reverse range construct

*js and python use a garbage collector to manage memory,c++ uses manual mem management and rust uses ownership

*the compiler checks for features of ownerships that if they are not met,the progam wont compile

*There are two places of memory in a program; the stack and the heap. The stack is for storing data that's of a fixed and known at compile time while the heap is for data that's of an unknown size. Data can only be added to the stack through the top and accessed by the first in, last out order or the rule of stacked plates and data in the stack only exists for the scope its called in.Once the scope finishes,the stack get cleared and as such,the stack manages itself and its very safe.function parameters and local variables are stored in the stack till they get cleared when the scope is finished.Its simpler and faster to manage than the heap as the program only has to manage only one contiguous block of memory.

*While the heap is for data that's of an unknown size at compile time or for variables that their values change often but the locations of each data block is sparse and can only be accessed by an allocator and since its sparse, it takes more time to allocate and access data on the heap. On the heap, its called allocating and deallocating while on the stack, its called pushing and popping.Data in the heap is left there until explicitly deallocated.You can only access data in the heap by following a pointer that leads to the address of that variable in the heap and since pointers are of known sizes,they are stored on the stack

*integers and arrays of fixed sizes are stored on the stack while flexible sized arrays and strings which grow and shrink dynamically are stored in the heap.

*strings and integers are passed by value while arrays and objects are passed by reference

*Dangling pointers are pointers that points to the address of a memory block that has already been freed and it can cause unexpected behaviour if accessed in the program and smart pointers are pointers that come with memory safety and more features.

*a null pointer means that the pointer doesnt currently point to any memory address.

*pointers get cleared like any normal variable when the scope exits but if they were left pointing to a memory,the memory remains allocated until explicitly freed

*Without pointers and references,you cant access data stored in the heap but for data on the stack,its direct through its variable names but many hll use references and garbage collection which is a manger for references as an abstraction over pointers.references are safer than pointers as they can never be null and it will always lead to valid memory

*For arrays,the pointer initially returned is the pointer to the first element of the array and since arrays are stored in a contiguos block of memory in the heap,the addresses of the elements are serialized and you can use pointer arithmetic to get the other data in the array.Array indexing is just an abstraction of using pointer arithmetic to access elements in an array

*There is a difference between a pointer and a reference.A pointer is a variable that its value is an address to another variable in the heap and can allow you to perform arithmetic operations on that value to create new pointers but doing so can lead to dangling pointers.Since pointers are just variables,they take their own space and have mem addresses on the stack while a reference is a direct alias or mapping to a variable in the heap meaning that it doesnt have its own space on the stack and it shares the same memory address as the variable is aliasing to.Pointers can be reassigned to another memory address while refs cant be reassigned this is because pointers are assigned at runtime while refs are assigned at compile time.References are safer because they cant be null which prevents dangling pointers.

^there is memory leak and memory fragmentation.

^Garbage collector,manual mem mangement and ownership are the different ways programming languages manages meory on the heap

*time allocation--single threaded,asynchronous,multi threaded,multi processing.

*strings and integers are immutable since they are passed by value 

*namespaces and import aliases are used for import safety to ensure that imports dont collide with existing functions in the same module.

*In js,you can do selective exporting and then import them under a namespace as a variable or use destructuring to import them directly in the namespace.

*rust uses the :: notation for accessing the methods in a type and the exports in a namespace/module and not the instance of that type But uses dot notation for instance methods and properties.Its a design choice for clarity while js and pythin use dot notation for both because of simplicity and consistency

*there is selective export and module export

*the string type is mutable while the string literal is immutable and is known at compile time and as such,its stored in the stack.

*when making string types,it makes a request to the allocator to get the space its need to store the string

*because integer values are known at compile time and they dont carry that much data,they can be created on each variable assignment and stored on the stack

*The pointer,the length and the capacity.The length is how much bytes the string is taking in memory while the capacity is the amount of memory in bytes given to the string by the allocator.This means that when you attempt to copy data thats on the heap,you actually copy the pointer,the length and the capacity of that variable on the stack and not the actual data.

*arrays will always decay into the pointer of their first element

*Data in the stack is accessed directly by the value such as integers,booleans,characters and fixed arrays and tuples while data in the heap is only accessed via pointers and references

*compilers can choose to copy the data on the heap but it will be computationally expensive in both memeory and at runtime since it takes the allocator some time to find free space on the heap and thats why variables that their values is another variable holding arrays are just shallow copies and not real/ddep copy because they still point to the same data on the heap but rust takes a different approach to prevent double free deallocs so it invalidates the first variable which is known as a move to ensure that only one pointer to data in the heap only exist at a time and as such,it is not a shallow copy meaning that you cant use the invalidated ref or it will throw an error

*Memory dangers can only be prevented when you call free at the right time mapped correctly to the right alloc.

*trying to deallocate memory on the heap twice will lead to memory coruption,unexpected behaviour and security vulnerabilities

*shallow copy and deep copy.

^dragon ball daima,manga

^in next js,a sidebar is loaded as a layout across many pages and the component that holds the content of what the sidebar leads to is a page that you get routed to by next js but in plain react,i used redux where the sidebar dispatches an action to change the current loaded data state and the content component will always reflect the current loaded data.The paradigms are different because of the way these apps approach rendering as next js creates multiple pages while react uses a single page,in next js apps,clicking on content on the sidebar routes you to the appropriate content while in react,it dispatches an action that changes the current state that the main page will always reflect

*discovering and building

*navbar and sidebar are for navigation

*rust takes a different approach.Once the variable goes out of scope,the variable that owns it gets deallocated so rust automatically calls a drop method to release the memory once the variable goes out of scope

*when you assign a variable to a new value on the heap,rust will automatically invalidate that reference but it will only drop it when the variable that owns it goes out of scope

*variables that have their data on the heap have stack data that contains pointer,length and capacity information and as such,when you copy that variable,you are only copying the stack data and not the heap data

*integer values are known at compile time and as such,they are stored on the stack meaning that variables that hold integer data dont get invalidated and the value actually gets copied when another variable attempts to copy it.This is the very reason why they get copied to a function when they are passed to a function as passing values to a function is just another form of assignment.

*integers,floats,boolean,chars and tuples of any of the types mentioned go to the stack.

*When you pass values to a function,they get copied into the function but when you pass refs like strings and vector arrays,you pass a ref to the function which means that modifying the variable in the function will modify the actual variable itself but rust also adds something else,when it also moves the ref or pass the ownership of that ref to the function meaning that when the function goes out of scope,rust will drop that variable and the variable cant be accessed in the caller after it called the function,it cant access the variable again

*This also means that in rust,when you pass variables that hold references,you also pass the ownership of that reference and when the function returns the variable back to another variable in the caller,it also returns the ownership of that variable back to the scope of the caller.

*This also means that all variables that hold references to data in the heap,are owned in the scope that declared them and when the scope is done,all the references it owns gets dropped.When a function returns a variable that holds a reference,it surrenders the ownership of that reference to a variable in the caller's scope.

*when a variable loses ownership of a reference,it gets invalidated by rust.So when you assign a variable a new ref value,the old ref has no owner,so it gets dropped.

^dropped and invalidated,ownership.

*This also means that in rust,anything that has to do with variables that hold references means transferring the ownerhip of that reference.

*but this is tedious as handing over and returning ownership becomes tedious

*rust goes through the ownership model and not the reference model used by garbage collectors

^exploit

*CORRECTION:so there is a difference between ownership and reference.Garbage collectors use references meaning that when you pass a variable that holds an array to a function,the function creates another ref and not take the ownership to the ref and the gc will clear it as soon as there are no refs again to the value but rust uses ownership meaning that array/object data doesnt get dropped till the variable that owns it gets out of scope and if a variable is given another data,the data from the old ref doesnt get cleared,it just gets invalidated.This also means that the ref no longer has a valid owner but it will only get dropped if the owner goes out of scope

^ownership,references and pointers.

*the ownership model of rust mimics the stack

^you can only access data on the heap through pointers and references.Ownership isnt a way to access data on the heap,its just a system that manages who owns a piece of data and when that data will be deallocated.

*Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference.

*references in rust is a way to pass data on the heap to a function without transferring ownership meaning that it can use the value but the value wont be dropped when the function goes out of scope because it doesnt own that value and the function doesnt have to return it back because it never owned it.

*references are immutable by default which means that any function that uses it only has read only access but there can also be mutable references which means that the function has read and write access.

*passing values to a function by reference over directly giving ownership is borrowing

*You can create many immutable references but once you create a mutable reference,you can no longer create or have any other refs to that variable again.This is to ensure safety because users of an immutable reference don’t expect the value to suddenly change when they want to use it and when they are using it.However, multiple immutable references are allowed because no one who is just reading the data has the ability to affect anyone else’s reading of the data.This restriction prevents data races as it gets caught at compile time because data races can cause undefined behaviour at run time.

*mutable references can only be made from mutable variables

*Many functions can use the same mutable reference.

*There can only be one mutable reference per scope and creating another mutable reference will have to be done in another scope.This is because mutable references stay as long as the life time of their scope and they only get dropped when their scope finishes.The same goes for immutable refs execpt that immutable refs get invalidated for use after a mutable one has been introduced.This rule prevents potential data races.If you were allowed to use immutable references after creating a mutable reference, it could lead to situations where one part of your code is reading a value while another part is modifying it, which could cause unpredictable behavior.

*Immutable references go out of scope from the point they were last used after their declaration.

*The reason why data that no longer has an owner or reference to it doesnt get dropped till the ref/owner goes out of scope in rust is to prevent the ref from dangling which is when the data is deallocated but the ref to that data still exist.This guarantees that a reference always points to valid data.Dangling references can still be created when a function returns a ref to a local variable which is invalid because the local variable goes out of scope after the function executes and as such,there is no value to borrow from meaning that the caller is referencing to nothing.Rust wont compile this.The right thing is to return the value itself,which surrenders ownership of the value to the caller.

*functions normally shouldnt take ownership of their arguments until when necessary.

^edits

*Python uses the variable[x:y] notation for slicing,js uses a function while rust uses the &variable[1..4] for slicing also known as the range syntax which is used in range constructs.

*string slices must occur at asciii character boundaries else,it will throw an error.

*slices are immutable refs to a part of a string meaning that slices dont take ownership of the data and you cant modify them.

*Just like how arrays decay to pointers of their first element,slices become refs to the first element of the array and its length.

^the stack,the heap,the binary read only memory

*string literals are immutable refs to string data on the binary read only memory

^data in the stack has scope lifetime.
^data in the heap has a persistent lifetime depending on the model used--manual,gc and ownership
^data in the binary read only memory has a static lifetime meaning that it never gets deallocated

*the stack also holds function call information

*The binary read only memory is a section of the data that is included directly in the compiled executable of a program and it can never be modified.This means that the data remains even after the program is closed and it is loaded back into the program's memory once the it is opened again.So in rust,string literals and constants get stored in this storage because it saves the allocator time from finding space in the heap to store this data and it can only be accessed by reference in the program because no variable can take ownership of it as its read only and cant be deallocated.But string data on the other hand,which is one that can shrink or expand throughout the program is stored in the heap.

*String literals are the only types that gets stored in the binary storage because they are hardcoded and known at compile time.even if integers are hardcoded and immutable,they are still stored in the stack because they are mostly shortlived and dont usually leave the scope they are defined in.The only way immutable integers can go here is if they are constant.

*The gc is a higher level abstraction that allows programmers to not worry about a thing about memory management while rust ownership model provides some abstractions only to guarantee safety at compile time but the programmer will still manuallay control the lifetime of data through borrowing and ownership and control which memory type every piece of data goes to by declaring it as immutable,mutable and const.

^libraries,modules,frameworks,the standard library.

^react state,rxjs and events are used to implement the observer pattern.

*With tauri,you can interpolate js and rust code in your apps.

*You can write secure code in rust but if you are going for exploitation code,you will want to go for C,C++ or python because the exploits are what rust is trying to prevent you from doing.

*dataframes are a way to create table structures in code.

^biome js and prettier are code formatters.Try out biome js

*for git,its safer to explicitly ignore which files you dont want to see rather than telling it to ignore all files except ...

*Gitignore is safe because an ignored file doesnt get removed from the repo.it just doesnt track any changes to that file for the next commit.

^Rustlings,the rust book,rust by example

^Approaches to memory management
*Through pointers--Manual memory management
*Through references--Garbage Collector
*Through the ownership model--Borrow Checker

*package managers are for managing dependencies and scripts across codebases like npm,cargo,poetry.
*project scaffolders/scaffolding utility are for setting up a structured folder for any type of project like vite,nest js.
*build automation tool which helps to auto compile,bundle and execute your code and optionally with auto reloading when the src code changes

*Build automation tools require one entrypoint file that intiliazes the app and manages imports.For rust its the main.rs file,for vite its main.tsx and for nest js,its the app.ts file.

*Package managers are often also basic project scaffolders
*in rust,cargo is not only a package manager and scaffolder but also a tool that compiles and run your program for you.its like vite that bundles your code for you and runs it with hmr and nest js that also compiles your ts files before executing it.

*It was js that i learnt the importance of a project/package manager.

^Bundler,compiler

^React--compiled,bundled,executed
^Nest js--compiled,live running

*intellisense suggestions are provided by a language server

*in rust,there is a difference between a string object and a string reference.A string reference is immutable,hard coded,known at compile time and stored in the binary storage since its just a ref to a string object in the binary storage while string objects can be mutable,can shrink and grow at run time and are stored in the heap.

^Typescript enforces type safety,Rust enforces memory safety.They both catch many errors at compile time

?Interfaces/Structures and Classes
?Land analogy--ownership model and gc

^Typescript with Rust

^Funk,Reverb,Nightcore and other musical effects

*nest js and angular are object oriented

*In rust,references to data dont outlive the owner of that data and as such,rust uses lifetimes to determine how long a ref is valid.Normally,ref get invalidated once the owner's scope is left.

*lifetimes are denoted by an apostrophe followed by a letter.they are used to tell rust how long a reference is valid for use before it invalidates it.Without specifying lifetimes, the compiler wouldn't be able to determine how long these references are valid which could to references that point to invalid memory and become dangling.

*Lifetime annotations are used to tell the compiler the lifetime of a reference.Rust implicitly creates lifetime annotations for simple assignments and function signatures but it is required in complex scenarios like struct.In assignments,lifetime annotations are implicitly tied to the owner meaning that if the owner goes out of scope,the reference becomes invalid.Rust doesnt infer lifetime annotations for structs because it can lead to ambiguity as each field might have a different lifetime.

*In situations where there is only one reference made at a time like in assignments,rust can infer its lifetime to be tied to its owner but when there are multiple refs to be handled by one entity like a struct or a function accepting many refs as pars,the lifetimes must be annotated explicitly so that the compiler can know the relationship between the refs

*in rust,the entire instance of a struct must be mutable if changes may be required after initialization as fields cant be mutable individually.This is so that refs to struct objects can only be mutable or immutable at a time and that no part/some of its fields can be immutable and mutable at the same time to prevent data races,ensure safety and prevent borrowing rules.

*in rust,data in the heap gets dropped if the owner gets out of scope,meaning that variables are local by default.

*Static storage is for data that will exist throughout the lifetime of the program menaing that variables in this storage are global and they are stored in the binary heap storage.

*News flash:By default,a ref can never outlive the data it points to but rust uses annotations so that it can keep track of how the ref is used in the function or struct to determine its lifetime and use it to know the relationship between future use of the refs in the same scope meaning that ref names must be consistent across the entire scope and lifetimes can only be defined in their definitions and no other lifetimes outside of what was defined can be used in the scope else,it will throw a compiler error and they are scoped to the function or struts that defines them.

*Lifetime annotations are just placeholders that can hold any arbitary name so you can use any name you like as long as its consistent across the scope.They can be either generic:a,b,c or descriptive:short long.Only the static lifetime annotation is hardcoded as it is used to tell rust that data must be global and must be stored in the static storage.Apart from this,other annotations are given lifetimes based on how rust infers it at compile time.

^This is similar to how react uses keys in list rendering to keep track of which values change to avoid unnecessary re-renders.React is the one that actually uses the keys,all the devs need to do,is to provide it.React relies on developer-provided keys to manage component rendering efficiently, Rust relies on developer-provided lifetime annotations to manage memory safely. Both mechanisms help their respective systems function effectively while placing the responsibility of clarity and accuracy on the developers.

*rust can just add annotations themselves if they wanted to but making devs to explicitly add names,allows for clarity as what the purpose of the ref is and clearly defining the relationships between refs

*so lifetime annotations are rust way of preventing dangling references as it states how long refs are valid

*The only lifetimes that can be used in a function or struct are the ones that are included in their definitions in the <>.

^You can use the field init shorthand syntax in rust when creating new objects from structs as it is in js.Rust also has a struct update syntax which is identical to js spread operator excep that in rust,it must come last but for js,it can be anywhere.This is just rust design choice.

*When you create a new struct object say object2 from an existing one say object1 using the struct update notation,any field data that is stored in the heap as defined by the structure will be moved from object1 to object2 if object2 doesnt create its own new value for that field as borrowing rules apply to the field level meaning that object1 has lost ownership to that field data to object2 and that field becomes invalid for object1.This is because,the update syntax essentially copies each of the field's data to create a new object but if any of that field data is in the heap,it moves the ownerhsip of the access to that data to the new object

^References and owners
^Redux provides state safety for react apps

*structs that dont use references in any of their fields dont need lifetime annotations.For fields that uses data on the heap directly,ownership applies.

?An object is just another way of storing grouped data like an array except that data access is by field name and not by index

^Tuples,arrays and vectors

*Tuples and arrays are both a sequential collection of elements that are known at compile time and as such,they are stored in the stack meaning that they implement the copy trait and not the move trait in rust.The only difference between the two is that all the elements in the array must be of one type while tuples can have elements of different types.Vectors are arrays that can grow and shrink during runtime and as such,they are stored in the heap.They are made to only hold one type because of type safety during runtime and you can only get different types if you use a vector of enums since enums can hold different types.

*Tuple structs are just a semantic layer over tuples by providing a struct nature.They take the name of the struct and a tuple definition which holds the type of the fields rather than raw values.They can be initialized unlike tuples.They are simply structs behaving like tuples where the field name is implicitly set as the index.Functions that take one tuple struct cant take another even if the tuple structs have the same types and number of elements.This is to ensure safety.

*so we can have a tuple struct or an object struct.

?How to access an array element with an index.
?unit type struct

^Unit-like structs can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself.They are a simple yet versatile feature in Rust. They allow for the creation of distinct types without associated data, which can be beneficial for type safety, marker patterns, and implementing behaviors via traits. This makes them a useful tool in Rust's type system, especially in more complex applications.

^Copy and move traits in rust.

*Unit like structs are for structs that dont need any data to implement methods

*In strucures in rust,we will want to have each object from that structure own all of its data so that it simplifies memory management and ensures safety.For example,in a struct,we will want to use the String type over the &str reference as the former allows the instance of the struct to own that string since its allocated to the heap but for the latter,the instance doesnt own its data and as such,it needs to use lifetime annotations to ensure that the reference to that data doesnt outlive the owner (in this case its the instance) to prevent dangling references

^Signature and definitions/implementations/concrete data
^Loose equality,Strict equality,Deep equality

*Typescript interfaces combine both data and method signatures while in rust,structs are strictly for data signatures while traits are for method signatures meaning that a ts interface is loosely equals to struct + traits in rust.

^The compilers are Clang,GCC,MSVC,intel C++ compiler

^msys2 is a development environment for C++ that provides a unix like shell for windows but it isnt integrated into a text editor.It is a collection of tools like compilers and package managers that can make ready C++ projects.I use msys2 to install c++.Msys2 allows you to install packages for C++ by using pacman as the package manager.Other options are the visual studio build tools,minGW that uses GCC.A dev environment takes you to the shell.

*An IDE is a development environment thats integrated into a text editor.In other words,its a supercharged text editor.

^llvm is a compiler framework that has compilers and allows developers to create their own.

^MinGW is a compiler suite/suite of compilers like GCC and other utilities

^The visual studio build tools is a set of tools for developing apps for windows.It uses a custom compiler called MSVC as its main compiler.

?Tuples-in terms of python and rust
?Coordinate geometry and Volumetric geometry

*so coordinate geometry data is an array of tuples where each tuple contains point data that can be related to form a shape while volumetric geometry data is an array of arrays where the outer array is the grid and each inner array is a layer that's stacked along the z-axis and each of those layers is an array of tuples which contain point data.They both come down to an array of tuples except that in the former,its just an array of tuples meaning that they are all just continuous number of points while in the latter,it has a finite number of arrays as each layer/inner array has many tuple data or voxel data

*in coordinate geometry the tuples representation of their data is the same as that of voxels in volumetric geometry as point(x,y,z) looks identical in structure to voxel(x,y,z) but i believe the difference is that since in coordinate geometry,there are no layers,the tuple just becomes the location of a point and a point can exist anywhere in the 3d space freely and the whole shape comes together when these points are related by many continuous points in between but for volumetric data,since each voxel is in a layer of fixed z-axis,only the x-y plane defines location while the z-axis represents the depth of the space it occupies as a volume and the whole object comes together with many of a finite number of of voxels.The reason for it being finite is that computers dont have the power to generate an infinite number of arrays that each hold voxel data.

*a grid is made up of number lines made to perpendicularly intersect at each other and thus creating multiple axis.

*Objects made from coordinates are hollow in the sense that they only represent surfaces and dont provide any information about the internal of the model while volumetric object encapsulates both the surface and internals of the object.

*Point data is best for 3d modelling and particle simulation while voxels are best for scientific purposes

*Triangle geometry is an extension of coordinate geometry, using triangles to connect points defined in a point data array, where each triangle is formed by indexing into the array of vertices.

^google made go and dart
^microsoft made typescript

^java and C# are object oriented while haskell and erlang is functional and python and js support the two.

^monad--a way for functions to do something with absolutely no side effects

*The concept of mutable state is mostly with classes than functions.Purely functional programming langaues promise no side effect whatsoever on the data the program use.

?poe crashed and reopened and now the ourple is more saturated.

*implementation in rust is a way to provide method definitions and concrete implementations to a structure.

*its best practice to borrow the self parameter as we dont want the method to take ownership of the ibstance

^class--interface + functions

*getters are a way to make fields private but the method public to ensure that the property is readonly

*C is procedural

*a pointer is like here is the address to the data of the variable on the heap while a reference is more of when i say x im referring to this particular data stored in the heap.

*Rust does automatic referencing and dereferencing when calling methods on instances meaning that any method that will use self i.e instance methods,an immutable borrow reference to the instance gets implicitly passed as the first parameter to that method

*constructors in rust implementation blocks can be named anything you like but a good convetion is new unless you have many of them in which you can then use descriptive names.
*in rust you can have many constrcutors to handle many cases in which an object of a class can be created.This is not supported in js and python as they only allow one constructor and the only way to handle multiple cases is with condition,type checks and default values and the reason its this way is because its dynamially typed and doesnt support method overloading unlike rust which is the opposite.

*in rust,the :: notation is used for namespaces and constructors while the . notation is used for methods.

*in rust,only expressions can end without semicolons if they are the last line of a scope

*Enums in rust are used for holding variant data.It is loosely equivalent to type aliases of interfaces and then a union of many of those except that for that version,it will have to implement a 'kind' property in each of the interfaces before it can decide what type of data it is because unions state what values a variable can accept but it doesnt state what variant of that data it is

^In coding,constants are normally used for making hardcoded values more readable over using arbritary number or string values so it is best practice to use them for any hardcoded value and in js and python,a data structure called an enum is used to hold a set of related constants but in rust,enums are used for creating variants of data.Also in an enum,each variant can have its own type and the amounts of unit data for that particular type.

?OCR technology with a flatbed scanner--converts images to text
?pdf tools--smallpdf and light pdf
^License agreement and privacy policy

^Markdown is better for structured notes but txt files are better for unstructured notes.

^my handwriting needs to be better for ocr tech

^make my own applock

^GCs like that in python also use weak referencing

^godot and unity uses the scene based architecture while roblox and unreal engine uses a component based architecture
*scene based architecture focuses more on scripts to define explicit behaviour
*component based architecture focuses more on triggering events to define behaviour

*There is also ecs too.but it isnt widely used

*A query language allows one to directly talk to a database but orms can prevent sql attacks since they provide abstractions that separate sql queries from your data. 

*abstractions protect you from mistakes that causes security vulnerabilities

*enums are better than unit structs.enums are also more concise than structs incases where you have many similar types.you can even make an enum of structs.this also makes function signatures more concise.You can also write implementation blocks for enums

*a prelude is a collection of items that are automatically included in every rust program

*Rust doesnt directly allow null values but rather it provides an option type which means that a value may be present or absent.Its safer than working directly with a variable thats initially declared as null because it forces you to handle both cases and its enforced at compile time.This is loosely equivalent to a typescript union of an actual type and undefined except that rust enforces handling all cases at compile time while typescript doesnt and rust provides methods that makes it easier to work with than ts.Another thing that option<T> in rust handles better than typesecript,is that a variable thats of this type cant be directly used in arithmetic or any operation until its converted back to a valid type and the rust compiler will never allow it to compile to none.this ensures that we handle the case of a possibly null value before using it.

*The option type is actually an enum.This makes its implementation easier.

*Match case statements can handle both simple values and complex patterns that cant be handled by switch case statements that are mostly used to check for fixed constant values as match cases are made to work with enum data which can hold many data variants.They are also enforced to handle all paterns/cases and as such,they are exhaustive unlike switch case statements.It also doesnt allow data to fallthrough all the cases like the switch case.The switch case has to have a break at each arm to prevent this.The switch case uses the 'default' case to catch all other cases that want caught by the ladder while the match case statement can do likewise by using an arrow function that uses an underscore or a variable name to bind the state of the data to.They both have to be the last case in the ladder

*_ in programming is used for signifying unused variables

*enums in rust cannot only hold a collection of constants but also data variants

*In rust,match case statements can bind to the state of an enum's data given that the enum data variant is made to hold data either as a tuple or a struct.This means that we can use the state of that enum in the function block of an arm.So you can match for patterns like Enum::Variant or bind to a value like Enum::Variant(state).

*In rust,arrow functions can only be used in match case statements while in js,it can be used anywhere

*Dunder methods in python are used to perform operator overloading which is changing the default behaviour of objects when used with built in operators.

*A trait is like a struct in rust except that a trait holds method signatures while structs are for field signatures.A trait is mostly used when multiple structs share methods and there's a need to define a stucture for the methods.It is implemented by impl blocks.

*Rust enforces snake case for function names whereas js and python dont.

*in rust,you can type annotate the type of data next to its variable name using the : notation or directly appended to the value.

*if let statement is like the match statement but for when you are interseted for matching for only one pattern and ignoring the rest.It is less verbose and less boilerplate than the match statement when matching only for a single pattern but you lose the exhaustive checking of match statements.Its essentially syntati sugar over one pattern match case statements.

*There is a difference between a return statement and return expression.A return statement returns a value from a scope to the caller and exits the entire function regardless of how deep the scope is within the function but a return expression returns a value from the scope without exiting the function.The return statement can be anywhere in a scope but a return expression can only be the last line of a scope.The return expression doesnt start with the return statement as it evaluates to a value.

*scope in coding usually refers to the visibility of variables.so scope in rust which can be created with {} allows me to create variables where their duration is only within the scope's definition.they are used to control the lifetime of variables by specifying them within a temporary context.

*lifetimes in rust can be controlled using lifetime annotations.

*There is a difference between a function scope and a block scope.The difference lies in who they give values to.All of these scopes can choose not to give values which will make the function scope a void function,the block scope a statement but they will become expressions if they do give a value.A function scope gives a value to the caller of the function.The caller of the function exists outside of the scope of the function and the function evaluates to a value and returns the value and flow control back to the caller of the function while a block scope gives a value to a variable but the flow control is still in the scope of the function as the variable that collects the value from these scopes exist within the function.This scope does this by just evaluating to a value which gives the value to the variable in the function scope without using the return statement to return flow control and the value to the caller of the function.

*So calling a function hands flow control over to the function but if you also pass variables whose data exist in the heap,you are passing both ownership of the variable and flow control to the function.The function will always return back flow control to the caller even if it isnt explicitly written but for the function to return back ownership of the data,it must be done explicitly.

*if statements,for and while loops tokens are just directives on how and when block scopes should be executed.

*A let-else statement is just a more readable way of returning from an if-let scope.

*statement and an expression.A statement doesnt evaluate to a value and end with a semicolon while an expression evaluates to a value and doesnt end with a semicolon.A statement like the if statement can be made to evaluate to a value and thus becoming an expression.

*enums can hold units,tuples,contants and structs in rust

*Nim has a completely tunable garbage collector meaning that you can disable it completely to switch to manual memory management

*Application level and System level programming languages

*Haskell is pure/declarative functional and one thing about the purely functional paradigm is that code is very predictable and reliable.It also provides a rich set of preludes/built in functions that makes writing many code instructions at an abstract level where you define what you want but you dont bother about how its done unlike the procedural programming paradigm.This means that the code is very minimal.

*procedural,imperative functional,concurrent,declarative functional,object oriented,data query language,markup,style sheet,multi paradigm

*The difference between declarative functional and imperative functional is that imperative functional produces side effects and also focuses more on how the steps are defined while declarative funtional is fully pure and provides a rich set of built in functions that abstracts away from the how.

*in procedural,everything is made of statements meaning that you describe control flow and how a program should achieve a result but in declarative functional,everything is made of expressions meaning that you define what the result should like rather than how it should be done.Declarative functional langauges are just another layer of sweet abstraction.Declarative functional languages also provide a more intuitive and expressive way to write code but it requires a different way of thinking than imperative langauges.

*programming paradigms are different from software design patterns

*python and js support declarative functional styles but are primarily imperative and as such have more of an imperative functional style over declarative

*js doesnt have direct control over memory and resources on the browser for security reasons but rather,it uses provided apis that exposes this functionality for js to use

^disassembler,decompiler,debugger,dll injection,windows api

*memory address and offset.Calculating offset with pointer arithmetic

*external and internal cheat

*system utilities and exploitware with rust

*system level-clis and app level--guis

*infecting a software with high priviledges

*user mode vs kernel mode anti cheat

*malware and cheat signatures

^Lynx js from tik tok
^Rs pack

*As you go down the programming iceberg from high level to low level,the dangers increase as priviledges increase.A software that has more priviledges is more unsafe and vulnerable to one that hasnt.

*A device driver is a software that allows an operating system to communicate with the hardware.It translates high level os commands to low level commands that the hardware can understand.There are kernel,user mode and virtual drivers.An OS acts as the middlema between the hardware and software ensuring that softwares reliably and safely interact with system resources.It uses a kernel driver as its core to directly communicate with the hardware.It is the core of the os and provides an interface for programs to communicate with the hardware through system calls to it.Kernel drivers operate at a high and unrestricted acces level to the hardware so its EXTREMELY DANGEROUS to create a software that operates at this level.Making system calls to the os is a safer way to do things.A user mode driver is a driver that allows the os to communicate with peripheral devices/hardware like a usb or printer in user space meaning that the interaction occurs in a restricted access space where crashes wont affect the entire system.It simplifies development and doesnt crash the entire system.

*Apps work on system calls.A system call is a controlled interface provided by the os that allows programs to communicate with the hardware through it.Code written in rust or c provides prelude methods and functions whereby when used,it gets compiled to machine code that makes system calls to the os for hardware access meaning that programs dont operate at a kernel level which makes it safer.In assembly,you can directly write system calls to the os in code unlike c and rust that provides abstractions over those system calls.

*low/system level languages are mostly compiled while high/application level languages are inetrepreted

*so when they say that low level languages give you direct access to hardware resources,this access is provided by the programming language compiler to directly make system calls to the os that can affect the hardware but its still restricted because the os is another abstraction/layer behind this layer and beyond this layer,is a direct and dangerous level of hardware access.So there are two layers between a program and hardware access and the compilers like c and rust can only give you access to what they have which is the first layer while interpreted languages bring in a third layer infront of these two through their abstractions provided by the runtime environment like the garbage collector meaning that your code doesnt directly make system calls.More layers equates to more safety but lesser control and possibly less performance because of the overhead of going through all these layers.

*rust allows you to write system level programs while also ensuring memory safety,type safety,concurrent safety and explicit error handling for runtime safety.

*system access is abstracted by the programming language and hardware access is abstracted by the operaring system

*The module system

*A crate is the smallest unit of code that is compiled by the rust compiler into an executable.A crate can be a binary crate which compiles to an exe or a lib crate which doesnt get compiled but rather,it is used by binary crates.A package is a collection of many of these crates.There can be many binary crate but only one library crate.A binary crate must have a main function that tells the rust program where to start once its loaded.The root crate is where rust starts to compile your program from.A package has a cargo.toml file that defines how these crates should be built and what dependencies your crates need.A package can have multuple crates by placing them in the bin folder

*A module is crate other than the root.The module keyword is used to declare a module in the module system for visibility and use.It is not used for importing modules.Rust will look for the module in the filesystem through the convention of the module's name.rs in the src file or mod.rs in a folder that has the name of the module or through an inline definition of the module which is supplied as a block scope next to the declaration line and then include that module in the module system.After declaring a module in the module system,you can access the module directly as rust will perform a lookup in the module system to see if the module you are attempting to use is present there.You can use the :: notation to access functions from that module and those functions can be made visible or public to the module system by using the pub keyword infront of the function's signature in the module where its defined.The use keyword allows you to import the namespace of a module directly in a file so that you only type a path once.

*To use a module declared in the module system outside of the main file,you have to use the use crate syntax to bring it into scope.The mod keyword is to declare and import a module while the use crate is used to import the module in a file other than the one that it was declared in.You can only declare modules in the main.rs file and sub modules in other modules.To access modules,you just use their names directly but for submodules,you use the names of the parent modules first before the submodule's name.

*The main.rs and lib.rs files are combined to form the root module because all other modules will fall under an hierarchy lower than these making that the root of the tree.This creates a module system which is similar to the filesytem but for organizing code.

*The main.rs file is the binary crate that acts as the entry point to the entire project structure of your rust program.It must have a main function which serves as the entrypoint to this file and it compiles into an executable file while mod.rs files or module_name.rs files are used to define modules that can be imported in the main.rs file to be part of the module system while the lib.rs file is for making a rust program as a library instead of an executable.

*The path of a module in rust is where a resource/rust script can be found.Paths to a script in rust can be relative or absolute.The absolute path is the full path to the module starting from the root of the module system.If you are using a module in the root crate/main.rs file or where it was declared,the path starts with the name of the module but if you want to use the module in another one other than where it was declared,you have to start the path with the literal,crate to tell rust that the path to the module starts at the root of the module system.

*The use keyword is just to bring a module to scope.Thats it.It isnt used for importing a module.Once a module is declared in the module system,it can be used or called in any other file in the codebase but the path.The pub keyword is used to expose certain functions from the module to be used externally.

*mod keyword,pub keyword,path

*Rust chose to make the functions of modules private by default unless otherwise stated to be public by the pub keyword in order to ensure that the dev knows exactly what code is being called or used throughout the module system

*the as keyword is an alias to prevent conflict

*There is a file-based import and a module based import.

*python and js use a different importing paradigm from rust.In python,you can import an entire module without the module explicitly allowing exports and by default,all the code in a module is public.This is the default behaviour but you can choose to do selective exports in python where only the functionality you want to export is used by other scripts.In js,selective exports is the default behaviour of exports although they also allow module,default export.In both of these paradigms,they are imported according to their paths in the file system and a script cant use a module unless they explicitly import them.But rust is a bit different,a module doesnt have to explicitly imported in a script as it can be used by any script regardless of where it is in the codebase because uses a module system to access resources rather than using the filesystem meaning that as long as the code you want to use elsewhere is defined in the module system,you can access that module's functionality by using its path in the ms to directly access its functionality.All the functions in a module are private unless stated otherwise.This is similar to js where only what you export is visible to other parts of the codebase except that the implementation is slightly different.Once a module is declared in rust,all its code is visible but not accessible while in js,only selective parts of the code is visible.

*Pythons paradigm has implicit visibility control.This is for readability and simplicity

*Levels of abstractions:1.runtime environments--interpreters,browsers,containers,virtual machines,coding environments,database engines. 2.Compiler--compiles to instructions and optionally perfroms safety rules like type and memory safety. 3.direct instructions. 4.OS 5.Hardware

*so modules that are defined in files and not as separate scripts have to be marked as pub in order to make them available to the codebase through the module system unlike modules that are declared in a file but the actual data of that module is in another script like mod.rs.Also making a module public doesnt make its content public.

?Memory mapped files

^Just an idea:defers allocation,skip the lines that uses unallocated strings,log the line and current state of strings that are already allocated to be used in the next execution cycle,deallocate old strings and repeat the execution cycle.Out of order string usage is an edge case for this.

*in rust,the :: notation is for modules and class methods while the dot notation are for instance methods.When structs are declared public,all the fields will be private by default unless otherwise marked a spublic but for enums,once it is marked as piblic,all the variants will be public

*the reason for this design choice is because enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with pub.

*The shortcut provided by the use keyword is only available for the module its used in meaning that if you use the use keyword to bring a module into scope,the shortcut wont be visible to inline module declarations

*We can also use the use keyword to bring the parent module into scope so that we can use all its functions but through the parent.This is to minimize the paths we have to write to use a function in that module and also ensure that we prevent naming conflicts by not bringing in any of its functions into scope.

^There is type alias,import alias and reference alias.

*we can use an import alias to prevent naming conlicts when bringing two imports with the same name into the namespace of the scope.

*The pub use keyword is essentially re-exporting the module.It allows a shortcut defined by the use keyword to publicly available to the codebase.This is useful when you want to create two domains of how programmers will think of your library.People that want to work on it will think of accessing the module system through its individual components but programmers calling the library just want to use the features they want directly without having to know the different level of components to get there.

*You can also use the super keyword to access content relative to the parent

*To include external packages in your codebase,you should write them as a dependency in the cargo.toml file but each codebase has its own module system and the module system of an external codebase cant be included directly in another.so in order to use any of its content in a script in your own codebase,you have to bring the content from the external module system into its scope/namespace.This allows you to work with those items without having to reference the entire crate each time.

*You can also use the wild operator to bring all the content from a  module into scope but itsnot recomended because of possible naming conflicts.

*You can shorten the number of use * lines we have in a script by factoring out the common path and put the subpaths that differ in curly braces.

*The recommended style to use for module files is the module_name.rs styel over the mod.rs style because having multiple mod.rs files can be confusing to navigate about if they are all opened in the editor at the same time.

*low poly,high poly

*Vectors can only hold a single type.

*Rust needs to know the type of data that a vector will hold at compile time or else,it will throw an error.Rust cant infer the type of data a vector will hold if it is constructed with the vector constructor without pushing any element to it after its assignment i.e it isnt initialized with any elements since the contsructor doesnt take any arguments.It  will then require an explicit type annotation but most of the time,vectors will be initialized with at least a value for rust to infer the type so the annotation will be rarely needed and rust also provides the vec! macro that automatically creates a vector along with its type annotation for us.

*get returns an option object which can be handled for out of bounds index while indexing will panic.Pick your pick based on the scenario

*The push vector method in rust takes a mutable reference to the instance of the class.This will allow the method to modify the vector without taking ownership and since there can only be one mutable ref at a time,it ensures safety to ensure that only one mutable operation is done at a time

*Looping over a vector in rust requires you to use a mutable ref to that vector.this is to ensure that you dont modify the vector while looping over it as there can only be one mutable ref in a scope.

*An immutable ref invalidates a mutable one but not vice versa.This is because when you create an immutable ref after a mutable one,rust takes the mut one out of scope as it believes that its job is done

*In rust,when reading a value from a vector through indexing,you can choose to access the data by an immutable ref which will allow you to read it or you can copy the data to that variable by directly assigning it to the data at that index as long as the data implements the copy trait like integers or chars.For types that do not implement Copy (like String or Vec<T>), assigning the value will move the data, which means you cannot use the original value after the assignment unless it's wrapped in a reference.Using the immutable ref means that you cant read the array before any mutable refs to that array is made so that later in the program,you dont read any unexpected data but since immutable refs can invalidate mutable ones,you can read the data using an immutable ref after modifying it with a mutable one as it is in push.

*a string object in rust is a wrapper around vectors.u can either use the to string method on the str literal type or the string object constructor directly

*The push_str or push (for a single character) method of a string object is used for copying the content of a string slice or a string literal to the end of a string object by using a reference to it to access its data.Concatenation with the + operator is used for adding a string object to another string object and assigning it to a new variable.It does this by moving or transferring ownership of the left operand string object to the new variable so that it remains memory efficient by not copying the data and for the right operands,it requires you to pass them as immutable references since the data to be appended to a string object must be a reference to a string literal data so that it can copy its contents to the end of the string.But since a &String ref is not the same as a &str ref as the former is a reference to data in the heap,rust does a deref coercion where it turns the ref to &str so that it matches the function definition and the reason why &str is used over &String when appending data is because its easier to read and work with so its purely out of rust preferences.This always ensures that the right operands continue to own their data.The reason why the content of a &str ref is copied instead of directly appending the ref to the string object is because a string object has its data stored in the heap and the variable that references to that data must own all of its data and not having to borrow data from another place and the reason why the right operand string objects are not just moved into the new variable is so that those string objects still retain ownership of their data for use later in the codebase.

*But why not just move all the string objects in concatenation for memory efficeiency why is it the left operand that gets moved but not the right.Who is to say its the right we will need to preserve ownership to reuse later over the one on the left?The reason is because of the components that makes up string concatenation.We have the primary data and secondary/source data.The primary data being the left operand is the one to be modified so it makes sense to move the data to variables rather than copying it every single time it needs to be modified while the ones on the right are the secondary meaning that its a source of data that is to be used to modify one to many string objects and as such,it serves as the source data.Because the source data might be reused across the codebase to modify various string objects,it makes more sense to copy them over rather than moving it which will make it difficult to reuse later

*Immutability over efficiency

*format! is like formatting in println but it returns the data to a variable rsther than printing it to the standard output.It doesnt take ownership of any of its parameters but rather copies the content of each string object.This alternative to direct concatenation makes it less memory efficient than concatenation but it is less cumbersome and allows for flexibility as you can opt into the method you wish for your strings to be handled when bringing them together.If you pass a borrowed type like &str,it takes a ref to it.The format method is more time efficient because for concatenation,the string might be reallocated to a new address on the heap if the space allocated to the string isnt big enough to hold the concatenated data meaning that there might be a new allocation for each concatenation which is more time consuming while the format macro doesnt append data to an existing string but rather,it creates a new string which means that there will only be one allocation and it will be big enough to hold its entire content but might take more space since it copies all of its operands in the case of string object.After copying the string data  over to a new memory in the heap after each reallocation that might happen during string concatenation,rust will automatically drop the old memory to prevent memory leaks and update the memory address that the variable points to to prevent dangling references

*strings in rust dont support indexing like in vectors

*The stack is for integers and floats that are fixed i.e they dont vary in size and known at compile time and function call frames like local variables.The heap is for data that might change over time and is not known at compile time.Data in the heap can grow and shrink over time.Stack allocation is done at compile time while heap allocation is done at runtime so its dynamic.References to data in the heap are stored in the stack but the data itself is in the heap.Strings go to the heap because they are can change throughout the program.Strings in python and js are stored in the heap because they are variable in size which will require the dynamic memory allocation of the heap but they are immutable meaning that any apparent modification to the string actually creates a copy of the string and it means that strings passed to functions are passed by value.This is to ensure preditability and safety by avoiding side effects over memory efficiency but in case of mem efficiency,you can use a join method which takes all the strings from an array to create a string which means it only copies once since arrays are mutable and thus,pushing to an array doesnt copy the array while in rust,the String object is directly mutable and is passed to functions by reference meaning that if you pass it as an mutable ref to the function,the function can create side effects on the string.In rust,you can choose where the string data will go by either using a ref to a string in the static storage which is fixed in size and doesnt copy the data but rather borrows it or by using a string object which allocates its data in the heap.so the final string from format is more time efficient but less memory efficient than concatenation although concatenation can lead to temporary memory spikes during the reallocating process.Format is preferred when working with larger strings

*The &str is a borrowed type so assignments to it is by reference while The String type is an owned type so assignments to it transfers ownership

*There is assignment by copy,borrows it and by taking ownership

*A slice must be a reference because the value cannot be known at compile time and it shouldnt own but borrow the data since its used for read-only operations.Since they borrow data,any changes to the original string will be reflected in the slice unless a modification is done to it that requires a reallocation which will not reflect the changes in the slice as the slice still reflects the old memory address and not the new one.The reason why slices dont change the address they point to because they dont own the data,they are just referencing the data for borrowing.

*String characters can be represented as Unicode or Ascii.Both of them are converted to their byte representation when storing their data in a string since a string in rust is a vector of raw bytes.Since they are stored as a sequence of bytes,indexing is a direct access to a byte and not a character.When indexing for bytes that hold for ascii character data,rust implicitly converts it back to its character representation since an ascii character will always correspond to 1 byte but if you access a byte from a unicode character,it will panic and throw an error because in unicode,no single byte corresponds to a valid character as a unicode character is made up of more than 1 byte but rather,it takes a variable length because and depending on the encoding.Common unicode characters are 2 bytes while more complex ones like emojis are 4.Although,if rust allowed the indexing feature even for unicode characters,it will just return the bytes directly if it cant convert it to a valid character because rust will have to return some data but doing this will create unexpected behaviour later in the code if not careful.So rust prvents errors like this from ever happening by totally removing the indexing feature.

*Slicing is a safer way because it guarantees that the slice will correspond to a valid character given that the slice is valid.Rust will then convert it back to its character whether unicode or ascii.But slicing can lead to runtime errors if they are invalid.Indexing makes it impossible to read unicode characters from a string but slicing allows it but you have to care about character boundaries.

*Because slicing can be invalid,rust provides another method of safely accessing the characters of a string.By using the chars method which will iterate through the string and stack up the bytes till they create a valid character called a code unit and return each code unit to a new array which is closer to how other programming languages like js choose to expose strings to the programmer;as a sequence of characters.But you cannot index into that because it isnt literally an array so you can only utilize it by looping over it.

*Rust uses utf-8 while js use utf-16.Utf-8 can take both ascii and unicode characters.Utf-8 is a variable length encoding which can manage space flexibly but can create complications as it is in rust while utf-16 is a consistent character encoding.For example,utf-8 encodes ascii characters as one byte while utf-16 encodes all characters into at least 2 bytes allowing a wider range of characters to take up consistent space but less common characters like emojis can take up to four bytes in both algorithm.Utf-8 is termed that way because characters can take at least one byte or 8bits while utf-16 takes at least 2bytes.The reason why utf-16 is consistent because many values can be encoded in 2 bytes.This consistent space allows js to represent arrays as a sequence of characters which abstracts from the complexities of representing it as an sequence of bytes as it is in rust so indexing in js is by character offset or code unit.It allows for a character oriented access over a byte oriented access to strings like rust.In other words,many programmers wont have known about any of this if they didnt learn languages like rust that didnt choose to spoil them with sweet abstractions but at some point,you'll care about space.

*Utf-8 is more memory efficient but more complicated as you have to care about character boundaries.If you return a byte thats not valid,youll get the byte and not the character which will lead to unexpected behaviour later while utf-16 is less complicated but can consume more memory for the same characters.So js uses a code unit representation through utf-16 while Rust uses a byte representation because they use utf-8 that encodes the data directly in bytes due to its memory efficiency.Its a system programming laguage so it has to deliver performance.Python uses utf-8 only when storing or sharing the data and actually holds the data in a sequence of unicode points internally which is an intermediate rep of unicode character data.This allows for simplicity and abstractions like js but memory efficiency when sending or storing the data like rust.

*A code unit is the collection of bytes that makes a valid unicode character while a code point is a unique number assigned to each character in the unicode format which gets converted to code units

*C++ like rust use utf-8 but allows for direct indexing but this is only safe when the characters are ascii.So you wont have to worry about boundaries and encoding until you start using unicode characters that span more than one byte unlike rust where it prevents you from ever indexing into a string so you have to care about this from the first time you want to access specific characters from a string upfront.Apart from this,the level of abstraction and control are the same.In both of them,if you need to safely access unicode characters from a string,you loop over a sequence that tokenizes the bytes into code units except that in rust,its provided in the standard library while in c++,its provided by user made libraries

*in these system languages,you will be forced to learn about low level details even if you dont want to as long as you want to use these languages because you will literally not go anywhere using them without attempting to understand the details that you will normally wont care or procrastinate to learn if you are using python and js.

*The char method returns an iterator of the unicode units that makes up a string.

*There are two ways to create a sequences;a random access sequence or an iterator sequence.A random access sequence like a vector will require an allocation on the heap that will cost memory and reduce time performance because of allocation time but once complete,it becomes very fast for lookup operations while an iterator doesnt take any data from the heap because the data is yielded value by value as the code runs rather than storing it in a collection that will require allocation and thus,it optimizes space performance but its slower for lookups.An iterator is a function that yields values and retains state of where it is in the sequence.Yielding means that it will return the current value and hand over execution till its called again.

*Char and slicing are both different ways of accessing unicode units from a string except that char is safer but requires you to loop over the iterator every time which might be less accessible when trying to access many characters as you have to store all of them in a vector first which will bring allocation costs on memory and speed while slicing allows you to directly access the data but requires upfront knowledge of the right character boundaries.They both conserve memory since they both dont take memory as slices just borrow the data while char iterates over the data.But slicing is more accessible for accessing many characters and its faster since it doesnt loop over anything as its direct access and it will even conserve more space if multiple-character accessibility is needed So these two methods are a trade-off between (speed and easier multi-character accessibility) or (safety and lack of prior boundary knowledge).Its better and recommended to start with chars for safety as it aligns with rust principles but use slicing for performance

*The keys and values of a hashmap must be of the same type.

*A vector is basically a heap allocated array

*When treating an option object from a vector or hashmap,we can return a referece or a copy using the .copied method.If we don't want the value of returned to the variable to reflect any further changes to the vector or hashmap in the program but it will increase memory consumption although insignificant in the case of small integers,chars or booleans but we can choose to use a ref and not a copy if we want to opt for more memory savings and its ok or needed for it to reflect any changes to the collection in the program.

*if the collection doesnt get updated in a way that affects previous values like push or insert operations,using a ref is better since it saves that extra 4 bytes or more and will still provide the same output as copying it.

*You can use the .copied method on anything to copy data thats on the heap.

^Borrowing it,owning it,copying it are the different ways to do assignments.A copy becomes independent of the source.The owner becomes the source while a borrow becomes dependent on the source

*When looping over a collection in rust,we should use a ref to ensure that the loop doesnt own the data.An immutable one for read and a mutable one for write operations.

*For keys and values that their data are on the stack,the heap owns the data but for data on the stack,the map copies its data

*I cant pass references to a temporary heap allocated data like string objects used directly on the fly without an assignment.This is because it will lead to a dangling reference as the data will be dropped immediately after use because it doesnt have an owner.Rust prevents this from happening but not c++ where it will lead to undefined behaviour.You can work around this by lifting the temporary value to a variable that will take ownership of it and the program will execute safely without creating a dangling reference but if it were an integer,there is no need to lift it as its in stack memory and will be copied if needed.

*The ownership model is the solution to all these mem management pitfalls but rust requires you to figure out how to work around it to still execute what you want but in a memory safe manner like through lifting temporaries which one will have to discover on his own making the programmer fully responsible for the memory usage of his program

*You cannot have a mutable ref after an immutable one to prevent undefined behaviour in parts of the code that wants to read the same value and accidental modifications to the value before its used.

*You cannot borrow a value mutably if the owner isnt declared to be mutable.This is to ensure that any data mutations is intentional and not accidental.Its a double check.Thats why variables are immutable by default.This is different from python and js where variables are mutable by default which can cause unintended side effects like when arrays are passed to functions.New devs wont know that they are passed by ref and can cause accidental modifications while in rust,even a vector thats passed by ref still requires permission before its modified.

*Hashmaps must have unique keys so inserting a value with an existing key overwrites the old one

*rust requires that you either have one mutable borrow or multiple immutable borrows but not at the same time.you can only create immutable refs after a mutable one which will invalidate the mutable one.The borrow checker is like a permission controller;immutable refs have read-only access while mutable ones have read and write access.

*integers,booleans and chars are stored in the heap only when they are inside collections which are stored in the heap.So using those values requires a ref.The vector structure itself is stored in the stack because the pointers go to the stack but the intger data goes to the heap.So you can control the allocation of the integer data to either the stack or on the heap

*mutability and immutability is independent of whether the data is stored in the stack or heap.the reason mutable integers go to the heap is because its allocation is fixed regardless of how the data is mutated which means that whether data goes to the stack or heap isnt about whether it will be changed later but whether rust knows that the allocated space for the data wont change after compile time.Integers have a predictable memory allocation according to their type regardless of how large the value is.The same for character and boolean which have a predictable allocation of one byte so all of these go to the stack.But we can never predict the space that a vector or a string will take and as such,they go to the heap.

*You can read the value that a reference holds by directly using it but if you want to modify the data that mutable references borrow,you have to use the dereference operator *.This is to ensure that you are intentional about using the mutable reference to modify the value at a particular part of the codebase when you mistakenly meant to use it for reading at that point.

*Assigning a variable that has stack allocated data to another variable copies the data unlike for heap allocated data like string which transfers ownership.If the variable holding the integer data doesnt change,copying it to another variable will be memory inefficient so using an immutable ref to another variable is better.But there are some complexities about opting for immutable refs because of memory efficiency;

*There are three ways to modify the data stored in a variable:by overshadowing/redeclaring,by mutating it and by reassignment.Modifying a variable by directly assigning the variable to a different value after its initialiation and declarartion as mutable is modifying by reassignment.You cannot modify a variable like this after it has been borrowed like incrementing a variable after it has been borrowed by a ref.This is because it will hold its newly assigned data in a different location whether on the stack or on the heap and making the older one invalid.This will make the borrowed variable a dangling reference because it no longer references a valid memory.So there are three ways around this;You either perform the reassignment before borrowing it,2.you use a mutable reference to change it because it directly modifes the data at that address without changing its location unlike reassignment or 3.overshadowing the variable.This is because overshadowing is pretty interesting in how it works.Overshadowing redeclares a variable not just reassign it.It allocates data in a different address but it doesnt invalidate the old one because it declares the variable as if it were a new one entirely meaning that any borrows to it before it was overshadowed is still valid.The preferred approach is to use mutable refs unless you dont want mutability where you will then use overshadowing another way to prevent all of this as a whole so that you can still reassign to modify the variable after its been used by another variable,is to copy the data over to the other variable and not accessing it by reference.

*order of priviledge:read-only,read and write,ownership

*so one can start with rust if they dont want to shoot themselves in the foot but they will learn about mem management by working with the compiler when it throws them errors while starting with c++ means you are starting out writing buggy software then coming to rust for safety later.Rust is better for beginners,it forms good habits early unlike c++ where you suffer enough from the bad ones and then learn why the good habits exist.This is the nature of Rust to C++ and C++ to rust transitions.

*panics and fallbacks are different ways of handling unexpexted behaviour.A panic will make the program to abort while a fallback will give the program a way of handling the situation.A fallback is more user friendly while a panic is necessary from stopping something critical from happening to the program.A fallback creates fault tolerant code that happens under expected conditions while panics should happen when under any normal circumstance,should something happen else allowing it to execute can lead to critical damage.The get() method fallbacks while indexing panics in vectors and unwrap panics while unwrap_or() fallbacks.

*entry doesnt overwrite.It only writes a value to a key if the key doesnt exist and returns a mutabl ref to it to the map.

*another thing is that panics shouldnt give stack traces as error outputs because every piece of this data can be used by attackers to know where in the codebase and perform variations of what they did to understand how the code responds to errors and over time,get full information about the error handling checks of the program and try how to crack their way around it by creating unchecked circumstances but having writing the program in rust will slow this down since memory and race condition vulnerabilities are removed by rust

*Any information thats meant to be used only development that gets exposed to production environments is called a leak.A leak in itself doesnt mean an instant defeat to the program but it can expose enough information that hackers can use to craft sophisticated attacks.Using environment configuration files like .env files with a tool like Git leaks can help prevent this and anonymizing logs can prevent this isssue.

*rust also ensures that you pay more attention to your code.

*The or_insert method returns a mutable ref to the value of a specified key in a map.If the key exists,it returns a mutable ref to the value as it is else,it inserts the new value and return an immutable ref to that

*attacks by memory corruption,by unsanitized inputs,race conditions,program intel

*Inconsistent outputs

*so a hash table is a function,an array and an optional linked list layer.The function takes a key and uses a function called the hash function to generate an index to the underlying array.The underlying array holds the data.But in the case of collisions which is when two keys maps to the same index,a method called chaining where the value at that index in the array is a pointer to a linked list where series of k-v pairs occur and secret key is like salting against rainbow tables where even if they get the input right,it will never collide with another key.It is used by the siphash function which rust implememens.It may not be the fastest but rust prioritizes security over performance.Hackers can take advantage of collisions by creating a vast amount of inputs that collides with others which creates multiple linked lists that can crash the program and slow it down for other users leading to Dos attacks.If they create keys that collide with legit data,they can use those keys to overwrite that data.Because of the way collisions are handled,keys dont get access to the same data even if they collide but existing entries can be overwritten and attackers can exploit dos attacks

*Python and js use general purpose hashing for typical use cases and overall good perfromance but its not highly collision resistant like siphash that rust uses.

*An implementation is a variation of a programming language in terms of its compiler or interpreter.It represents a different way of writing the compiler or interpreter for that language, often with unique optimizations, features, or behaviors.Js has different implementations based on runtime environments like node js and the browser engine like v8,spider monkey.Python has cython,pypy etc.Different implementations have various optimizations.

?Abstraction vs control

