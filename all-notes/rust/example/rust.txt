so macros are like functions for reusable blocks of code but macro genrates the reusable blocks at compile time unlike functions that gets called at runtime.this allows for compile time optimizations and can generate different code structures based on the input unlike functions that have a fixed structure

When a macro is invoked, it expands into code at the call site. This means the generated code can be different for each invocation, leading to more efficient and tailored output.

Functions: Always call the same block of code regardless of how they are invoked, which can lead to performance penalties if the function is called frequently.

macros give a more expressive syntax

functions have a fixed signature while macros signature are flexible to syntax patterns although function overloading in langs like ts,make function signatures flexible based on input and generics with union types makes return types and input types very flexible

functions can also take a varible number of args by using the spread operator

function overloads are resolved at runtime while macros expand into code at compile time allowing optimizations

Macros are generated at compile time which can prevent errors early rather than functions throwing errors at run time when the wrong args are passed

cargo is the package manager for rust and its cargo.toml and cargo.lock as oppossed to package.json and pnpm-lock.yaml or packagelock.json as it is for js files.This is called local project management.Its better to install dependencies for a particuar project rather than globally on the file system.pip does this globally i believe and thats why there is somthing called virtual environment

the dependency file is for specifying the packages and the versions a project uses while the lock file is for ensuring that the versions of the dependencies remains consistent regardless of the environment

toml and json files are for project management
cfg files are for settings for an app or a tool
yaml and json files are for serializin data

dependencies in rust are called crates as it is called node modules in javascript

lock files are managed by the package manager while the dependency files acn be manged manualy

*ill use rust to convert the size of my compressed array to a smaller size by representing chunks in the smallest byte representation possible for that chunk rtaher than having a consistent size across all chunks

*Dont need pinno for logging,the vscode turbo console log extension is far superior as it automatically creates detailed log messages and can adap it when the code refactors.Its a log manager

js is interpreted by the browser,so it can run directly in the browser
js in frontend frameworks have to be compiled by the frontend framework into regular js dom manipulation and then bundled into on js file with a web bundler like vite before running it on the browser.
running js standalone requires node js 
ts needs to be compiled to js files before its ran in the browser or node js envirnonment

since rust is a compiled language language,it has to get compiled into an executable before it gets ran

cargo build
cargo run
cargo clean
cargo check

cargo build emits the executable in the target/debug folder for quick re-editing while cargo build --release builds it as a final program for use so its slower so only use it when the final build of the program is ready.

"General learning material for Language X" is a completely different scope from "Teaching the basics of programming using Language X". The former is suitable when you are a beginner to the specific programming language but not to programming in general, whereas the latter is required when you are a beginner to programming in general.

react requires that states must be immutable and editing them should return a new value which reps the current state and not directly modify the state itself the same as rust

*rust is one of those languages that uses an entry point function called main.It also uses curly braces to create blocks over indentation and it uses semi colons as a line terminator

*intellisense is provided by a language server

*compile time erros means that the program isnt safely doing what its suppose to do yet.

*In js and python,variables are mutable until explicitly declared immutable stated while in rust,variables are immutable by default unless they are explicitly declared mutable

*in c++ and rust,printing to the std output must be in a string literal.I belive that python and js do this under the hood by an abstraction

*constants are immutable together with the fact that they must be annotated and they can be declared in any scope and the value of constants must be known at compile time instead of run time like immutable values meaing that the values of constants must be hardcoded while immutable variables can be assigned the values of other variables upon declaration

*constants are best for having a single source of truth for all the hardcoded values that will be used in your program and it also makes them more readable while immutable variables are for enforcing safety

*You cannot change the type of a mutable variable

*Shadowing is redeclaring a new variable with the same name as a previous variable.This means that the new declaration shadows the old one and takes precedence.It is used when trying to change the value and type of an immutable variable without actually mutating it because its actually declaring a new varible but with the same name.This ensures that the variable always remains immutable across changes and it also prevents the need for creating many similar variables but with just different names.Its a false sense of mutation.It can be considered as a safer alternative to mutation

*Mutation means changing the value of a variable after its declaration while shadowing doesnt.

*Immutability leads to predictablility as seen in react and redux and its the same for rust.

*integer,float,boolean and character

*Unsigned integers are guaranteed positive integers while signed integers may be positive or negative
*You can use _ as a separator for long integer values and you can suffix the type of a variabe that holds an integer with the type in front of the integer

*when an integer overflows,it can cause two things:if its in debug mode,it will panic and throw an error but if its in release mode,it will wrap around the given range which is also an error.

*i,u,f

2^(n-1) is the formula for calculating how many numbers can be produced with n bits.

*boolean values in rust are one byte
*there is unicode and ascii way of representing strings or characters just like python because unicode can represent a vast array of characters including emojis

*chars use single quotes in rust while strings use double quotes

*tuples can be unoacked in pythin and rust as arrays can be destructured in javascript

*arrays,tuples and vectors.Tuples can be composed of any types while arrays cant and arrays are fixed in length

*an array is a fixed large chunk of memory allocated to the stack

*in python functions arent hoisted but they are in js and rust

^Change the folding strategy in vs code to indentation

*expressions and statements.expressions return a value while statements are a series of functions.defining a functions is a statement while calling a function is an expression.

*you can create scopes in rust

*statements use semicolons to terminate the end of it while expressions dont.if you use a semi colon to terminate an expression,it will become a statement

*rust is expression first meaning numbers and arithmetic operations themselves are implicitly treated as expressions.

*in js,anything truthy value can be used in a condition check while in rust,only expressions that evaluates to bool values can be used.

*in js,paranthesis are required for blocks
*in rust,they must be removed
*in pythin,they are optional

*switch case statements are just syntatic sugar over if-elif ladders

*Blocks of code evaluates to the last expression in them and they are denoted by curly braces.

*In ternary statements,each block must return the same type and this is because rust needs to know the type of a variable at compile time and not at run time.If they allowed it,the compiler will be more complex and will provide less reliable type checks if it relied on possible values of a variable.

*do while loop,while loop,loop
*iterators and range constructs.
*range constructs are made up of a loop counter,end and a step and it can be forward or backward

*The loop keyword is like the while loop except that it doest check for any condition before it enters the loop and it only terminates when explicitly stated in the program with the break keyword

*variables are only visible within the scope they are declared meaing they are not visible to sibling scopes.They are also visible to child scopes but parent scopes cant access the variable in child scopes unless the scope returns the variable.Child scopes cant shadow the variables in the parent scope and can only modify it if the variable is declared muatbable in the parent scope.This is an intentional design choice to allow for predictable code.

*Blocks are made using {}

*Because lines have to be terminated by a semicolon in rust,only the last line of any scope in a rust program can be implicitly made as an expression.

*Running a program in debug mode will only work when there are breakpoints as a debugger is just a detailed step through for a program.

*Break is for breaking loops while continue is to skip the current iteration of the loop

*Scopes are valid blocks like if statements,loops and functions.They are used for scoping code.the last line is implicitly the return statement for scopes meaning scopes can also be used as expressions

*the loop keyword just tells a scope block to repeat itself indefintely until there is a break.You can return a value from a loop block by writing the value you want to return after it

*in rust,before an element from an array is accessed,the compiler takes the extra step of checking if the index is valid.

*You cannot type annotate the loop counter in a for loop

*arrays can be generated by [1;5].The former generates one five times.

*To do range constructs,you iterate over a special array type particularly for this through:[1..5]

*You can also use the rev() method to do a reverse range construct

*js and python use a garbage collector to manage memory,c++ uses manual mem management and rust uses ownership

*the compiler checks for features of ownerships that if they are not met,the progam wont compile

*There are two places of memory in a program; the stack and the heap. The stack is for storing data that's of a fixed and known at compile time while the heap is for data that's of an unknown size. Data can only be added to the stack through the top and accessed by the first in, last out order or the rule of stacked plates and data in the stack only exists for the scope its called in.Once the scope finishes,the stack get cleared and as such,the stack manages itself and its very safe.function parameters and local variables are stored in the stack till they get cleared when the scope is finished.Its simpler and faster to manage than the heap as the program only has to manage only one contiguous block of memory.

*While the heap is for data that's of an unknown size at compile time or for variables that their values change often but the locations of each data block is sparse and can only be accessed by an allocator and since its sparse, it takes more time to allocate and access data on the heap. On the heap, its called allocating and deallocating while on the stack, its called pushing and popping.Data in the heap is left there until explicitly deallocated.You can only access data in the heap by following a pointer that leads to the address of that variable in the heap and since pointers are of known sizes,they are stored on the stack

*integers and arrays of fixed sizes are stored on the stack while flexible sized arrays and strings which grow and shrink dynamically are stored in the heap.

*strings and integers are passed by value while arrays and objects are passed by reference

*Dangling pointers are pointers that points to the address of a memory block that has already been freed and it can cause unexpected behaviour if accessed in the program and smart pointers are pointers that come with memory safety and more features.

*a null pointer means that the pointer doesnt currently point to any memory address.

*pointers get cleared like any normal variable when the scope exits but if they were left pointing to a memory,the memory remains allocated until explicitly freed

*Without pointers and references,you cant access data stored in the heap but for data on the stack,its direct through its variable names but many hll use references and garbage collection which is a manger for references as an abstraction over pointers.references are safer than pointers as they can never be null and it will always lead to valid memory

*For arrays,the pointer initially returned is the pointer to the first element of the array and since arrays are stored in a contiguos block of memory in the heap,the addresses of the elements are serialized and you can use pointer arithmetic to get the other data in the array.Array indexing is just an abstraction of using pointer arithmetic to access elements in an array

*There is a difference between a pointer and a reference.A pointer is a variable that its value is an address to another variable in the heap and can allow you to perform arithmetic operations on that value to create new pointers but doing so can lead to dangling pointers.Since pointers are just variables,they take their own space and have mem addresses on the stack while a reference is a direct alias or mapping to a variable in the heap meaning that it doesnt have its own space on the stack and it shares the same memory address as the variable is aliasing to.Pointers can be reassigned to another memory address while refs cant be reassigned this is because pointers are assigned at runtime while refs are assigned at compile time.References are safer because they cant be null which prevents dangling pointers.

^there is memory leak and memory fragmentation.

^Garbage collector,manual mem mangement and ownership are the different ways programming languages manages meory on the heap

*time allocation--single threaded,asynchronous,multi threaded,multi processing.

*strings and integers are immutable since they are passed by value 

*namespaces and import aliases are used for import safety to ensure that imports dont collide with existing functions in the same module.

*In js,you can do selective exporting and then import them under a namespace as a variable or use destructuring to import them directly in the namespace.

*rust uses the :: notation for accessing the methods in a type and the exports in a namespace/module and not the instance of that type But uses dot notation for instance methods and properties.Its a design choice for clarity while js and pythin use dot notation for both because of simplicity and consistency

*there is selective export and module export

*the string type is mutable while the string literal is immutable and is known at compile time and as such,its stored in the stack.

*when making string types,it makes a request to the allocator to get the space its need to store the string

*because integer values are known at compile time and they dont carry that much data,they can be created on each variable assignment and stored on the stack

*The pointer,the length and the capacity.The length is how much bytes the string is taking in memory while the capacity is the amount of memory in bytes given to the string by the allocator.This means that when you attempt to copy data thats on the heap,you actually copy the pointer,the length and the capacity of that variable on the stack and not the actual data.

*arrays will always decay into the pointer of their first element

*Data in the stack is accessed directly by the value such as integers,booleans,characters and fixed arrays and tuples while data in the heap is only accessed via pointers and references

*compilers can choose to copy the data on the heap but it will be computationally expensive in both memeory and at runtime since it takes the allocator some time to find free space on the heap and thats why variables that their values is another variable holding arrays are just shallow copies and not real/ddep copy because they still point to the same data on the heap but rust takes a different approach to prevent double free deallocs so it invalidates the first variable which is known as a move to ensure that only one pointer to data in the heap only exist at a time and as such,it is not a shallow copy meaning that you cant use the invalidated ref or it will throw an error

*Memory dangers can only be prevented when you call free at the right time mapped correctly to the right alloc.

*trying to deallocate memory on the heap twice will lead to memory coruption,unexpected behaviour and security vulnerabilities

*shallow copy and deep copy.

^dragon ball daima,manga

^in next js,a sidebar is loaded as a layout across many pages and the component that holds the content of what the sidebar leads to is a page that you get routed to by next js but in plain react,i used redux where the sidebar dispatches an action to change the current loaded data state and the content component will always reflect the current loaded data.The paradigms are different because of the way these apps approach rendering as next js creates multiple pages while react uses a single page,in next js apps,clicking on content on the sidebar routes you to the appropriate content while in react,it dispatches an action that changes the current state that the main page will always reflect

*discovering and building

*navbar and sidebar are for navigation

*rust takes a different approach.Once the variable goes out of scope,the variable that owns it gets deallocated so rust automatically calls a drop method to release the memory once the variable goes out of scope

*when you assign a variable to a new value on the heap,rust will automatically invalidate that reference but it will only drop it when the variable that owns it goes out of scope

*variables that have their data on the heap have stack data that contains pointer,length and capacity information and as such,when you copy that variable,you are only copying the stack data and not the heap data

*integer values are known at compile time and as such,they are stored on the stack meaning that variables that hold integer data dont get invalidated and the value actually gets copied when another variable attempts to copy it.This is the very reason why they get copied to a function when they are passed to a function as passing values to a function is just another form of assignment.

*integers,floats,boolean,chars and tuples of any of the types mentioned go to the stack.

*When you pass values to a function,they get copied into the function but when you pass refs like strings and vector arrays,you pass a ref to the function which means that modifying the variable in the function will modify the actual variable itself but rust also adds something else,when it also moves the ref or pass the ownership of that ref to the function meaning that when the function goes out of scope,rust will drop that variable and the variable cant be accessed in the caller after it called the function,it cant access the variable again

*This also means that in rust,when you pass variables that hold references,you also pass the ownership of that reference and when the function returns the variable back to another variable in the caller,it also returns the ownership of that variable back to the scope of the caller.

*This also means that all variables that hold references to data in the heap,are owned in the scope that declared them and when the scope is done,all the references it owns gets dropped.When a function returns a variable that holds a reference,it surrenders the ownership of that reference to a variable in the caller's scope.

*when a variable loses ownership of a reference,it gets invalidated by rust.So when you assign a variable a new ref value,the old ref has no owner,so it gets dropped.

^dropped and invalidated,ownership.

*This also means that in rust,anything that has to do with variables that hold references means transferring the ownerhip of that reference.

*but this is tedious as handing over and returning ownership becomes tedious

*rust goes through the ownership model and not the reference model used by garbage collectors

^exploit

*CORRECTION:so there is a difference between ownership and reference.Garbage collectors use references meaning that when you pass a variable that holds an array to a function,the function creates another ref and not take the ownership to the ref and the gc will clear it as soon as there are no refs again to the value but rust uses ownership meaning that array/object data doesnt get dropped till the variable that owns it gets out of scope and if a variable is given another data,the data from the old ref doesnt get cleared,it just gets invalidated.This also means that the ref no longer has a valid owner but it will only get dropped if the owner goes out of scope

^ownership,references and pointers.

*the ownership model of rust mimics the stack

^you can only access data on the heap through pointers and references.Ownership isnt a way to access data on the heap,its just a system that manages who owns a piece of data and when that data will be deallocated.

*Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference.

*references in rust is a way to pass data on the heap to a function without transferring ownership meaning that it can use the value but the value wont be dropped when the function goes out of scope because it doesnt own that value and the function doesnt have to return it back because it never owned it.

*references are immutable by default which means that any function that uses it only has read only access but there can also be mutable references which means that the function has read and write access.

*passing values to a function by reference over directly giving ownership is borrowing

*You can create many immutable references but once you create a mutable reference,you can no longer create or have any other refs to that variable again.This is to ensure safety because users of an immutable reference don’t expect the value to suddenly change when they want to use it and when they are using it.However, multiple immutable references are allowed because no one who is just reading the data has the ability to affect anyone else’s reading of the data.This restriction prevents data races as it gets caught at compile time because data races can cause undefined behaviour at run time.

*mutable references can only be made from mutable variables

*Many functions can use the same mutable reference.

*There can only be one mutable reference per scope and creating another mutable reference will have to be done in another scope.This is because mutable references stay as long as the life time of their scope and they only get dropped when their scope finishes.The same goes for immutable refs execpt that immutable refs get invalidated for use after a mutable one has been introduced.This rule prevents potential data races.If you were allowed to use immutable references after creating a mutable reference, it could lead to situations where one part of your code is reading a value while another part is modifying it, which could cause unpredictable behavior.

*Immutable references go out of scope from the point they were last used after their declaration.

*The reason why data that no longer has an owner or reference to it doesnt get dropped till the ref/owner goes out of scope in rust is to prevent the ref from dangling which is when the data is deallocated but the ref to that data still exist.This guarantees that a reference always points to valid data.Dangling references can still be created when a function returns a ref to a local variable which is invalid because the local variable goes out of scope after the function executes and as such,there is no value to borrow from meaning that the caller is referencing to nothing.Rust wont compile this.The right thing is to return the value itself,which surrenders ownership of the value to the caller.

*functions normally shouldnt take ownership of their arguments until when necessary.

^edits

*Python uses the variable[x:y] notation for slicing,js uses a function while rust uses the &variable[1..4] for slicing also known as the range syntax which is used in range constructs.

*string slices must occur at asciii character boundaries else,it will throw an error.

*slices are immutable refs to a part of a string meaning that slices dont take ownership of the data and you cant modify them.

*Just like how arrays decay to pointers of their first element,slices become refs to the first element of the array and its length.

^the stack,the heap,the binary read only memory

*string literals are immutable refs to string data on the binary read only memory

^data in the stack has scope lifetime.
^data in the heap has a persistent lifetime depending on the model used--manual,gc and ownership
^data in the binary read only memory has a static lifetime meaning that it never gets deallocated

*the stack also holds function call information

*The binary read only memory is a section of the data that is included directly in the compiled executable of a program and it can never be modified.This means that the data remains even after the program is closed and it is loaded back into the program's memory once the it is opened again.So in rust,string literals and constants get stored in this storage because it saves the allocator time from finding space in the heap to store this data and it can only be accessed by reference in the program because no variable can take ownership of it as its read only and cant be deallocated.But string data on the other hand,which is one that can shrink or expand throughout the program is stored in the heap.

*String literals are the only types that gets stored in the binary storage because they are hardcoded and known at compile time.even if integers are hardcoded and immutable,they are still stored in the stack because they are mostly shortlived and dont usually leave the scope they are defined in.The only way immutable integers can go here is if they are constant.

*The gc is a higher level abstraction that allows programmers to not worry about a thing about memory management while rust ownership model provides some abstractions only to guarantee safety at compile time but the programmer will still manuallay control the lifetime of data through borrowing and ownership and control which memory type every piece of data goes to by declaring it as immutable,mutable and const.

^libraries,modules,frameworks,the standard library.

^react state,rxjs and events are used to implement the observer pattern.

*With tauri,you can interpolate js and rust code in your apps.

*You can write secure code in rust but if you are going for exploitation code,you will want to go for C,C++ or python because the exploits are what rust is trying to prevent you from doing.

*dataframes are a way to create table structures in code.

^biome js and prettier are code formatters.Try out biome js

*for git,its safer to explicitly ignore which files you dont want to see rather than telling it to ignore all files except ...

*Gitignore is safe because an ignored file doesnt get removed from the repo.it just doesnt track any changes to that file for the next commit.

^Rustlings,the rust book,rust by example

^Approaches to memory management
*Through pointers--Manual memory management
*Through references--Garbage Collector
*Through the ownership model--Borrow Checker

*package managers are for managing dependencies and scripts across codebases like npm,cargo,poetry.
*project scaffolders/scaffolding utility are for setting up a structured folder for any type of project like vite,nest js.
*build automation tool which helps to auto compile,bundle and execute your code and optionally with auto reloading when the src code changes

*Build automation tools require one entrypoint file that intiliazes the app and manages imports.For rust its the main.rs file,for vite its main.tsx and for nest js,its the app.ts file.

*Package managers are often also basic project scaffolders
*in rust,cargo is not only a package manager and scaffolder but also a tool that compiles and run your program for you.its like vite that bundles your code for you and runs it with hmr and nest js that also compiles your ts files before executing it.

*It was js that i learnt the importance of a project/package manager.

^Bundler,compiler

^React--compiled,bundled,executed
^Nest js--compiled,live running

*intellisense suggestions are provided by a language server

*in rust,there is a difference between a string object and a string reference.A string reference is immutable,hard coded,known at compile time and stored in the binary storage since its just a ref to a string object in the binary storage while string objects can be mutable,can shrink and grow at run time and are stored in the heap.

^Typescript enforces type safety,Rust enforces memory safety.They both catch many errors at compile time

?Interfaces/Structures and Classes
?Land analogy--ownership model and gc

^Typescript with Rust

^Funk,Reverb,Nightcore and other musical effects

*nest js and angular are object oriented

*In rust,references to data dont outlive the owner of that data and as such,rust uses lifetimes to determine how long a ref is valid.Normally,ref get invalidated once the owner's scope is left.

*lifetimes are denoted by an apostrophe followed by a letter.they are used to tell rust how long a reference is valid for use before it invalidates it.Without specifying lifetimes, the compiler wouldn't be able to determine how long these references are valid which could to references that point to invalid memory and become dangling.

*Lifetime annotations are used to tell the compiler the lifetime of a reference.Rust implicitly creates lifetime annotations for simple assignments and function signatures but it is required in complex scenarios like struct.In assignments,lifetime annotations are implicitly tied to the owner meaning that if the owner goes out of scope,the reference becomes invalid.Rust doesnt infer lifetime annotations for structs because it can lead to ambiguity as each field might have a different lifetime.

*In situations where there is only one reference made at a time like in assignments,rust can infer its lifetime to be tied to its owner but when there are multiple refs to be handled by one entity like a struct or a function accepting many refs as pars,the lifetimes must be annotated explicitly so that the compiler can know the relationship between the refs

*in rust,the entire instance of a struct must be mutable if changes may be required after initialization as fields cant be mutable individually.This is so that refs to struct objects can only be mutable or immutable at a time and that no part/some of its fields can be immutable and mutable at the same time to prevent data races,ensure safety and prevent borrowing rules.

*in rust,data in the heap gets dropped if the owner gets out of scope,meaning that variables are local by default.

*Static storage is for data that will exist throughout the lifetime of the program menaing that variables in this storage are global and they are stored in the binary heap storage.

*News flash:By default,a ref can never outlive the data it points to but rust uses annotations so that it can keep track of how the ref is used in the function or struct to determine its lifetime and use it to know the relationship between future use of the refs in the same scope meaning that ref names must be consistent across the entire scope and lifetimes can only be defined in their definitions and no other lifetimes outside of what was defined can be used in the scope else,it will throw a compiler error and they are scoped to the function or struts that defines them.

*Lifetime annotations are just placeholders that can hold any arbitary name so you can use any name you like as long as its consistent across the scope.They can be either generic:a,b,c or descriptive:short long.Only the static lifetime annotation is hardcoded as it is used to tell rust that data must be global and must be stored in the static storage.Apart from this,other annotations are given lifetimes based on how rust infers it at compile time.

^This is similar to how react uses keys in list rendering to keep track of which values change to avoid unnecessary re-renders.React is the one that actually uses the keys,all the devs need to do,is to provide it.React relies on developer-provided keys to manage component rendering efficiently, Rust relies on developer-provided lifetime annotations to manage memory safely. Both mechanisms help their respective systems function effectively while placing the responsibility of clarity and accuracy on the developers.

*rust can just add annotations themselves if they wanted to but making devs to explicitly add names,allows for clarity as what the purpose of the ref is and clearly defining the relationships between refs

*so lifetime annotations are rust way of preventing dangling references as it states how long refs are valid

*The only lifetimes that can be used in a function or struct are the ones that are included in their definitions in the <>.

^You can use the field init shorthand syntax in rust when creating new objects from structs as it is in js.Rust also has a struct update syntax which is identical to js spread operator excep that in rust,it must come last but for js,it can be anywhere.This is just rust design choice.

*When you create a new struct object say object2 from an existing one say object1 using the struct update notation,any field data that is stored in the heap as defined by the structure will be moved from object1 to object2 if object2 doesnt create its own new value for that field as borrowing rules apply to the field level meaning that object1 has lost ownership to that field data to object2 and that field becomes invalid for object1.This is because,the update syntax essentially copies each of the field's data to create a new object but if any of that field data is in the heap,it moves the ownerhsip of the access to that data to the new object

^References and owners
^Redux provides state safety for react apps

*structs that dont use references in any of their fields dont need lifetime annotations.For fields that uses data on the heap directly,ownership applies.

?An object is just another way of storing grouped data like an array except that data access is by field name and not by index

^Tuples,arrays and vectors

*Tuples and arrays are both a sequential collection of elements that are known at compile time and as such,they are stored in the stack meaning that they implement the copy trait and not the move trait in rust.The only difference between the two is that all the elements in the array must be of one type while tuples can have elements of different types.Vectors are arrays that can grow and shrink during runtime and as such,they are stored in the heap.They are made to only hold one type because of type safety during runtime and you can only get different types if you use a vector of enums since enums can hold different types.

*Tuple structs are just a semantic layer over tuples by providing a struct nature.They take the name of the struct and a tuple definition which holds the type of the fields rather than raw values.They can be initialized unlike tuples.They are simply structs behaving like tuples where the field name is implicitly set as the index.Functions that take one tuple struct cant take another even if the tuple structs have the same types and number of elements.This is to ensure safety.

*so we can have a tuple struct or an object struct.

?How to access an array element with an index.
?unit type struct

^Unit-like structs can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself.They are a simple yet versatile feature in Rust. They allow for the creation of distinct types without associated data, which can be beneficial for type safety, marker patterns, and implementing behaviors via traits. This makes them a useful tool in Rust's type system, especially in more complex applications.

^Copy and move traits in rust.

*Unit like structs are for structs that dont need any data to implement methods

*In strucures in rust,we will want to have each object from that structure own all of its data so that it simplifies memory management and ensures safety.For example,in a struct,we will want to use the String type over the &str reference as the former allows the instance of the struct to own that string since its allocated to the heap but for the latter,the instance doesnt own its data and as such,it needs to use lifetime annotations to ensure that the reference to that data doesnt outlive the owner (in this case its the instance) to prevent dangling references

^Signature and definitions/implementations/concrete data
^Loose equality,Strict equality,Deep equality

*Typescript interfaces combine both data and method signatures while in rust,structs are strictly for data signatures while traits are for method signatures meaning that a ts interface is loosely equals to struct + traits in rust.

^The compilers are Clang,GCC,MSVC,intel C++ compiler

^msys2 is a development environment for C++ that provides a unix like shell for windows but it isnt integrated into a text editor.It is a collection of tools like compilers and package managers that can make ready C++ projects.I use msys2 to install c++.Msys2 allows you to install packages for C++ by using pacman as the package manager.Other options are the visual studio build tools,minGW that uses GCC.A dev environment takes you to the shell.

*An IDE is a development environment thats integrated into a text editor.In other words,its a supercharged text editor.

^llvm is a compiler framework that has compilers and allows developers to create their own.

^MinGW is a compiler suite/suite of compilers like GCC and other utilities

^The visual studio build tools is a set of tools for developing apps for windows.It uses a custom compiler called MSVC as its main compiler.

?Tuples-in terms of python and rust
?Coordinate geometry and Volumetric geometry

*so coordinate geometry data is an array of tuples where each tuple contains point data that can be related to form a shape while volumetric geometry data is an array of arrays where the outer array is the grid and each inner array is a layer that's stacked along the z-axis and each of those layers is an array of tuples which contain point data.They both come down to an array of tuples except that in the former,its just an array of tuples meaning that they are all just continuous number of points while in the latter,it has a finite number of arrays as each layer/inner array has many tuple data or voxel data

*in coordinate geometry the tuples representation of their data is the same as that of voxels in volumetric geometry as point(x,y,z) looks identical in structure to voxel(x,y,z) but i believe the difference is that since in coordinate geometry,there are no layers,the tuple just becomes the location of a point and a point can exist anywhere in the 3d space freely and the whole shape comes together when these points are related by many continuous points in between but for volumetric data,since each voxel is in a layer of fixed z-axis,only the x-y plane defines location while the z-axis represents the depth of the space it occupies as a volume and the whole object comes together with many of a finite number of of voxels.The reason for it being finite is that computers dont have the power to generate an infinite number of arrays that each hold voxel data.

*a grid is made up of number lines made to perpendicularly intersect at each other and thus creating multiple axis.

*Objects made from coordinates are hollow in the sense that they only represent surfaces and dont provide any information about the internal of the model while volumetric object encapsulates both the surface and internals of the object.

*Point data is best for 3d modelling and particle simulation while voxels are best for scientific purposes

*Triangle geometry is an extension of coordinate geometry, using triangles to connect points defined in a point data array, where each triangle is formed by indexing into the array of vertices.

^google made go and dart
^microsoft made typescript

^java and C# are object oriented while haskell and erlang is functional and python and js support the two.

^monad--a way for functions to do something with absolutely no side effects

*The concept of mutable state is mostly with classes than functions.Purely functional programming langaues promise no side effect whatsoever on the data the program use.

?poe crashed and reopened and now the ourple is more saturated.

*implementation in rust is a way to provide method definitions and concrete implementations to a structure.

*its best practice to borrow the self parameter as we dont want the method to take ownership of the ibstance

^class--interface + functions

*getters are a way to make fields private but the method public to ensure that the property is readonly

*C is procedural

*a pointer is like here is the address to the data of the variable on the heap while a reference is more of when i say x im referring to this particular data stored in the heap.

*Rust does automatic referencing and dereferencing when calling methods on instances meaning that any method that will use self i.e instance methods,an immutable borrow reference to the instance gets implicitly passed as the first parameter to that method

*constructors in rust implementation blocks can be named anything you like but a good convetion is new unless you have many of them in which you can then use descriptive names.
*in rust you can have many constrcutors to handle many cases in which an object of a class can be created.This is not supported in js and python as they only allow one constructor and the only way to handle multiple cases is with condition,type checks and default values and the reason its this way is because its dynamially typed and doesnt support method overloading unlike rust which is the opposite.

*in rust,the :: notation is used for namespaces and constructors while the . notation is used for methods.

*in rust,only expressions can end without semicolons if they are the last line of a scope

*Enums in rust are used for holding variant data.It is loosely equivalent to type aliases of interfaces and then a union of many of those except that for that version,it will have to implement a 'kind' property in each of the interfaces before it can decide what type of data it is because unions state what values a variable can accept but it doesnt state what variant of that data it is

^In coding,constants are normally used for making hardcoded values more readable over using arbritary number or string values so it is best practice to use them for any hardcoded value and in js and python,a data structure called an enum is used to hold a set of related constants but in rust,enums are used for creating variants of data.Also in an enum,each variant can have its own type and the amounts of unit data for that particular type.

?OCR technology with a flatbed scanner--converts images to text
?pdf tools--smallpdf and light pdf
^License agreement and privacy policy

^Markdown is better for structured notes but txt files are better for unstructured notes.

^my handwriting needs to be better for ocr tech

^make my own applock

^GCs like that in python also use weak referencing

^godot and unity uses the scene based architecture while roblox and unreal engine uses a component based architecture
*scene based architecture focuses more on scripts to define explicit behaviour
*component based architecture focuses more on triggering events to define behaviour

*There is also ecs too.but it isnt widely used

*A query language allows one to directly talk to a database but orms can prevent sql attacks since they provide abstractions that separate sql queries from your data. 

*abstractions protect you from mistakes that causes security vulnerabilities

*enums are better than unit structs.enums are also more concise than structs incases where you have many similar types.you can even make an enum of structs.this also makes function signatures more concise.You can also write implementation blocks for enums

*a prelude is a collection of items that are automatically included in every rust program

*Rust doesnt directly allow null values but rather it provides an option type which means that a value may be present or absent.Its safer than working directly with a variable thats initially declared as null because it forces you to handle both cases and its enforced at compile time.This is loosely equivalent to a typescript union of an actual type and undefined except that rust enforces handling all cases at compile time while typescript doesnt and rust provides methods that makes it easier to work with than ts.Another thing that option<T> in rust handles better than typesecript,is that a variable thats of this type cant be directly used in arithmetic or any operation until its converted back to a valid type and the rust compiler will never allow it to compile to none.this ensures that we handle the case of a possibly null value before using it.

*The option type is actually an enum.This makes its implementation easier.

*Match case statements can handle both simple values and complex patterns that cant be handled by switch case statements that are mostly used to check for fixed constant values as match cases are made to work with enum data which can hold many data variants.They are also enforced to handle all paterns/cases and as such,they are exhaustive unlike switch case statements.It also doesnt allow data to fallthrough all the cases like the switch case.The switch case has to have a break at each arm to prevent this.The switch case uses the 'default' case to catch all other cases that want caught by the ladder while the match case statement can do likewise by using an arrow function that uses an underscore or a variable name to bind the state of the data to.They both have to be the last case in the ladder

*_ in programming is used for signifying unused variables

*enums in rust cannot only hold a collection of constants but also data variants

*In rust,match case statements can bind to the state of an enum's data given that the enum data variant is made to hold data either as a tuple or a struct.This means that we can use the state of that enum in the function block of an arm.So you can match for patterns like Enum::Variant or bind to a value like Enum::Variant(state).

*In rust,arrow functions can only be used in match case statements while in js,it can be used anywhere

*Dunder methods in python are used to perform operator overloading which is changing the default behaviour of objects when used with built in operators.

*A trait is like a struct in rust except that a trait holds method signatures while structs are for field signatures.A trait is mostly used when multiple structs share methods and there's a need to define a stucture for the methods.It is implemented by impl blocks.

*Rust enforces snake case for function names whereas js and python dont.

*in rust,you can type annotate the type of data next to its variable name using the : notation or directly appended to the value.

*if let statement is like the match statement but for when you are interseted for matching for only one pattern and ignoring the rest.It is less verbose and less boilerplate than the match statement when matching only for a single pattern but you lose the exhaustive checking of match statements.Its essentially syntati sugar over one pattern match case statements.

*There is a difference between a return statement and return expression.A return statement returns a value from a scope to the caller and exits the entire function regardless of how deep the scope is within the function but a return expression returns a value from the scope without exiting the function.The return statement can be anywhere in a scope but a return expression can only be the last line of a scope.The return expression doesnt start with the return statement as it evaluates to a value.

*scope in coding usually refers to the visibility of variables.so scope in rust which can be created with {} allows me to create variables where their duration is only within the scope's definition.they are used to control the lifetime of variables by specifying them within a temporary context.

*lifetimes in rust can be controlled using lifetime annotations.

*There is a difference between a function scope and a block scope.The difference lies in who they give values to.All of these scopes can choose not to give values which will make the function scope a void function,the block scope a statement but they will become expressions if they do give a value.A function scope gives a value to the caller of the function.The caller of the function exists outside of the scope of the function and the function evaluates to a value and returns the value and flow control back to the caller of the function while a block scope gives a value to a variable but the flow control is still in the scope of the function as the variable that collects the value from these scopes exist within the function.This scope does this by just evaluating to a value which gives the value to the variable in the function scope without using the return statement to return flow control and the value to the caller of the function.

*So calling a function hands flow control over to the function but if you also pass variables whose data exist in the heap,you are passing both ownership of the variable and flow control to the function.The function will always return back flow control to the caller even if it isnt explicitly written but for the function to return back ownership of the data,it must be done explicitly.

*if statements,for and while loops tokens are just directives on how and when block scopes should be executed.

*A let-else statement is just a more readable way of returning from an if-let scope.

*statement and an expression.A statement doesnt evaluate to a value and end with a semicolon while an expression evaluates to a value and doesnt end with a semicolon.A statement like the if statement can be made to evaluate to a value and thus becoming an expression.

*enums can hold units,tuples,contants and structs in rust

*Nim has a completely tunable garbage collector meaning that you can disable it completely to switch to manual memory management

*Application level and System level programming languages

*Haskell is pure/declarative functional and one thing about the purely functional paradigm is that code is very predictable and reliable.It also provides a rich set of preludes/built in functions that makes writing many code instructions at an abstract level where you define what you want but you dont bother about how its done unlike the procedural programming paradigm.This means that the code is very minimal.

*procedural,imperative functional,concurrent,declarative functional,object oriented,data query language,markup,style sheet,multi paradigm

*The difference between declarative functional and imperative functional is that imperative functional produces side effects and also focuses more on how the steps are defined while declarative funtional is fully pure and provides a rich set of built in functions that abstracts away from the how.

*in procedural,everything is made of statements meaning that you describe control flow and how a program should achieve a result but in declarative functional,everything is made of expressions meaning that you define what the result should like rather than how it should be done.Declarative functional langauges are just another layer of sweet abstraction.Declarative functional languages also provide a more intuitive and expressive way to write code but it requires a different way of thinking than imperative langauges.

*programming paradigms are different from software design patterns

*python and js support declarative functional styles but are primarily imperative and as such have more of an imperative functional style over declarative

*js doesnt have direct control over memory and resources on the browser for security reasons but rather,it uses provided apis that exposes this functionality for js to use

^disassembler,decompiler,debugger,dll injection,windows api

*memory address and offset.Calculating offset with pointer arithmetic

*external and internal cheat

*system utilities and exploitware with rust

*system level-clis and app level--guis

*infecting a software with high priviledges

*user mode vs kernel mode anti cheat

*malware and cheat signatures

^Lynx js from tik tok
^Rs pack

*As you go down the programming iceberg from high level to low level,the dangers increase as priviledges increase.A software that has more priviledges is more unsafe and vulnerable to one that hasnt.

*A device driver is a software that allows an operating system to communicate with the hardware.It translates high level os commands to low level commands that the hardware can understand.There are kernel,user mode and virtual drivers.An OS acts as the middlema between the hardware and software ensuring that softwares reliably and safely interact with system resources.It uses a kernel driver as its core to directly communicate with the hardware.It is the core of the os and provides an interface for programs to communicate with the hardware through system calls to it.Kernel drivers operate at a high and unrestricted acces level to the hardware so its EXTREMELY DANGEROUS to create a software that operates at this level.Making system calls to the os is a safer way to do things.A user mode driver is a driver that allows the os to communicate with peripheral devices/hardware like a usb or printer in user space meaning that the interaction occurs in a restricted access space where crashes wont affect the entire system.It simplifies development and doesnt crash the entire system.

*Apps work on system calls.A system call is a controlled interface provided by the os that allows programs to communicate with the hardware through it.Code written in rust or c provides prelude methods and functions whereby when used,it gets compiled to machine code that makes system calls to the os for hardware access meaning that programs dont operate at a kernel level which makes it safer.In assembly,you can directly write system calls to the os in code unlike c and rust that provides abstractions over those system calls.

*low/system level languages are mostly compiled while high/application level languages are inetrepreted

*so when they say that low level languages give you direct access to hardware resources,this access is provided by the programming language compiler to directly make system calls to the os that can affect the hardware but its still restricted because the os is another abstraction/layer behind this layer and beyond this layer,is a direct and dangerous level of hardware access.So there are two layers between a program and hardware access and the compilers like c and rust can only give you access to what they have which is the first layer while interpreted languages bring in a third layer infront of these two through their abstractions provided by the runtime environment like the garbage collector meaning that your code doesnt directly make system calls.More layers equates to more safety but lesser control and possibly less performance because of the overhead of going through all these layers.

*rust allows you to write system level programs while also ensuring memory safety,type safety,concurrent safety and explicit error handling for runtime safety.

*system access is abstracted by the programming language and hardware access is abstracted by the operaring system

*The module system

*A crate is the smallest unit of code that is compiled by the rust compiler into an executable.A crate can be a binary crate which compiles to an exe or a lib crate which doesnt get compiled but rather,it is used by binary crates.A package is a collection of many of these crates.There can be many binary crate but only one library crate.A binary crate must have a main function that tells the rust program where to start once its loaded.The root crate is where rust starts to compile your program from.A package has a cargo.toml file that defines how these crates should be built and what dependencies your crates need.A package can have multuple crates by placing them in the bin folder

*A module is crate other than the root.The module keyword is used to declare a module in the module system for visibility and use.It is not used for importing modules.Rust will look for the module in the filesystem through the convention of the module's name.rs in the src file or mod.rs in a folder that has the name of the module or through an inline definition of the module which is supplied as a block scope next to the declaration line and then include that module in the module system.After declaring a module in the module system,you can access the module directly as rust will perform a lookup in the module system to see if the module you are attempting to use is present there.You can use the :: notation to access functions from that module and those functions can be made visible or public to the module system by using the pub keyword infront of the function's signature in the module where its defined.The use keyword allows you to import the namespace of a module directly in a file so that you only type a path once.

*To use a module declared in the module system outside of the main file,you have to use the use crate syntax to bring it into scope.The mod keyword is to declare and import a module while the use crate is used to import the module in a file other than the one that it was declared in.You can only declare modules in the main.rs file and sub modules in other modules.To access modules,you just use their names directly but for submodules,you use the names of the parent modules first before the submodule's name.

*The main.rs and lib.rs files are combined to form the root module because all other modules will fall under an hierarchy lower than these making that the root of the tree.This creates a module system which is similar to the filesytem but for organizing code.

*The main.rs file is the binary crate that acts as the entry point to the entire project structure of your rust program.It must have a main function which serves as the entrypoint to this file and it compiles into an executable file while mod.rs files or module_name.rs files are used to define modules that can be imported in the main.rs file to be part of the module system while the lib.rs file is for making a rust program as a library instead of an executable.

*The path of a module in rust is where a resource/rust script can be found.Paths to a script in rust can be relative or absolute.The absolute path is the full path to the module starting from the root of the module system.If you are using a module in the root crate/main.rs file or where it was declared,the path starts with the name of the module but if you want to use the module in another one other than where it was declared,you have to start the path with the literal,crate to tell rust that the path to the module starts at the root of the module system.

*The use keyword is just to bring a module to scope.Thats it.It isnt used for importing a module.Once a module is declared in the module system,it can be used or called in any other file in the codebase but the path.The pub keyword is used to expose certain functions from the module to be used externally.

*mod keyword,pub keyword,path

*Rust chose to make the functions of modules private by default unless otherwise stated to be public by the pub keyword in order to ensure that the dev knows exactly what code is being called or used throughout the module system

*the as keyword is an alias to prevent conflict

*There is a file-based import and a module based import.

*python and js use a different importing paradigm from rust.In python,you can import an entire module without the module explicitly allowing exports and by default,all the code in a module is public.This is the default behaviour but you can choose to do selective exports in python where only the functionality you want to export is used by other scripts.In js,selective exports is the default behaviour of exports although they also allow module,default export.In both of these paradigms,they are imported according to their paths in the file system and a script cant use a module unless they explicitly import them.But rust is a bit different,a module doesnt have to explicitly imported in a script as it can be used by any script regardless of where it is in the codebase because uses a module system to access resources rather than using the filesystem meaning that as long as the code you want to use elsewhere is defined in the module system,you can access that module's functionality by using its path in the ms to directly access its functionality.All the functions in a module are private unless stated otherwise.This is similar to js where only what you export is visible to other parts of the codebase except that the implementation is slightly different.Once a module is declared in rust,all its code is visible but not accessible while in js,only selective parts of the code is visible.

*Pythons paradigm has implicit visibility control.This is for readability and simplicity

*Levels of abstractions:1.runtime environments--interpreters,browsers,containers,virtual machines,coding environments,database engines. 2.Compiler--compiles to instructions and optionally perfroms safety rules like type and memory safety. 3.direct instructions. 4.OS 5.Hardware

*so modules that are defined in files and not as separate scripts have to be marked as pub in order to make them available to the codebase through the module system unlike modules that are declared in a file but the actual data of that module is in another script like mod.rs.Also making a module public doesnt make its content public.

?Memory mapped files

^Just an idea:defers allocation,skip the lines that uses unallocated strings,log the line and current state of strings that are already allocated to be used in the next execution cycle,deallocate old strings and repeat the execution cycle.Out of order string usage is an edge case for this.

*in rust,the :: notation is for modules and class methods while the dot notation are for instance methods.When structs are declared public,all the fields will be private by default unless otherwise marked a spublic but for enums,once it is marked as piblic,all the variants will be public

*the reason for this design choice is because enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with pub.

*The shortcut provided by the use keyword is only available for the module its used in meaning that if you use the use keyword to bring a module into scope,the shortcut wont be visible to inline module declarations

*We can also use the use keyword to bring the parent module into scope so that we can use all its functions but through the parent.This is to minimize the paths we have to write to use a function in that module and also ensure that we prevent naming conflicts by not bringing in any of its functions into scope.

^There is type alias,import alias and reference alias.

*we can use an import alias to prevent naming conlicts when bringing two imports with the same name into the namespace of the scope.

*The pub use keyword is essentially re-exporting the module.It allows a shortcut defined by the use keyword to publicly available to the codebase.This is useful when you want to create two domains of how programmers will think of your library.People that want to work on it will think of accessing the module system through its individual components but programmers calling the library just want to use the features they want directly without having to know the different level of components to get there.

*You can also use the super keyword to access content relative to the parent

*To include external packages in your codebase,you should write them as a dependency in the cargo.toml file but each codebase has its own module system and the module system of an external codebase cant be included directly in another.so in order to use any of its content in a script in your own codebase,you have to bring the content from the external module system into its scope/namespace.This allows you to work with those items without having to reference the entire crate each time.

*You can also use the wild operator to bring all the content from a  module into scope but itsnot recomended because of possible naming conflicts.

*You can shorten the number of use * lines we have in a script by factoring out the common path and put the subpaths that differ in curly braces.

*The recommended style to use for module files is the module_name.rs styel over the mod.rs style because having multiple mod.rs files can be confusing to navigate about if they are all opened in the editor at the same time.

*low poly,high poly

*Vectors can only hold a single type.

*Rust needs to know the type of data that a vector will hold at compile time or else,it will throw an error.Rust cant infer the type of data a vector will hold if it is constructed with the vector constructor without pushing any element to it after its assignment i.e it isnt initialized with any elements since the contsructor doesnt take any arguments.It  will then require an explicit type annotation but most of the time,vectors will be initialized with at least a value for rust to infer the type so the annotation will be rarely needed and rust also provides the vec! macro that automatically creates a vector along with its type annotation for us.

*get returns an option object which can be handled for out of bounds index while indexing will panic.Pick your pick based on the scenario

*The push vector method in rust takes a mutable reference to the instance of the class.This will allow the method to modify the vector without taking ownership and since there can only be one mutable ref at a time,it ensures safety to ensure that only one mutable operation is done at a time

*Looping over a vector in rust requires you to use a mutable ref to that vector.this is to ensure that you dont modify the vector while looping over it as there can only be one mutable ref in a scope.

*An immutable ref invalidates a mutable one but not vice versa.This is because when you create an immutable ref after a mutable one,rust takes the mut one out of scope as it believes that its job is done

*In rust,when reading a value from a vector through indexing,you can choose to access the data by an immutable ref which will allow you to read it or you can copy the data to that variable by directly assigning it to the data at that index as long as the data implements the copy trait like integers or chars.For types that do not implement Copy (like String or Vec<T>), assigning the value will move the data, which means you cannot use the original value after the assignment unless it's wrapped in a reference.Using the immutable ref means that you cant read the array before any mutable refs to that array is made so that later in the program,you dont read any unexpected data but since immutable refs can invalidate mutable ones,you can read the data using an immutable ref after modifying it with a mutable one as it is in push.

*a string object in rust is a wrapper around vectors.u can either use the to string method on the str literal type or the string object constructor directly

*The push_str or push (for a single character) method of a string object is used for copying the content of a string slice or a string literal to the end of a string object by using a reference to it to access its data.Concatenation with the + operator is used for adding a string object to another string object and assigning it to a new variable.It does this by moving or transferring ownership of the left operand string object to the new variable so that it remains memory efficient by not copying the data and for the right operands,it requires you to pass them as immutable references since the data to be appended to a string object must be a reference to a string literal data so that it can copy its contents to the end of the string.But since a &String ref is not the same as a &str ref as the former is a reference to data in the heap,rust does a deref coercion where it turns the ref to &str so that it matches the function definition and the reason why &str is used over &String when appending data is because its easier to read and work with so its purely out of rust preferences.This always ensures that the right operands continue to own their data.The reason why the content of a &str ref is copied instead of directly appending the ref to the string object is because a string object has its data stored in the heap and the variable that references to that data must own all of its data and not having to borrow data from another place and the reason why the right operand string objects are not just moved into the new variable is so that those string objects still retain ownership of their data for use later in the codebase.

*But why not just move all the string objects in concatenation for memory efficeiency why is it the left operand that gets moved but not the right.Who is to say its the right we will need to preserve ownership to reuse later over the one on the left?The reason is because of the components that makes up string concatenation.We have the primary data and secondary/source data.The primary data being the left operand is the one to be modified so it makes sense to move the data to variables rather than copying it every single time it needs to be modified while the ones on the right are the secondary meaning that its a source of data that is to be used to modify one to many string objects and as such,it serves as the source data.Because the source data might be reused across the codebase to modify various string objects,it makes more sense to copy them over rather than moving it which will make it difficult to reuse later

*Immutability over efficiency

*format! is like formatting in println but it returns the data to a variable rsther than printing it to the standard output.It doesnt take ownership of any of its parameters but rather copies the content of each string object.This alternative to direct concatenation makes it less memory efficient than concatenation but it is less cumbersome and allows for flexibility as you can opt into the method you wish for your strings to be handled when bringing them together.If you pass a borrowed type like &str,it takes a ref to it.The format method is more time efficient because for concatenation,the string might be reallocated to a new address on the heap if the space allocated to the string isnt big enough to hold the concatenated data meaning that there might be a new allocation for each concatenation which is more time consuming while the format macro doesnt append data to an existing string but rather,it creates a new string which means that there will only be one allocation and it will be big enough to hold its entire content but might take more space since it copies all of its operands in the case of string object.After copying the string data  over to a new memory in the heap after each reallocation that might happen during string concatenation,rust will automatically drop the old memory to prevent memory leaks and update the memory address that the variable points to to prevent dangling references

*strings in rust dont support indexing like in vectors

*The stack is for integers and floats that are fixed i.e they dont vary in size and known at compile time and function call frames like local variables.The heap is for data that might change over time and is not known at compile time.Data in the heap can grow and shrink over time.Stack allocation is done at compile time while heap allocation is done at runtime so its dynamic.References to data in the heap are stored in the stack but the data itself is in the heap.Strings go to the heap because they are can change throughout the program.Strings in python and js are stored in the heap because they are variable in size which will require the dynamic memory allocation of the heap but they are immutable meaning that any apparent modification to the string actually creates a copy of the string and it means that strings passed to functions are passed by value.This is to ensure preditability and safety by avoiding side effects over memory efficiency but in case of mem efficiency,you can use a join method which takes all the strings from an array to create a string which means it only copies once since arrays are mutable and thus,pushing to an array doesnt copy the array while in rust,the String object is directly mutable and is passed to functions by reference meaning that if you pass it as an mutable ref to the function,the function can create side effects on the string.In rust,you can choose where the string data will go by either using a ref to a string in the static storage which is fixed in size and doesnt copy the data but rather borrows it or by using a string object which allocates its data in the heap.so the final string from format is more time efficient but less memory efficient than concatenation although concatenation can lead to temporary memory spikes during the reallocating process.Format is preferred when working with larger strings

*The &str is a borrowed type so assignments to it is by reference while The String type is an owned type so assignments to it transfers ownership

*There is assignment by copy,borrows it and by taking ownership

*A slice must be a reference because the value cannot be known at compile time and it shouldnt own but borrow the data since its used for read-only operations.Since they borrow data,any changes to the original string will be reflected in the slice unless a modification is done to it that requires a reallocation which will not reflect the changes in the slice as the slice still reflects the old memory address and not the new one.The reason why slices dont change the address they point to because they dont own the data,they are just referencing the data for borrowing.

*String characters can be represented as Unicode or Ascii.Both of them are converted to their byte representation when storing their data in a string since a string in rust is a vector of raw bytes.Since they are stored as a sequence of bytes,indexing is a direct access to a byte and not a character.When indexing for bytes that hold for ascii character data,rust implicitly converts it back to its character representation since an ascii character will always correspond to 1 byte but if you access a byte from a unicode character,it will panic and throw an error because in unicode,no single byte corresponds to a valid character as a unicode character is made up of more than 1 byte but rather,it takes a variable length because and depending on the encoding.Common unicode characters are 2 bytes while more complex ones like emojis are 4.Although,if rust allowed the indexing feature even for unicode characters,it will just return the bytes directly if it cant convert it to a valid character because rust will have to return some data but doing this will create unexpected behaviour later in the code if not careful.So rust prvents errors like this from ever happening by totally removing the indexing feature.

*Slicing is a safer way because it guarantees that the slice will correspond to a valid character given that the slice is valid.Rust will then convert it back to its character whether unicode or ascii.But slicing can lead to runtime errors if they are invalid.Indexing makes it impossible to read unicode characters from a string but slicing allows it but you have to care about character boundaries.

*Because slicing can be invalid,rust provides another method of safely accessing the characters of a string.By using the chars method which will iterate through the string and stack up the bytes till they create a valid character called a code unit and return each code unit to a new array which is closer to how other programming languages like js choose to expose strings to the programmer;as a sequence of characters.But you cannot index into that because it isnt literally an array so you can only utilize it by looping over it.

*Rust uses utf-8 while js use utf-16.Utf-8 can take both ascii and unicode characters.Utf-8 is a variable length encoding which can manage space flexibly but can create complications as it is in rust while utf-16 is a consistent character encoding.For example,utf-8 encodes ascii characters as one byte while utf-16 encodes all characters into at least 2 bytes allowing a wider range of characters to take up consistent space but less common characters like emojis can take up to four bytes in both algorithm.Utf-8 is termed that way because characters can take at least one byte or 8bits while utf-16 takes at least 2bytes.The reason why utf-16 is consistent because many values can be encoded in 2 bytes.This consistent space allows js to represent arrays as a sequence of characters which abstracts from the complexities of representing it as an sequence of bytes as it is in rust so indexing in js is by character offset or code unit.It allows for a character oriented access over a byte oriented access to strings like rust.In other words,many programmers wont have known about any of this if they didnt learn languages like rust that didnt choose to spoil them with sweet abstractions but at some point,you'll care about space.

*Utf-8 is more memory efficient but more complicated as you have to care about character boundaries.If you return a byte thats not valid,youll get the byte and not the character which will lead to unexpected behaviour later while utf-16 is less complicated but can consume more memory for the same characters.So js uses a code unit representation through utf-16 while Rust uses a byte representation because they use utf-8 that encodes the data directly in bytes due to its memory efficiency.Its a system programming laguage so it has to deliver performance.Python uses utf-8 only when storing or sharing the data and actually holds the data in a sequence of unicode points internally which is an intermediate rep of unicode character data.This allows for simplicity and abstractions like js but memory efficiency when sending or storing the data like rust.

*A code unit is the collection of bytes that makes a valid unicode character while a code point is a unique number assigned to each character in the unicode format which gets converted to code units

*C++ like rust use utf-8 but allows for direct indexing but this is only safe when the characters are ascii.So you wont have to worry about boundaries and encoding until you start using unicode characters that span more than one byte unlike rust where it prevents you from ever indexing into a string so you have to care about this from the first time you want to access specific characters from a string upfront.Apart from this,the level of abstraction and control are the same.In both of them,if you need to safely access unicode characters from a string,you loop over a sequence that tokenizes the bytes into code units except that in rust,its provided in the standard library while in c++,its provided by user made libraries

*in these system languages,you will be forced to learn about low level details even if you dont want to as long as you want to use these languages because you will literally not go anywhere using them without attempting to understand the details that you will normally wont care or procrastinate to learn if you are using python and js.

*The char method returns an iterator of the unicode units that makes up a string.

*There are two ways to create a sequences;a random access sequence or an iterator sequence.A random access sequence like a vector will require an allocation on the heap that will cost memory and reduce time performance because of allocation time but once complete,it becomes very fast for lookup operations while an iterator doesnt take any data from the heap because the data is yielded value by value as the code runs rather than storing it in a collection that will require allocation and thus,it optimizes space performance but its slower for lookups.An iterator is a function that yields values and retains state of where it is in the sequence.Yielding means that it will return the current value and hand over execution till its called again.

*Char and slicing are both different ways of accessing unicode units from a string except that char is safer but requires you to loop over the iterator every time which might be less accessible when trying to access many characters as you have to store all of them in a vector first which will bring allocation costs on memory and speed while slicing allows you to directly access the data but requires upfront knowledge of the right character boundaries.They both conserve memory since they both dont take memory as slices just borrow the data while char iterates over the data.But slicing is more accessible for accessing many characters and its faster since it doesnt loop over anything as its direct access and it will even conserve more space if multiple-character accessibility is needed So these two methods are a trade-off between (speed and easier multi-character accessibility) or (safety and lack of prior boundary knowledge).Its better and recommended to start with chars for safety as it aligns with rust principles but use slicing for performance

*The keys and values of a hashmap must be of the same type.

*A vector is basically a heap allocated array

*When treating an option object from a vector or hashmap,we can return a referece or a copy using the .copied method.If we don't want the value of returned to the variable to reflect any further changes to the vector or hashmap in the program but it will increase memory consumption although insignificant in the case of small integers,chars or booleans but we can choose to use a ref and not a copy if we want to opt for more memory savings and its ok or needed for it to reflect any changes to the collection in the program.

*if the collection doesnt get updated in a way that affects previous values like push or insert operations,using a ref is better since it saves that extra 4 bytes or more and will still provide the same output as copying it.

*You can use the .copied method on anything to copy data thats on the heap.

^Borrowing it,owning it,copying it are the different ways to do assignments.A copy becomes independent of the source.The owner becomes the source while a borrow becomes dependent on the source

*When looping over a collection in rust,we should use a ref to ensure that the loop doesnt own the data.An immutable one for read and a mutable one for write operations.

*For keys and values that their data are on the stack,the heap owns the data but for data on the stack,the map copies its data

*I cant pass references to a temporary heap allocated data like string objects used directly on the fly without an assignment.This is because it will lead to a dangling reference as the data will be dropped immediately after use because it doesnt have an owner.Rust prevents this from happening but not c++ where it will lead to undefined behaviour.You can work around this by lifting the temporary value to a variable that will take ownership of it and the program will execute safely without creating a dangling reference but if it were an integer,there is no need to lift it as its in stack memory and will be copied if needed.

*The ownership model is the solution to all these mem management pitfalls but rust requires you to figure out how to work around it to still execute what you want but in a memory safe manner like through lifting temporaries which one will have to discover on his own making the programmer fully responsible for the memory usage of his program

*You cannot have a mutable ref after an immutable one to prevent undefined behaviour in parts of the code that wants to read the same value and accidental modifications to the value before its used.

*You cannot borrow a value mutably if the owner isnt declared to be mutable.This is to ensure that any data mutations is intentional and not accidental.Its a double check.Thats why variables are immutable by default.This is different from python and js where variables are mutable by default which can cause unintended side effects like when arrays are passed to functions.New devs wont know that they are passed by ref and can cause accidental modifications while in rust,even a vector thats passed by ref still requires permission before its modified.

*Hashmaps must have unique keys so inserting a value with an existing key overwrites the old one

*rust requires that you either have one mutable borrow or multiple immutable borrows but not at the same time.you can only create immutable refs after a mutable one which will invalidate the mutable one.The borrow checker is like a permission controller;immutable refs have read-only access while mutable ones have read and write access.

*integers,booleans and chars are stored in the heap only when they are inside collections which are stored in the heap.So using those values requires a ref.The vector structure itself is stored in the stack because the pointers go to the stack but the intger data goes to the heap.So you can control the allocation of the integer data to either the stack or on the heap

*mutability and immutability is independent of whether the data is stored in the stack or heap.the reason mutable integers go to the heap is because its allocation is fixed regardless of how the data is mutated which means that whether data goes to the stack or heap isnt about whether it will be changed later but whether rust knows that the allocated space for the data wont change after compile time.Integers have a predictable memory allocation according to their type regardless of how large the value is.The same for character and boolean which have a predictable allocation of one byte so all of these go to the stack.But we can never predict the space that a vector or a string will take and as such,they go to the heap.

*You can read the value that a reference holds by directly using it but if you want to modify the data that mutable references borrow,you have to use the dereference operator *.This is to ensure that you are intentional about using the mutable reference to modify the value at a particular part of the codebase when you mistakenly meant to use it for reading at that point.

*Assigning a variable that has stack allocated data to another variable copies the data unlike for heap allocated data like string which transfers ownership.If the variable holding the integer data doesnt change,copying it to another variable will be memory inefficient so using an immutable ref to another variable is better.But there are some complexities about opting for immutable refs because of memory efficiency;

*There are three ways to modify the data stored in a variable:by overshadowing/redeclaring,by mutating it and by reassignment.Modifying a variable by directly assigning the variable to a different value after its initialiation and declarartion as mutable is modifying by reassignment.You cannot modify a variable like this after it has been borrowed like incrementing a variable after it has been borrowed by a ref.This is because it will hold its newly assigned data in a different location whether on the stack or on the heap and making the older one invalid.This will make the borrowed variable a dangling reference because it no longer references a valid memory.So there are three ways around this;You either perform the reassignment before borrowing it,2.you use a mutable reference to change it because it directly modifes the data at that address without changing its location unlike reassignment or 3.overshadowing the variable.This is because overshadowing is pretty interesting in how it works.Overshadowing redeclares a variable not just reassign it.It allocates data in a different address but it doesnt invalidate the old one because it declares the variable as if it were a new one entirely meaning that any borrows to it before it was overshadowed is still valid.The preferred approach is to use mutable refs unless you dont want mutability where you will then use overshadowing another way to prevent all of this as a whole so that you can still reassign to modify the variable after its been used by another variable,is to copy the data over to the other variable and not accessing it by reference.

*order of priviledge:read-only,read and write,ownership

*so one can start with rust if they dont want to shoot themselves in the foot but they will learn about mem management by working with the compiler when it throws them errors while starting with c++ means you are starting out writing buggy software then coming to rust for safety later.Rust is better for beginners,it forms good habits early unlike c++ where you suffer enough from the bad ones and then learn why the good habits exist.This is the nature of Rust to C++ and C++ to rust transitions.

*panics and fallbacks are different ways of handling unexpexted behaviour.A panic will make the program to abort while a fallback will give the program a way of handling the situation.A fallback is more user friendly while a panic is necessary from stopping something critical from happening to the program.A fallback creates fault tolerant code that happens under expected conditions while panics should happen when under any normal circumstance,should something happen else allowing it to execute can lead to critical damage.The get() method fallbacks while indexing panics in vectors and unwrap panics while unwrap_or() fallbacks.

*entry doesnt overwrite.It only writes a value to a key if the key doesnt exist and returns a mutabl ref to it to the map.

*another thing is that panics shouldnt give stack traces as error outputs because every piece of this data can be used by attackers to know where in the codebase and perform variations of what they did to understand how the code responds to errors and over time,get full information about the error handling checks of the program and try how to crack their way around it by creating unchecked circumstances but having writing the program in rust will slow this down since memory and race condition vulnerabilities are removed by rust

*Any information thats meant to be used only development that gets exposed to production environments is called a leak.A leak in itself doesnt mean an instant defeat to the program but it can expose enough information that hackers can use to craft sophisticated attacks.Using environment configuration files like .env files with a tool like Git leaks can help prevent this and anonymizing logs can prevent this isssue.

*rust also ensures that you pay more attention to your code.

*The or_insert method returns a mutable ref to the value of a specified key in a map.If the key exists,it returns a mutable ref to the value as it is else,it inserts the new value and return an immutable ref to that

*attacks by memory corruption,by unsanitized inputs,race conditions,program intel

*Inconsistent outputs

*so a hash table is a function,an array and an optional linked list layer.The function takes a key and uses a function called the hash function to generate an index to the underlying array.The underlying array holds the data.But in the case of collisions which is when two keys maps to the same index,a method called chaining where the value at that index in the array is a pointer to a linked list where series of k-v pairs occur and secret key is like salting against rainbow tables where even if they get the input right,it will never collide with another key.It is used by the siphash function which rust implememens.It may not be the fastest but rust prioritizes security over performance.Hackers can take advantage of collisions by creating a vast amount of inputs that collides with others which creates multiple linked lists that can crash the program and slow it down for other users leading to Dos attacks.If they create keys that collide with legit data,they can use those keys to overwrite that data.Because of the way collisions are handled,keys dont get access to the same data even if they collide but existing entries can be overwritten and attackers can exploit dos attacks

*Python and js use general purpose hashing for typical use cases and overall good perfromance but its not highly collision resistant like siphash that rust uses.

*An implementation is a variation of a programming language in terms of its compiler or interpreter.It represents a different way of writing the compiler or interpreter for that language, often with unique optimizations, features, or behaviors.Js has different implementations based on runtime environments like node js and the browser engine like v8,spider monkey.Python has cython,pypy etc.Different implementations have various optimizations.

^Pypy is a jit compiler for python.its just like java rather an interpreter like cython.Old js usef an interpreter but modern engines now use a jit compiler.Its like C# and java.cython is a transpiler of python that converts python to c

^In linux,bash is the go to programming language because of its command-oreiented nature.it is not like other programming languages for building but rather for utilizing the usage of many clis.You write prompts or commands not code

^Compiler,Interpreter,Transpiler,Jit compiler

^Web assembly is a compilation target.

*A server and a database is just like your os to the file system

*Jit compilers compiles code to bytecode which is a platform independent and intermediary format that can be compiled later to a specific platform

^Api client,text interface,command interface,graphical interface
*We use api clients to communicate with js servers

*Commands are like queries.They are declarative and focus on getting data

*You can choose panic and clean up or panic and abort.Clean up will step up through the code from where it panicked and free any memory that was used by the function while abort skips this.

*Rust libraries can panic in response to code in our own codebase

*Accessing a vector beyond its index will panic but in c,it will read past the memory block of the array leading to a buffer overread which is a vulnerability.The reason why rust panics here is so that it prevents this vulnerability from continuing running

*You can allow backtraces.A backtrace is a display of the series of function calls that lead to the error.

^result and option enum

*Enum destructuring is taking out the encapsulated data from an enum variant.You can do this by pattern matching statements like match,if let and let else

^Array unpacking,object destructuring and enum destructuring

*if let and let else are when you only care about one pattern like option but match is better for patterns that returns the Result type

*You can match an enum against a pattern and choose to destructure it

*Pattern matching can be a bit verbose and as such,rust provide methods that shorten it;unwrap--which destructures the enum variant and panics if it isnt a success and expect which is the same as unwrap but allows us to control the panic message.The message in expect shouldnt be why it failed but why what assumption was wrong that made it to fail by convention

*throw/assert and catch
*Result type,panic,validation and expect

*Rust chooses to propagate errors to the caller

*the code should panic when assumptions that should always hold true have been violated and executing further can be insecure and harmful.Panic is also useful when an external library is bugged somewhere that your codebase cant fix so it panics as it isnt under the control of one's codebase

*The standard library in rust panics when one tries to operate on invalid data because of safety vulnerabilities and returns a result for other errors.

*There is a difference between recovering and fixing.Recovering means that even if there's an erro,the caller can go around it but when it panics,it can only proceed further when it fixes the way it calls it.A function can also panic if its contract as defined in its signature has been violated.

todo:Read rust chapter 9.2

*validation by parsing or by a class constructor

*A way of validating user input is by using parsing which will parse the input to the correct type and return a result which can be an error if the parsing failed

*Repeating many checks for data validation becomes cumbersome across many functions.We can instead lift the validation logic to a type that always guarantees that the data that we are working with is validated.We do this by using a struct that encapsulates the data we want to validate in a private field so that the caller cant directly modify this value.The constructor will validate the input and return an instance of the class if its valid or panic if its invalid.The data can then be accessed by a getter since we made the field private.This is more readable and safe

*so there are two different paradigms in handling runtime errors;the error as value and error as an exception.Error as an exception is aimed for simplicity and primarily for user experience.Every runtime error that uses this paradigm stops the program as it throws the exception not because of a possible harm or vulnerability but because the programming language doesnt know what to do next and as such,it has to be caught explicitly by the program to guide the language on what to do or the programmer fixes his code.The programmer can fix his code if it isnt expected or catch it if its expected and can also throw an error explictly when an operation is meant to fail for some reason but the thing here is that every error can be caught allowing the program to proceed using the codebase with a possibility of mitigating security while Errors as value is a different approach.This paradigm goes for security and predicatbility.Errors here are explicit.Under normal circumstances,rust and the codebase wont throw an error that stops the program to stop at runtime but rather,any possibility of an error failing has to be explicitly stated by the programmer and the error is handed over to the user of the codebase to decide how to recover from it but when the program attempts to do something that violates normal conditions,rust or the codebase will throw an error that cant be recovered or done around as it is in exceptions where every exception can be caught.This is not because rust or the codebase doesnt know what to do but because if it proceeds,it may lead to severe damage to data or the user of the codebase.The reason why js and python go for exception is because of its use for developing user friendly applications while rust goes for error as value because being a system level language means that it has to be secure when using the resources it has priviledges to

*Variable data that goes to the stack must be written at the signature

*so are tuples fixed at compile time because its not possible to create a data structure that has different allocations for each element on the heap.So in vectors when i say vec i32,it tells rust that whenever i want to modify this vector,it only allocates and deallocates 4 bytes but if it were to hold multiple types,it will have variable allocations and rust cant predict the best allocation for the element that will be inserted into the array and if it did,it may lead to wasted memory.But js and python allow arrrays of different types but this is because they have runtime overhead that will come at the cost of performance which rust cant afford and even at that,in js,i cant create a typed array that has variable allocations like one is int32 and the other is int8 at runtime.So the overhead that js and python do for an array of different element types at runtime is resolving their types and not predicting variable allocations

*Any predictable knowledge must be given at compile time.

*Tuples are fixed at compile time because its not possible to create a data structure that has different allocations for each element on the heap.So in vectors when i say vec i32,it tells rust that whenever i want to modify this vector,it only allocates and deallocates 4 bytes but if it were to hold multiple types,it will have variable allocations and rust cant predict the best allocation for the element that will be inserted into the array and if it did,it may lead to wasted memory.But js and python allow arrrays of different types but this is because they have runtime overhead that will come at the cost of performance which rust cant afford and even at that,in js,i cant create a typed array that has variable allocations like one is int32 and the other is int8 at runtime.So the overhead that js and python do for an array of different element types at runtime is resolving their types and not predicting variable allocations

*Runtime information cannot be known ahead of time.

*Dynamic allocation is done at runtime but the individual elements that makes up the collection must have a fixed allocation size known at compile time

*In c,c++ and zig,i can control the allocated space at runtime using condition checks except that zig allocators are safer and the intuitive way of using the language while c and c++ offer this at the cost of safety while rust doesnt give me control over the allocator so despite that it does dynamic allocation at runtime for shrinkable types like vector,the space to be allocated for each of the elements in the collection must be known by rust at compile time.Rust does this to ensure safety.

*C,C++,Zig,Rust,Nim

*so ? is a shorthand like unwrap.They both check for variants,destructure them and return it to a variable except that when unwrap encounters an error,it panics,for unwrap_or it recovers by returning a default value and for the ? operator,it propagates the error to the caller.? is good for propagation,unwrap is good when you are certain that an error shouldnt occur and unwrap_or is good for recovering from the error by providing a default value to fallback to.

*Ways of matching and destructuring:match case block,if let block,let else block.

*The structure of the struct and enum itself is stored on the stack as pointers but the actual allocation of the data varies on the type.If the data is of a fixed allocation,it is stored directly with the struct or enum but if its dynamic like string or vector,its stored on the heap and the field or variant is a pointer to its location in memory.

*i32 for example,is stored on the stack but if its in a collection like vector or hashmap,it goes to the heap in a contiguous block but the actual vec structure is stored on the stack and it becomes a pointer to the first element.

*So for vectors,structs and enums,the structure of it is on the stack but the data itself will be stored on the heap if its a vector or on the stack or heap if its a struct or enum. data can go to the stack or heap depending on whether its allocation is known ahead of time through a type annotation that has information of allocated space but vecs and hashmaps of anything moves data to the heap.

*so with i32 in a vector,i can tell rust to only allocate 4 bytes for each data in the heap.so even if its 0 when i allocate 8 bytes,it will always take 8bytes of space regardless of whether the value fully uses the space.So type annotations can help me to control allocated spaces

*An enum will take the size of its largest variant that means that even if a variant takes 1 byte of data,the entire enum instance itself will still take 8 bytes assuming that 8 bytes is the largest variant.This is a design choice because rust doesnt allow variable allocations for safety and predictability.Rust ensures that all allocation information is known at compile time.

^Ill create an allocator that allocates the smallest space that can contain a particular variable at runtime but it means that the variable itself cant be modified after it has been pushed because it might be bigger than its allocated space after modification so it will be immutable but the collection itself can still be used to add or remove elements.If there is any needed to modify an element after,it will lead to a reallocation where the allocator will then calculate the smallest space that can hold it and then take it to the vector by replacing the one at the original index with it although it will lead to consnat reallocations on every modification so each element will be immutable by default.This is because the allocation itself is determined by its initial value.i want to use this to create an optimized vector since all the elements of a vector must take the largest allocated space for any of the elements which might lead to unused space from other variables

*Rust allocates more space for strings than required to prevent constant reallocations

* strings themselves also have predicatble allocations.its actually a vector of 1 byte per element.So strings have the perception of taking the smallest amount of size required for the string seeming like variable size allocation but its actually a predictable allocation.Its true that strings and vectors themselves have variable allocations but the elements in them have predictable allocations.

*the problem about predictable memory allocations is that they must be true for all elements in the collection which is too general of an assumption that may lead to unused memory by some elements thus causing fragmentation

^so this is the normal vector:Vec<i32> = vec![12345, 6789, 1000000, 2, 56, 789, 12, 345]; taking up 32 bytes but mine:Vec<i8>[12,34,-5,67,-89,10,-105,-2,-56,78,-9,12,34,-5].the 105 reads 5 zeros in this chunk.the positive number to the negative number concatenated together after removing the neg sign reassembles the original element separately from others.this will take 14 bytes.

*so the rule is simple:chunk the integers in the vectors into two digits.the last one or two digit chunk that's part of the integer will have the - sign to indicate that its the last chunk so when it needs to get reassembled,all the elements from a positive chunk down to the neg one will be concatenated to give the original integer.the - will not be involved in the concatenation as its just an indicator that will be ignored during the concatenation process.To represent something like 100000,where zeros will be a chunk but will lose info as it will just be 0,it will use 200s to rep the count of zeros in this chunk by ignoring the leading two and reading the values after.This means that at most,it can rep 55 zeros which is big enough for many numbers.100s will be used to indicate that a chunk is negative.this will always be the starting chunk of an intger if its negative.it will ignore the leading 1 and count the remaining two digits as the chunk so 199 will be read as -99.The choice of purpose for the 100s and 200s is so that a large range of zeros can be rep while also allowing neg integer chunks of any size to be a valid i8 type as a chunk wont exceed two digits.The 100s can have the neg sign to indicate that its the last chunk for that integer.216 no longer rep 16 zeros but 6.the offset is 10 since 201-209 is used for sparse zeros 

*this algorithm makes the individual elements of a vector to take the smallest amount of space it can take rather than every element taking the space of the largest integer that will not be utilized by all elements.A direct solution would have been to create an allocator that does variable sized allocations for each element in a vector but that will be complex.a workaround is the algorithm i made.It gives the perception of a variable sized allocator but it actually just takes advantage of the problem to create more accurate predictable allocations.it manipulates the problem to become the solution.thats a workaround rather than a direct solution to the problem like a new allocatorA vec<i32>[123456,90,12000] will have 12 bytes because rust will make each element take the size of the largest integer for predictable allocations but only the first is 4,the second is 1 and the third is 2.So my algorithm rerepresents the vector in a way that ensures that the element doesnt take more than required.My algorithm will turn this vector to: vec<i8>[12,34,-56,-90,12,-213].This array then takes 6 bytes.which is what it would have been if rust did variable based allocation.The first three chunks 12,34,-56 is 3 bytes.123456 can actually be rep in 3 bytes but because rust doesnt have i24,it rounds to 4 bytes but my algorithm makes it to only take 3 bytes.it reads from the first chunk and concatenates it with the adjacent one till it hits a chunk with a neg sign which indicates that that chunk is the last one for this number.the fourth chunk -90 is for the second element 90 which only takes one byte and 12000 is 12,-213 which reps 12000 in two bytes.If you use the vector from this algorithm it will seem like a normal vector that somehow uses some variable allocator but really,it represents the vector in a way that leads to more accurate space savings.its still uses an i8 so it is actually still using a predictable allocator

*so a workaround is just a reinterpretation of the problem.It doesnt directly solve it but rather,it manipulates the limitations cleverly to become the solution which doesnt require changes to the underlying system .While a direct solution will require a new different approach to the underlying system which is more complex but leverages standard approaches that guide its implementation.Since the workaround doesnt actually change the internals,it leads to code thats easier to understand and doesnt require any new integrations.The workaround is a clever approach while the direct is a standard approach but both can achieve the same effect like my algorithm over using an actual variable allocator.

*so in rust,the constructor explicitly returns an instance and its the instance methods that have access to self implicitly but in other programming langs like js and python,the constructor doesnt explicitly return an instance of the class but rather uses self to set parameters that belongs to that instance

*match case,if let,let else,while let

*its only &str slices that i can safely slice into

*If you attempt to read past an array,it will lead to a buffer overread and if you attempt to store a larger integer than what was allocated,it will wrap around the value which will lead to heavy data loss

*turbofish syntax is for supllying type annotation to functions that accepts them as generics

*so usize is just a platform dependent unsigned integer.whats so different about this from u32 or u64.This ensures it can address the maximum possible size of a collection on the given platform.

*all slices must be a ref because the size cant be known at compile time.A slice is just a view into a portion of an array or vector.

*"" is for string literal while '' is for a character

*References to temporaries are only valid in cases where the function copies the content from the reference and not borrow it like that in concatenation

*To convert a string to a number,we use the parse method and for vice versa,we use the to string method.the parse method returns an option object.

*generics are resolved at compile time

*By using rust ownership system,you can create a function with an empty body and a signature that takes ownership of any variable passed to it to directly control deallocations.although this isnt a common practice and its still safe,its recommended to allow rust control the deallocations for you.

*data on the stack can never escape its scope.it can only be copied to another while heap data can live beyond its scope by transferring ownership to data to another scope.This means that the lifetime of heap data can be extended while stack data cant.Box allows us to make stack data go to the heap for extending its lifetime

*Box makes it easier to manage the lifetime of any data by making it have ownership semantics which is easier to understand than returning copies even if its at the end of the scope where it will be immediately dropped

*Rc allows to create multiple owners ensuring that the data is only dropped after all the owners have gone out of scope.This is good for shared data

*unsafe is a block of rust where rust allows the programmer to use raw pointers and the rust compiler wont check if its safe because there are no guarantees or rules.Its like proceed if you have acknowledged the consequences.

*Any literal used in code without being assigned to a variable like in an if statement will be dropped after that line.does this temporary data go to the register

*smart pointers are best for dynamic sized types,complex lifetimes and shared ownerships

*The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the length of a vector, which specifies the number of actual elements within the vector. If a vector’s length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.

*in order programming languages,if statemenst cant return values outside of its body to a variable directly but only to outside of a function like python and js and thats why there is a ? operator while rust allows any scope to return values directly from itself to a variable.this allows for explicitness

*I cant typeannotate in function calls and loops only in signatures

*Literals can also have type info appended to the end of their value in the case of integers

*In rust,i cant directly access instance methods like i can in js because in js,a barebones instance is implicitly created first before my constructor uses it to set values which also allows the constructor to call instance methods directly but in rust,constructors can either create an empty instance,modify it and return it or they can directly return an instance of the struct in the end of their definition.For the first option,i have to create the self instance object first before accessing instance methods and then return that same object.For the second method,its more explicit but i wont be able to access instance methods or getters in the constrcutor.if i made an instance explicitly but returned a new struct instance at the end of the constructor it wont be the same object.So there is no valid way of combinin g the two options in rust

*in rust,objects are actually instances of structs which means that they belong to the struct they were instantiated from.The are direct representation of the struct with concrete values.While typescript objects dont belong to their interfaces as they are literals/plain objects and only conform to the contract of the interface.They dont belong to anything unless you do so with classes.An interface cant have concrete methods defined on it meaning that an object that coforms to the interface must provide their own implementation of the method in order to use it while in rust,structs provide concrete implementations of methods ahead of time for objects instantiated with them

*Structs and classes are similar but struct objects dont have to use the struct constructor.They can directly assign themselves as instances to the struct using the struct literal while classes require that the objects must be created from the constructor and structs dont support inheritance and polymorphism

*the new keyword tells ts to create an instance and implicitly pass it to the constrcutor

^Rust doesnt have null or undefined,it has option.it doesnt have void but rather,it has the unit struct() and it doesnt have the never type but rather the Result type.

*A method that doesnt have self is a class method but if it has,its an instance method.Instance methods are the only time when rust implicitly passes self to the method.its that what the dot notation is for.

*Rust has the following notations; the : notation,the :: notation,. notation,<> notation,::<> notation and the -> notation.If i want to specify type annotations,i use the : notation.For instance mtehods,its the . notation,for accessing anything from the module system and struct methods,its the :: notation, if i want to specify that a function takes generics and has lifetime information,i have to do it in its signature using the <> notation.if i want to call that same function and specify the type,ill use turbofish notation which is ::<>.If i create a struct and i want to type annotate the specific generic,its the the struct<> notation.To specify the return type of a function,we use the -> notation.In rust,i cant do methods on a generic directly without specifying the traits it implements.i can do that using the : notation infront of the generic or the where statement.

*if a function makes minor modifications to a vector,its better to pass it a mutable ref to the function.if it significantly modifies it,its best to pass ownership of the vector to it and the function can return it back once its done using it.

*The extend method copies the elements of right operand vector to another.append moves them  while + copies both vector operands to produce a new vector.Im sure the best here is append cuz its memory efficient

*Copying creates reallocations while owning only adds a ref to that vector in memory and invalidates the previous vector from accessing it. and instance methods that takes immutable refs to self only intend to use methods and read values from it while those that a mutable ref to self are those that use its setters

*so the clear method in rust doesnt remove the capacity meaning that if one wants to push to the vector after clearing it,there wont be any reallocations till it reaches the size of th evector before it was cleared while reassigning it to an empty vector refreshes the capacity meaning that there will be constant reallocations.clear is better if its going to be reused again very soon while reassigning it is better if its going to remain empty long term so that there is no wasted space

*Use shadowing when you want to transform a value without modifying the original and want to limit the scope of the new variable.use mutation when you need to change the state of a variable throughout its lifetime

*Lsb and Rsb in bitwise operators

*To get the binary of any number,you convert it to base 2 and pad it till you get 8 bits

*binary shifts,bitwise or,not and and
*logical operator

*the zeros padded infront of a binary number till it reaches 8 bits are empty slots or placeholders while the last bits are the filled slots.When i do a bin num << 2,im telling the cpu to shift/move the position of the value in the occupied slots to two empty slots to the left leaving the previous slots empty for use.when this is converted back to base 10,it gives a differnt number entirely but since we are operating at the bit level,our concern is the internal rep of the number as bits and not the overall value.if i said bin >> 3,im telling it to shif the value to the next three empty slots to the right.Padding doesnt affect the value it only allows for consistent presentation.When you shift bits to occupy a different space on the byte when there is no more space,the bits that spilled out of the byte will be trashed

*Box is also used to prevent stack overflow which can be caused by recursion.

*Bitwise shifting can lead to spillage while lower number representation can lead to wrapping.The difference in the result of the effect is based on binary arithmetic principles.

^bitwise operators can store more information at zero memory costs.
^bitwise and,or and not
^different scenario when wrapping.whats a buffer overflow
^Lsb,Msb
^buffer overflow

*unsigned integers use the msb to store sign information while a signed integer uses all of its bits to store information.

*a buffer is used in batching data to a temporary storage till its transferred somewhere like from disk to memory instead of directly writing to the destination which may take time.This allows the programmer to process the entire chunk at once instead of constant read/writes.file operations,input data and network data all utilize buffers for efficiency.when more data is taken to a buffer more than the allocated space,it lead to a buffer overflow which leads to memory corruption and unexpeted behaviour as it unintentionally affects adjacent memory blocks

*Bitwise operators perform logical operators on the individual bits that makes up a value.Bitwise AND filters bits,OR combines them and NOT flips them.Bitwise AND is used for masking bits by isolating one and clearing others.Bitwise OR is used for enabling many flags/bits at the same time

*in rust,i can write any variable's value in its value literal,binary literal or hexadecimal literal.You can in js but binary literals are always 8 bytes so its not as memory efficient as it looks but in rust,you can make it one byte or more.i can use binary directly to store many flags all in just one byte instead of many booleans that will take a byte each.

*You have to declare generics in the function signature before you use them

*The <> notation is used for defining generics.Generics can lead to a mismatch error if many field use a genercic type but dont actually use different types at compile time.Its best to have only a few generics

*When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.

*You can define generics on individual methods/functions but if you define generics in struct definitions,the entire impl block must have the generic type defined in its signature but it doesnt have to use it in any of its methods.This is so that any method in the impl block can get ready to use a field from the instance thats a generic.The reason this is so is that whenever you use the struct that has the generic,you must provide a type to it.you can provide a concrete type or another generic.impl blocks arent the struct so they cant access its generic directly so it has to supply types to it like everything else in the codebase.If it provides generics,it must use a generic from its scope which means that you have to define the impl block with its own generic using the <> notation.it can also supply a concrete type

*Generics have zero runtime cost because rust expands the method,struct or enum that uses the generics for each concrete type used in the source code into duplicates at compile time.

*Since rust is object based and not oop,you cant directly make struct fields private but you can work around it by encapsulating it in a module scope which keeps everything private unless explicitly stated public.which means that all the fields in the struct will be private and can only be accessed through methods and can only be instantiated by a constructor unless you mark specific fields public with the pub keyword.

*Modules can be accessed through a relative path if they are declared in the same file where its used

*Generics are too arbitrary so rust needs more informations on generics to validate their operations.Thats what a trait is.A trait is a method that a type implements

*A struct,an impl block all encapsulated in a module is rust equivalent to a class. this class equivalent is made by composing a struct and an impl block together.Rust calls their methods associated functions that can behave like constructors.

*impl blocks are associated with the struct.They dont belong to the struct.

*traits are just contracts like structs.combined together,they are the equivalent of an interface in typescript.They are just contracts and any implementation must be done by impl blocks or providing concrete values in its assignment

*traits are mostly used with generics because they are used for defining shared methods so that you can work with the same method but on different types.

*polymorphism is when multiple objects or types have the same method signatures but different impls meaning that traits provide a form of polymorphism

*all the methods from a trait are public by default cuz they are shared

*we use the impl for block for traits

*A method that takes self is an instance method and one that doesnt is a class method.

*when you have a library of classes,you dont have to code a new object from scratch but you can just inherit from any class you want and override some functionality.

*There can be a default trait.which has an implementation but can be overriden.

*the From method on any struct is a special constructor that takes an object of one type and return the struct type's equivalent of it

*A trait encapsulated in a module block allows for a form of abstract classe.The difference here is that traits arent inherited,they are only implemented which means that a struct can impl the traits it chooses and override it.

*The best part about implementation over inheritance is that one doesnt have to worry about inheritance heierarchy especially in languages like js that makes this difficult.you only focus on th functionality that it has.This means that new structs can be created by composing it of other blocks

*string from,to string and format

*A method in a trait can use self to call another method from the same trait even if that method on the trait doesnt have a default impl.this is because any struct that implements a trait must provide concrete impls to all the methods from that trait.but a method defined in a trait can use self to call any field or method particular to a struct that impls it.this is because traits arent meant to be shared so they are not directly associated with any struct that impls them.

*A function can take a trait as a parameter instead of providing a concrete type which means that it takes any type that implements the trait by using the impl Trait syntax.It can take it as a ref or own it.The impl trait syntax is just syntatic sugar over the trait bound syntax.The impl trait syntax is better if each of the parameters take different types but implement a particular trait meaning that the function only cares about the traits the type has and not any relationship between the parameters types but if the function requires the parameters to be of the same type and implement the same trait,then the more verbose trait bound syntax is used.The + operator is used to specify that the paramter must have more traits.The where clause syntax is used to remove the clutter from the trait bound syntax by separating the trait information into its own block separate from the generic information.A function can also return a trait to specify that it returns any type that implements this trait.This is done with the impl trait syntax although you cant have the possibility of returning more than one kind of type that implements the trait meaning that if a function returns a type that implements a particular trait,it cant return one type in a conditional block for example and return another in another conditional block i.e they must be consistent

*You can conditionally render implementations for an instance of any type by specifying trait bounds in its generic type info signature of the impl block.It means that it only renders implementations for that instance if the type it provided as a generic to the struct has the specified traits.The implementation block can also be made to conditionally implement traits and not just methods.This is called a blanket implementation.It ensures safety as it will be wrong for the impl blocks to assume that every instnace of the struct uses types that satisfy a particular trait

*the conditionally rendered method impl block is for implementing methods only when a trait is satisfied while the conditional trait impl block is for implementing another trait when another trait is satisfied.

*undefined is a variable that has been declared but hasnt been set to any value as the value is indeterminate till its initialized.So if an unitialized declared pointer is used in the code,it will lead to undefined behaviour as the memory address the pointer points to is undetermined and its very unsafe.a null pointer is a safer option as it tells the compiler that the pointer doesnt point to any valid memory address.

*Dereferencing means accessing the value a pointer points to.If you try to dereference a null pointer,you are attempting to read/write to an invalid memory address which will lead to undefined behaviour.

*An uninitialized pointer is a pointer that is declared but without a value.Rust doesnt allow it.

*a bug in a c++ program that will cause undefined behaviour is one that c++ doesnt explicitly handle,understand its behaviour or state what should happen and they are left in the hands of the environment the program runs on which can cause unpredicatble and inconsistent results.

*string literals go to the static storage which has a permanenet lifetime
*you can write binary literals on any type.for a binary literal for a byte,you use a binary literal on u8

*the static storage is storage that is directly included in the program's binary in the read only section of the program.Data stored in the static storage cant be computed at compile time

*References in rust get invalidated when they go out of scope meaning that if the lifetime of the data they ref has a more extended lifetime like string literals,the ref gets invalidated but the string literal remains in the program which means that the data a reference refers to can outlive it and to prevent the otherwise where a ref mistakenly outlives its data which can create a dangling ref.

*string literals are created at the compile time of the program and are more memnory efficient than heap allocated data because of no need for allocation costs.the compiler can reuse literals rather than creating unique instances each time.

*a constant allows me to move any data that would have gone to the stack to be included in the programs binary to have a permanent lifetime while immutability doesnt affect its location but it prevents the data from accidentally mutated

*a let variable is tied to the lifetime of its scope so outside its scope,it gets invalidated even if it holds a ref to static lifetime data but constants arent tied to the lifetime of their scope.they live throughout the program but arent visible outside of their scope so they dont get invalidated outside of their scope,they arent just visible.Its about Validity vs Visibility.Constants can be declared top level since they arent tied to any scope while let variables cant even though they ref static storage

*lifetime annotations are just constraints that we must follow.They are used in functions to indicates that the returned reference will have the same lifetime as defined by any of the parameters of the function's choosing provided that its valid.They are used to ensure you dont mistakenly create dangling references.Rust replaces the lifetime placeholders with concrete values using the lifetimes of the parameters. if the params have the same lifetime annotation,rust takes the smaller one to ensure that the returned one isnt used beyond its scope but if they are different rust uses their separate lifetimes.the problem about using different annotations is that there you have to ensure that you return the one that lasts longer as rust cant know ahead of time which one will outlive the other.If you try to use the returned reference beyond the lifetime of the shorter input, the compiler will produce an error, preventing potential runtime issues.

*lifetime annotations should have more descriptive names about the data over generic names

*0b is for binary literal while b"" is for byte string literal.The first is for manipulating data at the bit level while the second one is for writing strings in abyte format over utf-8.


^----TO BE SUMMARIZED-----------^
*A ref is a shell over a pointer

*smart pointer,pointer and a ref.so they are the same thing in implementation.they are encapsulate pointers and have meta data but smart pointers manage themselves while refs are managed by the gc

*a ref in rust is a pointer to the addres of an owner.since the ref doesnt point to heap allocated data,it doesnt need to be managed by itself,rust or the programmer,the stack pops this out automatically but a ref in js directly points to the heap allocated data so it has to be managed by the gc.so the difference here is that the first is an indirect/borrowed ref while the second is a direct gc ref

*Reassigning changes the memory location of the data it holds on the heap.Redeclaring creates a variable with a new memory address on the stack that has the same name as the owner.It will also point to a separate memory address on the heap.It creates a new variable that overshadows the previous ones meaning that subsequent uses of that variable is to the new one not the old one.Mutating doesnt change the memory location of the data it holds.it changes the data directly at the location in the heap.

*so a weak ref is direct ref to the heap allocated data but it doesnt increase the ref count in the gc for that data this means that in a gc language,all ref are direct refs and as such,they have to be managed by the gc but in rust,there can only be one direct ref which is the owner thats a smart pointer.all other refs are indirect and only point to the address of the owner.

*To access the data that a pointer points to,you have to dereference it with the dereference operator * buut rust automatically does this when you want to access the data an owner points to.

*ref to variable and ref to data
*an owner is a smart pointer.
*A pointer is a variable that holds the memory address of data on the heap

*an owner becomes a ref only whenit encapsulates a pointer.a ref is a shell over a pointer and if an owner can have a pointer,its a ref except that in rust,an owner is a special kind of ref that can only be created once.other refs will have to be a borrowed ref. but in js,all references are treated equally.

*The owner itself is stored on the stack.it contains a pointer,length and capacity information but the data it owns is on the heap.it uses internal pointers to access that data so the key here is to ensure that the stack data doesn't outlive the heap data.By keeping onwer data on the stack,it can get deallocated by the stack memory automatically.rust just checks that if it does,the heap data is dropped.C++ pointers to are stored on the stack but any heap allocated memory must be explicitly freed.whwn you transfer ownership in rust,rust copies the owner metadata from the original location in the stack and transfer it to the new variable in the new scope and invalidates the old one
*the ref points to the owner and the owner points to the data if the data is on the heap. ref stores the location of the owner on the stack
*if the ref is a pointer to the data,then isn't it the same as an owner in rust or is the difference that in rust,only one variable can hold the pointer data at a time while in js,many variables can hold that same pointervdata
*a ref uses a pointer to access the data on the heap
*a ref encapsulates a pointer and since it's a shell over a pointer,pointer operations can't be directly done on the reference
*the owner of data is actually a ref to that data but the difference between this and refs that borrow is that refs that borrow points to the owner on the stack not directly to the heap data while owners point directly to the heap data
*But if the owner only has an integer,the owner won't have any pointer.it has the integer directly in one of it's properties

*so the gc has three types of algorithms;reachability,generation,compaction and when it runs
*reachability--to free memory--runtime ref counting,marking
*generation--splitting memory to young and old
*compaction--trace and compact
*when it runs---incrementally or concurrently

*The gc uses more than one algorithm besides ref counting.Ref counting and marking are the two ways of determining reachability.Its limitation is that it cant handle cyclic ref.Another one is generational collection which is when younger refs are collected more frequently and older ones are collected less.This is based on the observation that younger ones have a shorter use case.It involves dividing the heap;reachable and unreachable,young and old.

*so a cyclic ref doesnt affect the fact that they will both point to the same heap data except that cyclic ref will never allow any of the refs to drop to zero as there will always be a ref to the ref so it will never be garbage collected leading to a leak.A cyclic ref will be dropped once they go out of scope but if there is nay ref to any of the refs in the cycle,it prevents the other from dropping its count.

*They also perform tracing which is when they mark and compact instead of cleaning to reduce fragmentation.also stop and copy to prevent fragmentation

*so in rust because there is only one direct ref i.e the owner,the variable can drop the data after it goes out of scope but because in gc languages there is more than one direct ref,no variable can choose to drop it once it goes out of scope as it will invaldate others so ref counting has to be done where each direct ref increases the count and as they go out of scope,they drop the count.its only when the gc guarantees that there is no direct ref to data i.e all the direct refs have gone out of scope,it clears it.reachability means if there is anyone using the data

*Gcs do their work incrementally or concurrently

*so marking is by crawling through all direct refs in the code,if there is no direct ref to data on the heap which means it has gone out of scope,the gc will drop that memory on the heap

*the gc doesnt run as the program runs but rather,at intervals like when the memory is reaching a threshold,when its explicitly called by the programmer or when there isnt enough space.This means that gc languages dont free memory as the program runs but only at intervals which can be less efficient if some data being used is very short lived.while in rust,rc doesnt include a gc,there is no code that manages ref counts.the owners are smart pointers so the last owner will deterministically free memory once it goes out of scope meaning that ref counting in this case,frees memory as soon as its not in use.

*The owner cant outlive the data and a ref cant outlive the owner

*the ownership model in rust as enforced by the borrow checker isnt a memory manager like the garbage collector.The gc is its own codebase that manages the memory of the application's codebase that uses the memory while the borrow checker doesnt manage the memory of my code.it only enforces rules.Its the owner themselves that manages deallocations.They are responsible for managing their own memory and the borrow checker ensures that they do.This is a smart pointer.It doesnt rely on anything to manage itself.This is because that since rust only allows one direct ref,each owner can be responsible for the memory they use but since gc languages use multiple direct ref,no direct ref can take an action or a decision on what should happen to the data it points to in memory so it requires the gc that watches out for them.but how does rust rc allow multiple direct refs without a gc and why cant other programming langs do mimic rc for a more efficient mem management unless it will require the programmer to understand the mem usage of their program as thats what they want to prevent so that they can focus on their apps

*so in rust,every owner has a destructor thats called when they go out of scope.their scope lifetime is handled automatically by the stack because the owners themselves are on the stack.when their destructors are called,they free the memory they were pointing to.This makes them smart pointers.In rc,there can be multiple owners or multiple direct refs but this will create a scenario for making a gc like it is n js but this will lead to having another runtime which will not free mem as soon as the owners go out of scope and together with the runtime costs,it is not very efficient especially for rust standards.so rust makes many owners of the same rc instance to share a state called ref count.each time thy go out of scope and their destructor is called,they decrement this shared state and if another owner's destructor is called when the ref count is already zero,it frees the memory.This shifts ref counting ti the owner themeselves and not a separate runtime making the owners still smart pointers and deterministic unlike direct refs in js an python that dont manage themseleves and require the gc as a separate runtime

*the difference between a ref and a smart pointer is that a ref doesnt manage any memory.in gc languages,refs dont manage the memory they use,so they are called refs.in rust,refs are indirect refs,they only point to the owner so there is no memory they need to manage and as such,they are termed refs while owners of String,Vec,Hashmap manage the deallocation of those data so they are termed smart pointers as part of a collection while Box and Rc,are smart pointers that only focus on the memory they use

*memory usage in rust is more predicatble than in gc languages because memory is dropped as soon as its no longer in use

*the algorithm used determines the speed and effective memory usage of an app regardless of either it provides abstractions or not but coding an app in a more memory controlled environment like rust can lead to unmatched performance if used well thoughtfully.even if you apply the same thought to another pl that uses gc,will rust outperfrom in terms of memory

*for loop uses a ref and not ownership of the vectors so that each loop counter doesnt own each element of the vector which will make it unusable after the loop.so vectors dont allow for loops to consume them unless they become iterators through the into iter method which rust calls implicitly if you try to directly consume a vector in a loop.i can also loop over it as a ref annd put both of them in a scope and continue execution in the outers scope to free the vector after loop is done.the scoping of the vector and the loop in a scope to drop the vector after the loop is good if maybe after the loop,i may use the vector for a few more lines but after that,its no longer needed

*we dereferce twice when deref refs in rust because one is to get the address of the owner and the second is to get the address of the data it points to

*i have to convert a vector to an iterator before doing functional operations

^closure before io

^-----------------------------^

xcode vs vosual studio
swift vs c#.net


^Rust has a bunch of ways of providing full and explicit access to the stack,heap and static memory.

C--raw pointers
C++--smart pointers
Zig--safe allocators
Rust--Ownership
Nim--Tunable garbage collector

^&100u8,index as u32--Type casting
^self hosting compiler

^porting vs calling--interopability
^work around,direct solution
?errors as value vs exception
?Abstraction vs control

*rust closures are anonymous functions unlike functions,closures can capture scope meaning that they are not isolated like funtions that require data that enters them to be explicitly stated.Closures allow one to skip type annotations.apart from the pipeline operator,a closure is syntatically similar to functions.liuke arrow functions,closures can remove the braces if they only have one expression.Closures must evaluate some expression on the variable they use so that rust can infer its type annotation in input and on return.if there is no expression for rust to infer the type,the first use case of the closure creates the inference info that rust will use subsequently.a variable can bind to a closure definition, and we can later call the closure by using the variable name and parentheses as if the variable name were a function name.

*a closure is an anonymous function that can be stored in a variable.depending on what the closure captures the variables from its env for,it can capture it as an immutable ref,mutable ref or by ownership.The move keyword tells a closure to take ownership of all the variables it captures.

*an fnonce trait is a closure that can be called.by default,all closures implement this trait.a closure that moves values applies only the fn once trait and can only be called once because the variables required for it to work have becom invalidated.FnMut is a closure that mutates the values it captures but it doesnt take ownership so it can be called more than once.Fn trait is applied to closures that dont mutate the variable they capture or dont even capture variables at all.they can be called multiple times safely.

*Traits for closures in rust are rules on how a closure can be called.A higher order function or method can define traits in its signature that the caller must hold if they want to pass their closure to the function

*anonymous functions are syntatic sugar over functions in all the languages but they have unique properties depending on the language.

*An iterator is a special kind of generator.a generator is a function that yields values to the caller.Theres a difference between returning a value and yielding a value.returning a value returns a value to the caller and surrenders control flow back to the it while yielding a value gives the value to the caller but it doesnt terminate the control flow from the generator.the generator can be called again to resume from where it stopped to continue giving values.a generator is lazy.an iterator is a generator that iterates over a data structure and sequentially yields the value to the caller.Generators are lazy functions meaning that they compute their values on the fly instead of all at once like functions

*calling next on an iterator eats it up or consume it.which is when calling the next value on the iterator increases where it is in the sequence.you can only call it as much times as it can yield values.The iter function only takes an immutable ref to the vector so that consuming the iterator doesnt take ownership of each element in the vector or modify it but you can use methods liek iter_mut that makes the iterator take mutable refs to each item in the vector and into_iter for ownership.

*consuming adapters are methods that are called on iterators.they automatically call next on the iterator till they consume the whole thing.an example is sum.consuming methods take ownership of the iterator

*iterator adapters like map are methods that are called on iterators that dont consume the iterator empty but rather,creates a new iterator that applies a closure on each element of the prev iterator but because these closures are called lazily,they must be consumed before they can be used and thats what the collect method is for.its for consuming iterators from iterator adapters.so the collect method collects the value from these iterators into a vector.

^next,consumer adapter,iterator adapter

*iteratiors in rust dont yield values like generators do,they instead use a struct to manage state and determine which values they should return.so they are actually just normal functions that give the perception of a generator while a generator in other programming langs can yield and resume execution and the state is managed by the langauge's runtime

*the statement for zero cost abstractions is: you dont pay for what you dont use and you dont pay when you use it

*range construct syntax [start..end] is analogous to the slice syntax in other langs; [start:end]. the range construct syntax in rust can create slices of arrays or vectors and iterators that produces values within that given range.This is also called range notation.The range object which is when its used directly without slicing doesnt directly create an iterator but rather an object that can be turned to an iterator to produce values sequentially as its implicitly done in for loops.

*There are three types of doing ranging in for loops--range function like python,range object in rust and loop counter in c++ and js

^11,12,14

**Smart pointers like String,Vec and Hashmap only store data structures in the heap but if you want to store data that would have normally gone to the stack but on the heap like integers,char and bool,you can use the Box smart pointer but putting a single value on the heap isn’t very useful, so you won’t use boxes by themselves in this way very often. 

*Having values like a single i32 on the stack, where they’re stored by default, is more appropriate in the majority of situations and box doesnt provide any better memory performance.it just stores the data in the heap instead.But box is useful to preserver runtime in functions that return stack-allocated data so that rather than copying the data and returning it which will cost time,you can just transfer ownership of that value instead.

*The reason why structs are allocated the sum of their fields is because the space will be big enough to contain all the fields that will be present while enums are allocated the size of their largest variant because only one variant can occur at a time so summing the two will be inefficient,if it were to allocate it the size of the smallest variant,it wont hold a variable thats of a larger variant and rust cant do flexible allocations at runtime to flexibly allocate space for it as rust ensures that all allocations must be predictable or known at compile time.

*so a two way relationship breaks the ownership system because it becomes a recursive or cyclic structure and rust decides the memory allocation for a struct by summing the sizes of their fields or enum owner at compile time by giving it the size of its largest variant and if it were a recursive type,it will allocate an infinte amount of space to that type but it wont destroy the heap because rust will be lagging on determining the space to allocate to the type before it does use the space on the heap.

*The enum owner itself will be the size of the largest variant and its stored on the stack but the data of the variant itself is stored on the heap and the amount of space it uses depends on its type annotation


*A linked list is just an array that distributes its elements to random locations on the heap instead of a continuous block of memory.Since the memory address of each element is random,it cannot be indexed using pointer arithmetic to retrieve values which prevents access by index because a linked list disperses the elements on the heap and the only way to get the next element is by using the pointer of one element that will lead you to the next one but it will require you to start at the first element because lists like arrays decay to the pointer of the first element.The type of each element in a linked list has to be a struct that holds a value and the pointer to the next node in the list.

*the cause of memory leak is not freeing memory after use and the cause of fragmentation is constant reallocations and reallocations also cost runtime.

*Resizing vectors will create a reallocation where the compiler will look for a contiguos block that can hold its current size but to prevent constant reallocations,rust assigns a capacity which is extra space than the vector needs at the moment thats proportional to the size of the vector each time the vector grows to prevent the need for future reallocations if it grows in size.This may cause internal fragmentation because of the possibility that the vector will not use up all that space but if its not done,constant resizing like pushing will lead to  reallocations that will cause external fragmentation and external fragementation can cause resizing and future allocations to fail.clearing a vector removes the elements but keeps the capacity to prevent reallocations that will cause fragmentation but

*but because external fragmentation will only affect Strings and Vectors and HashMaps because they each use contiguous blocks of memory for their implementation,linked lists can be allocated despite this because each of its elements are scattered bypassing external fragmentation.

*stack data is for holding one value while heap data is for holding a bunch of values together.

*structs and enums only take one block since rust calculates the size required for them so they go to the stack

*null terminator or length as part of the metadata so that the compiler doesnt read past the block.

^heap data is for collections
^owners are stored on the stack but their values can be stored in the heap but the const are owners that are stored in static storage
?is an owner a k-v structure
^single linked lists in rust are created with recursive types using the Box pointer
^recursive type and a cyclic type
?does rust allow optional fields
^boxes can do recursive type but not a cyclic type
^smart pointers like vec,hashmap and string move stack allocated data to the heap but stores it in a collection that can grow and shrink.String is a smart pointer of characters
?why do characters take 2 bytes

*the heap doesnt have a neat grid structure or a particular layout
*the stack is like putting wooden blocks of various heights on top of each other while the heap is a wide wooden board where the wooden blocks can be placed anywere without any layout drawn on the board like a grid that will define where the blocks should go.Each variable in the stack is its own memory block and each scope creates a stack frame which is a collection of these blocks stacked together in a collection and when the function exits,the stack frame is popped off.

*if a struct is so large that it will lead to a stack overflow,you can use the box smart pointer to move it to the heap

*the size of a vector is the number of elements it has while the capacity of the vector is the amount of space allocated to it whether its bigger or smaller than the actual size needed

^enums is rust safer version of unions
*so it isnt just rust where each element in the vector takes the largest memory that any of the elements take.even when using enums in rust or unions or variants in c++ to store a vector that seems to store elements of various types,it only keeps track of the type and doesnt affect the fact that each element will take the size of the largest type.Its just use to preserve type information.This is for simplicity,reduced overhead and to prevent inconsistency that can have undefined behaviour

*the dynamic size is just determined by how many memory blocks it has.its flexible that blocks can be added and removed but the blocks themselves take a fixed space.by the functionality of heap to provide dynamic sizing which is just the placement or removal of memory blocks makes the heap just used for managing multiple memory blocks for a variable that stores other data

*Data on the heap has a lifetime thats not tied to the scope of the program because they exist outside the program so they must be freed manually but rust enforces borrowing rules

*The stack is for variables where the number of memory blocks that will be used for a variable must be known in advance or at compile time while the heap is for when the number of memory blocks to be used for a variable can be known at runtime

*the stack can also hold multiple memory blocks for a variable but the reason why memory blocks cant be removed or added anywhere in the stack other than the top is because it will dirupt the lifo order which will cause the other blocks crumble down from the stack but in actual implementation:it will complicate predictability but in the heap,the memory block can be removed without affecting any other one

*since the data on the stack is in a lifo order,you cant remove any block,you have to pop off the entire stack frame at once to clear any variable in a scope.

*Because a Box<T> is a pointer, Rust always knows how much space a Box<T> needs: a pointer’s size doesn’t change based on the amount of data it’s pointing to. This means we can put a Box<T> inside the Cons variant instead of another List value directly. The Box<T> will point to the next List value that will be on the heap rather than inside the Cons variant. Conceptually, we still have a list, created with lists holding other lists, but this implementation is now more like placing the items next to one another rather than inside one another.

*deref a box means taking ownership although one can reference the dereference to avoid ownership.

*You cant return an option and another type in a match.they both have to return option so that the programmer explicitly handles the cases of no value

*Its better to make structs own all their data for simplicity and removing the overhead of managing lifetime annotations even if the data wont shrink.

*the diff between a smart pointer and a ref is that a smart pointer can manage its own mem while refs cant.refs in rust are indirect refs while smart pointers are direct refs


*Using a pointer uses the memory address and not the actual value.To use the actual value stored at the address,you have to dereference it using the * operator,it is an operation on a pointer where you retrieve the data from the memory address that it points to.But now there are two types of smart pointers in rust;one-one smart pointer and a one-many smart pointer.You can only explicitly dereference a one-one smart pointer like Box and a mutable ref.for the Box,when moving a value out of the it,it is expicitly dereferenced but if i try to access fields on it,rust will automatically deref it for me so trying to deref it in this case will deref it twice and rust prevents it from compiling.After this operation, the Box is no longer valid for accessing the data since ownership has been transferred.It only allows explicit dereferencing on mutable refs and one-one smart pointers because if rust were to allow one to deref a one-many smart pointer like pointers to collections like vec,string or hashmap,it will lead to confusion and raises a lot of questions of what doing that actually means.Some may think that it will deref the entire collection but others and rust assumes that you typically want to access an element rather than the entire collection as it is consistent with how collections are usually used. so rust provides methods over these pointers and direct usage of the variable in reading and assignments that makes it clear what you are trying to do with that collection through the pointer.You cannot use an immutable ref to deref at all because if you use it to deref and assign,it will modify the value which can lead to races if anyone is going to use the immutable ref and if you use it to deref and return,it may transfer ownership which will make the immutable ref dangling.You can only deref an immutable variable in two strict conditions;if the data you are dereferencing to implements the copy trait or you are printing it to the standard output so that you dont move it out but rust does this implicitly in this way but mutable references have to be explicitly dereferenced when assigning the variables they point to to a new value and when they want to mutate the value they point to.

*There is explicit and implicit dereferencing.You can explicitly dereference in two ways;dereference and assign or dereference and return.When the deref operator is on the left hand side of the assignment,its deref and modify but if its on the right,its deref and return.You can only deref and assign with mutable refs to data.You cannot deref and return with a mutable ref if the data doesnt implement the copy trait as rust doesnt allow mutable refs to move data form their owners if the owners are one-many smart pointers but you can for one-one smart pointer like the box and it will transfer ownership.


*both get and indexing must return a reference to an element in the vector while remove removes it from the vector and give ownership of that value to a variable meaning that i cannot directly index into a String and give it to a variable.You have to do referencing and indexing at the same time to do this.If you remove an element from a vector,trying to access it will give index out of bounds error if the index of what you removed is greater than the new size of the vector 

*boxing doesnt provide any better memory savings for integers or chars as their allocations are known at compile time and it only provides ownership.Boxing collections is pointless because vectors,strings and maps are smart pointers themselves designed to manage the memory they hold.Boxing is useful for structs when the structs have recursive and not cyclic types.

*A tuple struct in Rust is a type of struct that is defined using a tuple-like syntax. Tuple structs allow you to create a new type with named fields, but unlike regular structs that have named fields, the fields in a tuple struct are accessed by their position (index) rather than by name.It isnt different from a tuple other than to give more meaning to grouped data.it also makes it more typesafe to work with

*associated types are like the generics of traits

*in rust,you can create functionality on operators for your types by using operator overloading.You do this by implementing traits while in python,you do this by using dunder methods.js doesnt support operator overloading.

*in rust and python,operators are actually syntatic sugar over function calls only for user defined types while operators on default types like integers gets compiled directly to a cpu instructions.

*the deref trait allows one to write code that uses a smart pointer as readably as a regular reference.it is called when the * operator is used on the type

*deref coercion is when rust cnverts a ref on one type to a ref of another.When you have a type T that implements the Deref trait, Rust can automatically convert a reference of type &T to a reference of type &U, where U is the target type defined by Deref.The Target associated type defines what type the Deref implementation will convert to when dereferenced.

*When you have a function defined to take a reference of one type, and you provide a reference to another type that implements the Deref trait to convert to the expected type, Rust will automatically perform this conversion behind the scenes.

*the drop trait is automatically called when a struct goes out of scope.cleanup code in python is done with the with block which is a context manager while rust uses the drop trait while in js,its done manually.the resources that needs to be managed by the drop trait is not just memory in the case of smart pointers but also other resources like file handlers,network sockets 

*rust doesnt allow one to call the drop method manually as its done automatocally when a variable goes out of scope and if you call the drop method,rust will still call it when the scope ends,causing a double free

* the term destructor, which is the general programming term for a function that cleans up an instance. A destructor is analogous to a constructor, which creates an instance. The drop function in Rust is one particular destructor.

*so i can implement my own smart pointers in rust

*if a function doesnt use a variable,the compiler doesnt see the need to invoke the drop function but it still enforces its ownership rules but it wont bother calling the drop trait

*copy is a trait and move is a trait

*if multiple variables use the same data and we knew the last user of the data in advance,we wont have to use rc as we can just make the last person the owner and the owenrship rules will apply

*Box::new takes ownership

*in rust,if variable b is dependent on variable a either by ref or for assignment,there is no way b will outlive a because b cant be initialized before a since it depends on it and b wont be able to use the value of a outside of the scope of a as a will be invalidated so the only way around this is to declare b without a value outside of the scope of a and modify it in the scope of a so that b,the dependent will outlive a

*Rc doesnt allow the owners to mutate the data as it will cause data races so the owners can only read the data.it doesnt feel much like a difference from immutable refs except that each owner is a pointer to the address of one owner but each owner is a direct pointer to the data on the heap meaning that it wont get dropped until all the owners are out of scope

*Ref cell uses unsafe code to perform interior mutability which is mutating data with immutable refs

*structs are stored on the stack and rust needs to know the memory to allocate to that struct at compile time and if a struct uses itself in its field,rust will have to calculate the size that that struct will take and again and again that will lead to a recursion so Box solves the problem of recursive type moving data to the heap which means that rust doesnt have to calculate the size all at once,it just stores a pointer to the field of the struct that refs the struct an since its a pointer,the data is shifted to the heap which allows for rust to opt in more memory blocks as more structs are added but Box requires that the data must have a single owner so if two structs ref themselves,Box wont decide who owns who to decide who is responsible for deallocating the memory once out of scope so Rc fixes this by doing what the Box does but also allowing multiple owmers of data to coexist by using ref counting.this ensures that the data is only dropped when all the owners go out of scope but to prevent memory leaks from cyclic ref,one can use a weak ref which wont affect the ref count

*a declared variable is not mutable because its value hasnt been decided yet

*Rc and refcell are only single threaded scenarios
*Because RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.Mutating the value inside an immutable value is the interior mutability pattern.Using RefCell<T> is one way to get the ability to have interior mutability, but RefCell<T> doesn’t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you’ll get a panic! instead of a compiler error.

*In python and js,functions can capture variables from their environment or outer scope meaning that they can share and modify the same data by moving data to the top level scope.The global keyword can move any variable from any scope to the top level scope to implement sharing of data across functions while in rust,functions are completely isolated meaning that they cant capture variables from their environment only child scopes can capture variables from the parent scopes while functions requires you to pass any data that it will use from the parent scope to it to prevent accidental side effects but you can use closures which are anonymous functions that can capture data from their environment.

*Persistence and sharing data amongs functions

*global variables dont take data to the heap.they just move the scope of the variable to the top scope so that multiple functions can capture it

^Code editors rely on consistent font sizes to correctly render cursor placement

^update the flex type to have many traits and better performance

*cyclic ref: when A->data,A has a ref count of 1 and when B->A,A now has a ref count of 2 because it contributes two pointers to the same data and B has a ref count of 1 because B contributes one pointer to the data so its now 2 for A and 1 for B and if A->B,B now has a ref count of 2 because it contributes two pointers to the data and A now increases to 3 because it now contributes 3 pointers to the data

*the ref count of a doesnt just increase when it points to data on the heap,it also increases when another variable points to it

*so there are two types of references;an external and an internal ref.A variable has an external ref when it points to data on the heap or another variable and has an internal ref when its pointed to by another variable.Given two refs A and B,A->data and A will have an external ref of 1 because it points to data on the heap.then I will want to create B so that B will share the data with A so it will be B->A.A now has an internal ref because its being pointed to by B so A now has two refs and B has on external ref because it points to A.then if A->B,B has one internal ref because its being pointed to by A making B to have two refs(one internal and one external).So now,both A and B have 2 refs count each.This doesnt affect the fact that they will both point to and share the same data on the heap but it will affect the ref count to that data.When the scope ends,they will only decrease by one ref count each and it will still have a ref to the data preventing it from being reclaimed.if A goes out of scope but B still exists, A's reference count will decrease, but B will still hold a reference to A, leading to a dangling reference if not managed properly.


*A->data,B->A,A->B
*ref counting has two types of ref--internal and external ref

*Internal references do not contribute to the strong count. They are part of the relationships between instances but do not increase the count reported by Rc::strong_count().The total reference count is simply the sum of all external references to the underlying data.

*there is a linear sequence of assignment,recursive and cyclic assignment.a linear assignment has a clear ownership flow and cannot happen with types like String

*Rust doesnt allow recursive types because it doesnt know how much space to allocate for the struct and it doesnt allow cyclic types because it cannot determine how to drop these instances. They are waiting on each other to be dropped, leading to a situation where neither can be freed.So the same goes for Box.without a single owner,the memory can never be freed as no one is responsible for freeing it

*the rust compiler complains if it is done directly but it wont if its done in a vector/indirectly but they are still cyclic types.i taught that this somehow bypassed rust because rust didnt complain but i cant even initiliaze any of the type because it requires the other struct to be created before that one which also requires a struct from the other type to be declared first to infinity.so even if rust didnt complain,i cant even do it.This is because in this situation,the compiler does not explicitly complain at the struct definition level, but it still creates a situation where initializing instances of either struct requires the other to exist first. This results in a circular dependency that makes it impossible to instantiate either struct.

*The Rust compiler checks for ownership and borrowing rules but does not evaluate the logical flow of initialization in the same way. When you define types, it doesn't check if you can instantiate them based on their interdependencies.Even though the compiler allows the definitions, you won't be able to create instances of these structs because each constructor requires the other, leading to an infinite loop of dependencies.


*Object oriented uses a constructor with the new keyword.prototype based doesnt create objects from anything its done on the fly but can adhere to an interface or optionally a constructor while object based uses the struct's name and pass the fields or optionally using an association


*So making matt an Rc directly and creating another instance of that per student allows many students to share the same teacher instead of one student owning that one teacher.i cant directly access the fields of an Rc because like Box,it will move it out which isnt allowed since many students share the same data unlike Box where there is only one owner at a time

*Rc new creates a new data to share and rc clone is tell one to be a shared owner of the data.rc clone refs an rc not a variable directly.Rc new and rc clone creates an rc except that rc new moves takes ownership of the data meaning that if its separate from the variable,the original variable will be invalid for reuse later so to properly utilize the rc,the data to be shared must be initialized as an rc directly so that others can use it with rc clone which doesnt take ownership but shares ownership allowing the data to be reused later.in other words,the variable to be shared should be initialized with rc new and the ones to share it should use rc clone.

*the reason why we use rc in both is so that not one instance of eithet structs owns the other but rather share it

*If student were just an Option<Student>, then Teacher would own the Student directly. This means when a Student is assigned to the student field, the Teacher would take ownership of the Student, and you wouldn't be able to use that Student elsewhere.

* by using an rc on both sides,i prevent one from owning the other but rather sharing the other,i can reuse any of the instances on demand and it allows me to create a graph relationship between structs where each struct can refer back to the other instead of a single linear flow

*so for a graph relationship,no one type owns the other but if it were a linear type although i can use rc on one side of the relationship to create a cycle,it wont allow me to use one after using the other

*enumerate is a consumer adapter on an iterator.it returns the index and value

*We can use types that use the interior mutability pattern only when we can ensure that the borrowing rules will be followed at runtime, even though the compiler can’t guarantee that. The unsafe code involved is then wrapped in a safe API, and the outer type is still immutable.


*Refcell only allows one owner of data at a time so a refcell cant wrap an rc but an rc can wrap a ref cell.Refcell is just like box.The difference is that the rule that there can only be one mutable ref or many immutable refs but not both at the same time is checked at compile time for Box but it isnt possible to check it for Refcell at compile time but only at runtime.This means that the code for refcell has to be in an unsafe block so that rust doesnt prevent it from compiling and the rules are ensured to be enforced at runtime by the programmer and wrapped as safe code so that the compiler doesnt complain about it but since the rules are checked at runtime,refcell panics when you brea its rules unlike box that panics.The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, where they would’ve been disallowed by the compile-time checks.

*thats why we have the unsafe block.for code that is guaranteed to be safe but rust doesnt understand this kind of code so it doesnt allow it.This means that the programmer has to ensure that the code follows borrowing rules at runtime and panic if they are violated.

*Box<T> allows immutable or mutable borrows checked at compile time; Rc<T> allows only immutable borrows checked at compile time; RefCell<T> allows immutable or mutable borrows checked at runtime.

*the reason why rc cant be mutable directly is because its a scenario thats memory safe but the compiler wont allow it because its not sure as it will allow for data races which will be a violation.The reason why box allows mutations is because there is a single owner so data races isnt possible.Mutating the value inside an immutable value is the interior mutability pattern.

*because refcell uses runtime checks,we cant use notations like & and mut & as they are compile time notations.so we use methods like borrow and borrow_mut for borrowing immutably and mutably respectively.borrow returns a branch of the refcell smart pointer,Ref while borrow mut retunrns RefMut.

*Rc<RefCell<data>> creates interior mutably because it bypasses the immutable shell of Rc allowing us to mutate the value inside the rc.this allows us to mutate the value while still having the safety of rc

*Box is a type,the box smart pointer is Box::new.Rc is a type but its smart pointer is Rc:new for creating the data that will be shared and Rc::clone for sharing that shared data.Refcell is a type,the smart pointers are borrow and borrow_mut on the refcell data.the same way rc keeps track of the owners sharing the data,refcell keeps track of each immutable pointer created and decreases it each time one goes out of scope,when it reaches zero,the data it points to is dropped.Mutable smart pointers dont need to be counted since only one can be created at a time.If the ownership rule is violated,it panics

*the reason why only one mut ref can be created at a time so that only one process can use it at a time and not multiple to prevent races

*using refcell which checks for borrowing rules at runtime will mean code that wrongly uses it wont be known at runtime and there will be additional runtime used by refcell to keep track of borrows unlike other code that checks it at compile time.

*Arc is the thread safe version of Rc and Mutex to RefCell

*cycles are difficult but not impossible to do in rust.one has to ensure that there is a weak ref on one side of the relationship to break the cycle.a weak ref is an owner that doesnt affect the ref count.Rc::clone returns a strong ref pointer while Rc::downgrade returns a weak ref smart pointer

*weak refs dont prevent what they share to be dropped meaning that what they share can be dropped if there are no strong refs to it but the variables that own the weak ref will still remain and their refs will be invalid.This will create a scenario where they remember the data they shared but they no longer have access to it.you can then use upgrade to check on that before accessing the data by the pointer

*the side that has the weak ref depends on who i want to outlive the other

*weak unlike rc doesnt directly return a pointer because of the possibility that it will be inavlid.it rather returns an option object in which you have to match before use making it more verbose to write

*modules must be declared in the top-level scope because modules within functions wont be visible to the module system because it will only be available if the function is called

*overshadowing can lead to confusion so its uncrecommended to use it

*to make a field in a struct optional in rust,you must use the option eneum

one-many smart pointer--Vec,String,Hashmap
one-one--->Box,Refcell
many-one--->Rc

*Refcell is just box but enforces rules at runtime allowing for interior mutability.By putting refcell in an rc,rust can ensure that many owners cant mutate the data and even if they do,it will be one at a time because refcell only allows one owner.

*You use rc on both sides of the relationship so that both types can be reused later and are independent from each other such that one doesnt drop because of another.The one that outlives the other should use weak.it will not affect the ref count which will make the other type to drop before it

^explicit code can be more verbose to read but when you do read it,you fully understand what your program is doing because it doesnt hide anything from you

*it only captures it by value if i want to print it in the closure unless i use the move keyword but when i assign it to another variable,it gets moved with or without the move keyword

* you cannot directly create an implement block for a built in or generated type i.e through builtin type with generics because it will override its default behaviour so you have to implement traits instead to create new behaviour for the type

*the to_owned method copies data only from a reference and creates an owned instance of that data while the clone method copies any object regardless of whether its a reference or not so its general purpose while to owned is optimized for references

*The process of creating snapshots to save a particular state of data is often referred to as "cloning" or "copying" the data. This allows you to work with separate instances of the data, avoiding issues that arise from shared mutable references. Cloning helps in situations where you need to maintain distinct states for different variables or contexts.

*upgrade turns a weak ref to a strong one but in an option object in case what it refs to is no longer there

*long method chaining is used to access deeply nested types.The number of methods in a chain increases with how nested a type is

*clarity is not equal to easy-readability.Code that is clear is very explicit and informs the programmer about everything that goes on in the program preventing wrong assumptions that can lead to bugs but makes it more verbose to write while code that is easily readable is more implicit but hides what the code does underneath that create wrong assumptions that can lead to bugs.The first creates more reliable code while the second creates rapid software.Bugs are harder to leak in rust than in typescript

^the swap function of my Teacher:in the previous one,i effectively swapped the students the teachers were pointing to by using snapshots of their students but i didnt correctly update the students to reflect this modification because i changed the name property without actually changing the teacher objects they were pointing to so when the students of the teachers were swapped, the students were still tied to their original teachers, which resulted in the names being mixed up and the reason why it worked this time because i made the teacher property of each student point to their respective teachers post-modification.

^if i want to modify the property of a node like node A in a graph relationship,i have to make sure that all other nodes pointing to A point to the post-modified node A object instead of directly trying to change the property of the pre-modified nodeA object they point to.for example when i directly updated the properties of node A and node B which are the teachers,they swapped their students but the students in their arrays were pointing to the node they pointed to before the swapped so before,node A taught class A and node B taught class B but after the modification nodeA taught class B and node B taught class A but the students in class A still say they are taught by node A and the students in class B are still pointing to node B as their teacher.So they didnt reflect the change but the teachers did so it created the scenario were the teachers taught new students but the students still claimed that they are being taught by their old teacher.but after making each student in class A and B point to their teachers post modification,it correctly fixed the relationship.

^This is because like in a school,if you change any of a teacher's students you have to equally imform the students about the changes so that there wont be any confusion.

*linear relationship,recursive relationship and cyclic relationship

*turning a vector to an iterable using iter is required to do functional things on a vector and the collect method is required to return a transformed vector.You can insert a function that does something on each of the elements which wont require collect but if the function applies a rule on the iterable to create a new transformed one,it requires a collect method.

deref using & or as_x method vs to_x methods

as,Type suffix vs type annotation
from trait,into
to_x,as_x,clone
parse

structured vs grouped data

iter for working on the individual elements
direct methods for working on the vector directly

transformation,reduction,modification--take rules or closures

*parse can be implemented on any type that has the FromStr

^The rule of ownership is different from the rule of borrowing

*You can only borrow an Rc immutably

*the cow smart pointer represents either an owned or a borrowed value.if its owned,i can use it directly to modify the value and if its not,it is only read only and if i do want to modify it,it will create a copy and transfer ownership of that instance to my program.i can then create borrowed pointers to it using to_mut.It is short for copy on write which does what its name implies

*smart containers.they are called smart containers cuz they are not focused on memory managemnt but collections
String->::from is the smart pointer
Vec->::new is the smart pointer
Hasmap->::new is the smart pointer

*Smart pointers->x-one relationships
Box->::new is the smart pointer
Rc->::new,Rc::clone 
Weak->Rc::downgrade
Cell
RefCell->::new
Cow->::Owned,Borrowed
Pin
Arc
Mutex

*iter_mut(): This method creates an iterator that yields mutable references to each element of the vector. This allows you to modify the elements directly.

*functions and methods are in their own evironments while cloures are within another's environment

*you cannot directly modify the value with a refcell pointer like you can do with box.you can only modify it by borrowing it with a ref.Rc directly reads by dereferencing like box.Cell allows direct deref over borrowng unlike Refcell but its only for values that can be copied like integers.It cannot be used for types that requires borrowing.Refcell is required for this.The reason why cell doesnt work for borrowed types because it will be more dangerous to allow interior mutability for owned types to prevent them from being dropped when modified.By not allowing direct deref,ownership cannot be transferred.Transferring owership doesnt change the mem address of the value it points to.

*redeclaring,reassignment,mutating through a deref or mutable borrrow
^dereferencing vs borrowing
^semantic highlighting vs textmate grammer for syntax highlighting'

*Race conditions, where threads are accessing data or resources in an inconsistent order
*Deadlocks, where two threads are waiting for each other, preventing both threads from continuing

*rust uses a 1:1 thread model

^There is an array,an itrerator and a vector.an array can be gen by using the syntax; [x;y] where x is an element and y is the number of times it occurs.it will be generated at compile time.The [x..y] syntax is specific to range and slices.A range returns an iterator.(1..20) is a Range and this: [1..20] is an array that has a Range as its first element.the [] syntax is specific to arrays.for vectors you use the vec! macro or use the array syntax and convert it to a vec using to_vec.paranthesis () is only used for tuples and representing the order of operations and the rust compiler will flag it if you use it where its not needed for cleaner code.

setTimeout and setInterval in js

^Dynamically adjusting the timeout based on synchronous execution time

*the program terminates as soon as the main thread is doen regardless of the state of the other threads.You can sleep the threads so that the main thread waits on other threads.Sleeping is a way for threads to wait on each other allowing them to take turns but it isnt guaranteed.

*the output or order in which threads run is not guaranteed as it changes each time the program runs since the time slices will be calculated different each time but the order of async operations is guaranteed and controlled because everything is running on one thread

*The join handler on a thread ensures that the main thread waits before join.

*join blocks a thread until another finishes so where its placed can affect whether the threads will run concurrently or not while sleeping a thread doesnt block it but it delays a thread from executing which will allow other threads to run.Its the same thing as joining except that joining is more precise

*sleeping a thread is delaying/pausing its execution for a specified duration which can allow other threads to run.Delay here means the thread doesnt do anything for that specified period of time.Its less precise to use to synchronize threads but its a general way of making threads wait on each other while joining blocks another thread until its done.its a more precise way to synchronize threads.The difference between blocking and delaying a thread is that blocking a thread prevents its execution while sleeping a thread means making it dormant for a specified duration of time

*so rust prevent threads from borrowing values directly from their environment because the thread may outlive its function.They need to own it

join,sleep
events,flags,locks,messages

match case is pattern matching syntax while if let and let else is destructurig syntax.thers array destructuring,object destructuring and enum destructuring.they follow the syntax let structure = variable
perplexity

*in a real app,we will want to handle the places where we put unwrap properly

*one way to share data among threads is by using a channel which can send variables over threads

*The transmitter has a send method that takes the value we want to send. The send method returns a Result<T, E> type, so if the receiver has already been dropped and there’s nowhere to send a value, the send operation will return an error. 

*The receiver has two useful methods: recv and try_recv. We’re using recv, short for receive, which will block the main thread’s execution and wait until a value is sent down the channel. Once a value is sent, recv will return it in a Result<T, E>. When the transmitter closes, recv will return an error to signal that no more values will be coming.

*The try_recv method doesn’t block, but will instead return a Result<T, E> immediately: an Ok value holding a message if one is available and an Err value if there aren’t any messages this time. Using try_recv is useful if this thread has other work to do while waiting for messages: we could write a loop that calls try_recv every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.

*The send function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it. This stops us from accidentally using the value again after sending it which prevents unexpected behaviour if the receiver modifies or drops the data before we continue using it

*you can treat rx as an iterator.its useful when we want the receiver to be taking in values as they come

*The channel's model is multiple producers and one receiver.You ca use the same receiver object but the transmitter object must be cloned because each thread will take ownership of each transmitter

channels are a way of sharing data by ownership

*mutexes are the thread safe version of refcell.like refcell,its used for safe mutability even when they are multiple owners by allowing only one thread to use a given data at a time by using locks the same way refcell ensures that even in an rc,there is only one owner at a time for the data and any changes has to be done by borrowing.

*Rc and refcell is about ownership while mutex and arc is about sharing

*The type system ensures that we acquire a lock before using the value in m. The type of m is Mutex<i32>, not i32, so we must call lock to be able to use the i32 value.As you might suspect, Mutex<T> is a smart pointer. More accurately, the call to lock returns a smart pointer called MutexGuard, wrapped in a LockResult that we handled with the call to unwrap. The MutexGuard smart pointer implements Deref to point at our inner data; the smart pointer also has a Drop implementation that releases the lock automatically when a MutexGuard goes out of scope, which happens at the end of the inner scope. As a result, we don’t risk forgetting to release the lock and blocking the mutex from being used by other threads, because the lock release happens automatically.

*the only way to access the value in a mutex is with the lock and the lock is automatically dropped when the scope ends.the call to lock will fail if another thread holding the lock panics to prevent access to possibly corrupted data.The mutex then becomes posioned

*the lock gets dropped automatically like what every other smart pointer does with their data

^diff between rc and arc,atomic vs integer counting

Because atomic operations are guaranteed to be atomic, they prevent data races. A data race occurs when two or more threads access the same memory location concurrently, and at least one of the accesses is a write.
With atomic counting, you can safely increment or decrement a reference count from multiple threads without using locks, avoiding the overhead and complexity of lock management.

Unfortunately, Rc<T> is not safe to share across threads. When Rc<T> manages the reference count, it adds to the count for each call to clone and subtracts from the count when each clone is dropped. But it doesn’t use any concurrency primitives to make sure that changes to the count can’t be interrupted by another thread. This could lead to wrong counts—subtle bugs that could in turn lead to memory leaks or a value being dropped before we’re done with it. What we need is a type exactly like Rc<T> but one that makes changes to the reference count in a thread-safe way.

When multiple threads modify the reference count without synchronization, it results in a data race. This can lead to undefined behavior, crashes, or corrupted memory. For instance, if one thread decrements the count while another thread is still using the object, it might lead to a situation where the object is freed while still being accessed.

a data race is when multiple threads access the same data and at least one of them is a write

You might then wonder why all primitive types aren’t atomic and why standard library types aren’t implemented to use Arc<T> by default. The reason is that thread safety comes with a performance penalty that you only want to pay when you really need to. If you’re just performing operations on values within a single thread, your code can run faster if it doesn’t have to enforce the guarantees atomics provide.

as complex as arc is,the usage of arc is the same as rc and and the usage of mutex is the same as refcell where we use lock instead of borrow and u can directly deref on the value to modify it without borrowing

Mutex is like refcelll where the underlying data is a shared ref and when wrapped in an Arc,only one thread can use the data at a time even when multiple threads share the same data similar to how refcell only allows one owner at a time and refcell only allows one mutable borrow the same way mutex only allows one lock access at a time

*Mutex<T> comes with the risk of creating deadlocks. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever.Deadlocks are like cyclic refs because cyclic refs makes the two variables wait on each other before they dropped and causing a leak while deadlocks makes two threads to wait on each other making them freeze forever.the first will cost you runtime and the second will cost you memory

*Marker traits in Rust are traits that do not have any methods or associated functions. They are used to convey additional information about a type, often related to properties or capabilities of that type. The most common examples of marker traits are Send and Sync.They are just used to mark them as safe.

*Send:A marker trait that indicates a type is safe to be transferred across thread boundaries.If a type implements Send, it means that instances of that type can be safely sent to another thread.

*Sync:A marker trait that indicates a type can be safely referenced from multiple threads simultaneously.If a type implements Sync, it means that you can have a reference to that type in multiple threads at the same time.

*When designing data structures, careful consideration must be given to what types are used within them. If a data structure contains a type that is not Send, it cannot be safely shared across threads.Similarly, if a data structure contains a type that is not Sync, it cannot be safely referenced simultaneously from multiple threads.

tokio lib for rust

*locking block the thread till it acquires the lock

*if the shared data is read-only,i use arc alone,if its heavily modified,i should use mutex wrapped in an arc but if its heavily read but a little bit modified,i should use rwlock wrapped in an arc.

js pioneers in async programming
rust pioneers in thread safe code
mojo and bend pioneer in gpu programming
go pioneers in goroutine model

*the higher the level of thread synchronization,the less concurrent the program becomes and to resolve this,we break down the syncs into multiple locks instead of just one and use more flexible locks like rw locks meaning that threads are better as they more independent but if they are heavily dependent one may resort to async for better concurrency

*so async is better for heavily dependent concurrent operations because heavily dependent operations will just reduce to a single thread and async can still achieve concurrency on thread by prioritizing tasks while threads are for independent operations

promises/futures and async/await

parallelism is for cpu bound tasks
async is for io bound tasks
threading is for both generally

cpu bound tasks are only as fast as the cpu while io bound tasks are only as fast as the speed of input and output

*the term blocking is usually reserved for function calls that interact with files, the network, or other resources on the computer, because those are the cases where an individual program would benefit from the operation being non-blocking.

*When an individual works on several different tasks before any of them is complete,it becomes concurrency.

*heavily dependent operations are blocking because it requires an operation to finish before another starts.The more synchronized threads become,the more serial they become,the less concurrent they become while independent operations are non blocking meaning that they can operate indepently and they are only limited by the cpus speed.

*interrupting ans switching between tasks.the async keyword is used for saying that a function can be interrupted and resumed

rust uses the tokio runtime for async code.A runtime is an environment that executes or manages an aspect of a program

Iterators do nothing unless you call their next method—whether directly or by using for loops or methodssuch as map that use next under the hood. Likewise, futures do nothing unless you explicitly ask them to.This laziness allows Rust to avoid running async code until it’s actually needed.

*in rust,await is a postfix method thats chained to an async function.It allows us to chain async operations easily

async operations in rust are lazy while async operations in js are postponed or reprioritized

*in rust,async blocks get compiled into futures while async functions gets compiled to regular functions that return futures.The same in js,async is syntatic sugar for a function that returns a promise except that in rust,async functions wrap the entire block in a future while js only wraps the return value in a promise and this is because in rust,blocks are expressions that can return something while in js only the return keyword can return a value

*promise is the main thing of async operations.a promise means that this operations shouldnt execute immediately but later

* tokio is a rust program that executes async code by compiling async code into an orchestrated sync code by managing futures.This means that every async code in rust goes through a two way process to execution and cant be solely understood by the compiler.Its the same for go that uses a go-runtime to manage goroutines and js where the event loop is a runtime that manages async code.Threads in rust dont have their own runtime as its managed by the os.async io is the async runtime for python

*in js code,async code can be directly executed because its bundled with a runtime while rust isnt

*cargo installs the compiled depenedencies as separate executables that are linked to mine at runtime.The compiled dependencies are stored in the target folder.The cargo bundle tool will package my entire codebase along with the dependencies into a single installer

*there is a debug build and a release build.The debug one is quickly compiled for dev while the release build is heavily optimized for production.cargo build and build release do these respectively.

*futures are state machines like promises.They have states similar to idle,pending and done in promises.Now you can see why the compiler stopped us from making main itself an async function back in Listing 17-3. If main were an async function, something else would need to manage the state machine for whatever future main returned, but main is the starting point for the program!

*I can ship apps as desktop apps,web apps and container apps.the first two are for users while the last one are for servers

*tokio bundles the main function in an async runtime allowing us to use async code top level like in ts

*Concurrency and parallelism are not the same thing. If you alternate between two tasks, then you are working on both tasks concurrently, but not in parallel. For it to qualify as parallel, you would need two people, one dedicated to each task.

*async programming ensures that operations that cant be completed immediately are suspended

^18,19,20
^12,14,11

a chatbot app is stateful--can take longer prompts and keeps records of chats
a chatbot in a search engine is stateless--requires shorter prompts

commands,queries,code,prompts

reverse engineering
key generator

promises/futures,async/await,micro task and macro tasks


*async functions in rust are lazy meaning that they wont start executing unless you await them or you can spawn them which will execite them while in js,when you call an async function,it starts running immediately till it reaches an await

*async threading is where the runtime leverages multiple threads from a pool but maps many tasks to a single thread instead of one task to a thread by making tasks that block the thread to yield control for another task to use that thread.But in async like js,tasks are ordered from non blocking to blocking and the sorted order of tasks is executed synchronously.pure async programming is about prioritizing tasks according to their blocking or non-blocking nature and executing that serially.in async,the code in the task is executed serially and once a part of it is blocking,the task yields control to the program and that task is postponed to run later after the non blocking ones finish

*since async blocks are lazy,they dont execute till you await them or map them to a thread using spawn unlike threading that every new task spawns a new thread.

the event loop handles async code
the os handles threads
the runtime handles async thread code

*Spawning the task submits it to the Tokio scheduler, which then ensures that the task executes when it has work to do. The spawned task may be executed on the same thread as where it was spawned, or it may execute on a different runtime thread. The task can also be moved between threads after being spawned.

*Async functions that are ran with await tells tokio that its part of the task that called it which means that the caller cannot continue executing until that one is finished and they are both on the same thread while running it by using spawn tells tokio that the caller does not require the task to continue executing so that task becomes independent from the caller and can be mapped to another or the same thread as the caller depending on tokio

*its difficult to preduct the exact execution order of code written in threads or async-threads like tokio unlike js

*when tokio comes across an awaited function,the awaited functions yield uts execution so that other tasks can execute on the same thread

*When we say that a value is 'static, all that means is that it would not be incorrect to keep that value around forever. This is important because the compiler is unable to reason about how long a newly spawned task stays around. We have to make sure that the task is allowed to live forever, so that Tokio can make the task run as long as it needs to.

*a tokio task must own all of the data it uses for the same reason why threads are made that way

*When a task is awaiting, it yields control back to the Tokio runtime. If that task is to be resumed on a different thread, all data it holds must be safe to move between threads.If a task yields control at an .await, it must save the state it will use after the .await. If this state is not Send, the task cannot be safely resumed on another thread.

*When you call await on a handle,you have to handle the result of wheteher the task failed or succeeded.You can choose to handle the error manually,use unwrap if you expect it to succeed or use the ? to return control to the caller with the error if it failed but if you call await on an async function,you directly get the variable.

*await is a keyword and not a function call

*join must be error handled in case the thread failed

*async threading unlike async in js doesnt work by reprioritizing tasks to run later in order of their non-blocking/blocking nature at runtime but rather makes async code lazy meaning that any code that is wrapped in an async block most preferrably io tasks will never execute until you call await on it or spawn it as an independent task.If you await it,it means the task is dependent on the waiting result but if the task is not dependent on the waiting task,you can spawn it as an indepenedent task.If awaited,it yields control so that another tokio task can use the thread and when all non-waiting operations are done,the awaited task can go back to that thread and continue executing where it left off.if its spawned,then its independent.tokio will then map it to a different or the same thread where it then executes immediately so that it doesnt pause the execution of the task that called it.

*In js,async blocks are executed immediately upon being called but when a micro or macro task is encountered and awaited,the function will yield control flow to the scope of the caller and if not,js will prioritize/defer it for later and execute the remainder of the async block.This means that js will essentially skip over it and execute the remaining block so that it executes the waiting operation later.

*anything thats wrapped in a promise will be deferred to execute later while anything wrapped in a future wont execute at all till its awaited or spawned as a separate task.async blocks in both languages are syntatic sugar over promises and futures.Since their results are wrapped in both of them,you have to await them to get the result.when you call await,you are awaiting the result not the function so the reason why js executes an async block immediately when called till it reaches a promise or await its because its only the result that gets awaited but in rust,since blocks are expressions,the entire block itself is the result thats wrapped and since the wrapped result is not computed till you await on it,async functions in rust dont compute immediately when called and only compute when awaited.but since js prioritizes tasks,it computes the result when every non waiting operation is done but not tokio since tokio doesnt prioritize tasks.awaiting a result is telling the language to compute the result of the wrapped value immediately so it causes the function to compute in tokio.when you do tokio spawn,you await the task but not on the task that called it but rather as its own task and the result is wrapped in a result and not in a future unlike awaiting an async because it reps whether the task failed or not.A spawned task will not cause other tasks to fail if it does and the only way to get the state of this success is to return it to a variable that is to be awaited.

*correction:tokio spawn doesnt internally await the task because await does two things.it not only eagerly execute the async block but it also yields execution on the thread to another task to execute so since spawned tasks are scheduled to run,they arent using any threads,so they cant be awaited to execute eagerly.it is mapped to a thread but not executed till the thread it was mapped to was yielded so that it can use it.as soon as the spawned task takes its turn on the thread,it executes eagerly.so there are two ways that async blocks can be executed eagerly.if they are part of another task,it must be awaited else if independent,they execute eagerly as soon as they take their turn on a thread.so the return of an awaited task,is the computed result but since a spawn eventually eagerly executes a task,the return of that is a handle which isnt the computed result but the computed result wrapped in a result stating whether the task failed or not

*an interesting feature about tokio is that when you call an async function,the entire body of the function is wrapped in a future and returned to a variable and if its a scope marked as async,the entire body of the scope is wrapped in a future and returned to a variable which is different from normal scope and functions where its only the end that is returned to the variable meaning that the variable now needs to be awaited or spawned to eagerly execute the whole function and the return of that is now the computed result but it differs from js where its only the end thats wrapped in a promise.If js were to wrap the entire function body in a promise and return that,async functions wont execute immediately like they normally would but will be deferred till after everything else is done but is not possible since js functions arent expressions unless its a self-executing function.the async blocks in js are deferred meaning that they will eventually be executed but in tokio,they are lazy not deferred

*since a thread must own all of its data,multiple ownership is the only way for threads to share data as they cant do it by ref as its unsafe since the thread may outlive the task where the variable they ref to lives.so arc must be used.so the use cases of rc and arc are different.rc is for graphically related structs while arc is specificaly for threads

*an async task can be moved to another thread on every await so mutexes must be dropped before the await as mutexes is not send safe.

handle
sleep,join,await



scope,closure,function,async scope,async function.there is no async closure

*if Tokio suspends your task at an .await while the task is holding the lock, some other task may be scheduled to run on the same thread, and this other task may also try to lock that mutex, which would result in a deadlock as the task waiting to lock the mutex would prevent the task holding the mutex from releasing the mutex.Keep in mind that some mutex crates implement Send for their MutexGuards. In this case, there is no compiler error, even if you hold a MutexGuard across an .await. The code compiles, but it deadlocks!

*The safest way to handle a mutex is to wrap it in a struct, and lock the mutex only inside non-async methods on that struct.This pattern guarantees that you won't run into the Send error, because the mutex guard does not appear anywhere in an async function. It also protects you from deadlocks, when using crates whose MutexGuard implements Send.

*The tokio::sync::Mutex type provided by Tokio can also be used. The primary feature of the Tokio mutex is that it can be held across an .await without any issues. That said, an asynchronous mutex is more expensive than an ordinary mutex, and it is typically better to use one of the two other approaches which is the scope and the struct to hold a regular mutex

12.1,12.4,12.5

^bytes type

*There is bytes type from stack allocated types and bytes type from the heap

*The byte data from stack allocated types is a single value which is modified at the bit level since its made up of 1-8 bytes according to the type like u8,u16 or u32.You can directly modify it at the byte level by using byte literals and bitwise operators.But this treats the entire bytes as a value and not a sequence

*A collection of bytes like vec<u8> where each u8 is a byte allows one to modify byte data as a sequence of smaller bytes and not as a whole value.This type of byte is used when the number of bytes grows and shrinks over time since it goes to the heap.A vector of bytes can do this but the Bytes object from the bytes crate is dedicated to handling a sequence of bytes and is more optimized for the task

*The Bytes instance is an immutable view into the bytes data.If you want to modify the bytes,you have to use BytesMut.They allow for optimized manipulation of byte sequences.The bytes type is essentially an Arc<Vec<u8>> but with extra optimizations and unlike rc and arc,bytes guarantees immutability.its best for sending byte data over a network and manipulating files async

*i have channels of different models and i can use enums to structure the different types of commands and put this in a file to create a single source of truth structure

^self contained examples that are distict and not part of a project
^incremental single project example documentation

*If the asynchronous operation runs eagerly, the loop will repeatedly queue a new async_op to run without ensuring the previous operation completed. This results in implicit unbounded queuing. Callback based systems and eager future based systems are particularly susceptible to this.However, with Tokio and asynchronous Rust, the above snippet will not result in async_op running at all. This is because .await is never called. If the snippet is updated to use .await, then the loop waits for the operation to complete before starting over.

*enums can hold unit variants,struct like variants and tuple like variants

*using structs as a single source of truth for all mutex lock uses

*so framing prevents errors during streaming of byte data by defining the possible variants the data being streamed can be.its better than just sending byte data crossing fingers that it doesnt get corrupted.It can cause the data to be silently corrupted.its also used to indicate the boundary of data

*The poll method is what advances the future and determines whether it is ready to provide a value or needs to be polled again later.the poll method is what advances the future. When you call poll, you're essentially asking the future if it can provide a result. If it can't (i.e., it returns Poll::Pending), it indicates that the future needs to be polled again later.When a future is pending, it may register a waker, which is a mechanism that tells the runtime when the future can be polled again (for example, when I/O is ready).

*select runs all the tasks concurrently till one matches the value first and the rest are dropped.it allows you to await multiple futures simultaneously and proceed with the one that completes first

*When spawning tasks, the spawned async expression must own all of its data. The select! macro does not have this limitation. Each branch's async expression may borrow data and operate concurrently. Following Rust's borrow rules, multiple async expressions may immutably borrow a single piece of data or a single async expression may mutably borrow a piece of data.

*The data variable is being borrowed immutably from both async expressions. When one of the operations completes successfully, the other one is dropped. Because we pattern match on Ok(_), if an expression fails, the other one continues to execute.only one handler can execute at a time so each branch can borrow mutably as well.

*rayon is a lib that mainly provides parallel iterators

^note your extensions
^theres cargo add
^dependi vs code,wallaby

^github actions for a cd pipeline

rust gives the js experience where the std library is small and most of what you will need is provided by the community and as such,it has a solid package manager called cargo as pnpm is to js

code lldb,dependi
rayon,tokio,thread api
rayon,tokio,bytes,bacon

rustup,rustc cargo

*to turn a string into a vector for character access,use .chars().collect()

*traits in rust allows you to extend the functionality of any type and create a type thats composed of characteristics of other types

*k-v config files like cfg,toml and property and object config files like json and yaml

terminal user interface

*constants declared with the const keyword are not stored in static storage in the traditional sense. Instead, they are inlined wherever they are used, meaning their values are directly substituted into the code at compile time. This approach eliminates the need for memory allocation and indirection, providing performance benefits. Constants do not have a fixed address in memory and are not stored in a specific memory segment like static variable and because static variables have a fixed memory location,they can be modified

stack,heap,static,no memory

*task is managed by the runtime instead of the os

non-waiting vs waiting

?green threads
?cooperative multitasking is coroutines

?js async reprioritizes tasks
?coroutines yield.manual control

*threading is the os switches execution time between tasks 
*yielding is when the tasks voluntarily give execution time to another task

interrupting,suspending/deferring/reprioritizing

^booking rust owl till when it becomes widely used

*data structures that structure data,those that group data and those that relate data.arrays group,object sructures and graphs relate

^arrays are fixed in size.growable arrays are termed lists or vectors
left type annotation
right type annotation
colon right type annotation

*The reason why the values in a set must be unique is because the same value will lead to the same hash which is like you never added another element.if you could do it,will it cause mem vulnerabilities.sets uses the values to compute the hash while maps use the keys .sets use a hashfunction to compute the index and an array.While the array itself is contiguous in memory, the way elements are stored within the set (due to hashing and collision resolution) means that the actual values can be spread across different indices of the array. The elements may not be stored sequentially.

contiguous memory,non contiguous memory and scattered memory

allocator,gc,borrow checker
*mobile apps---kotlin,swift,flutter,js with react expo
type parser--dto

*const values must be known at compile time and cannot depend on user input or runtime calculations.

*rust doesnt have unions like in ts but rather enums.so if you want something that can be one of many types,you have to use the enum and rust will force you to handle all the cases

pixi js,phaser,babylon,three js

*Accessing elements by get or indexing takes it by ref while using remove does it by ownership.The reference access is safer because it prevents ambiguity or confusion on which element a variable points to if the variable were to take ownership of the element in a vector.rust also prevents moving values out of smart containers and pointers unless allowed by the owership and borrowing rules

*in js,truthy values implicitly evaluate to booleans on if checks but in rust,it must explicitly evaluate to a boolean regardless of whether the value is truthy or not

*when doing an if check on a vector,use is empty and not checking if the length is greater than 0 as it will return different results.

*idiomatic use statements with {} super,crate keyword,self keyword nand the * patter.i can either use the crate keyword or the projects name when accessing the module system from the root.when you declare a module in the main.rs file,it can be accessed anywhere in the codebase by using the code's ms but if modules are declared in the lib.rs file,it can only be used in the rest of the codebase if the main.rs file brings it to its own scope by doing the use project_name::x statement or if they individually get it through the same statement.

*The lib.rs should be used for writing out the module system of your projcet so that the codebase can be reused,be tested since lib.rs files can be tested and not main and create a cleaner code structure by separating the module system from the main allowing the main to only package as much code just to start the program whithout having responsibility of the programs logic.so other rs files encapsulate the logic,the lib.rs declares the module system and the main file wraps all of this to an executable codebase.It also mounts all the modules declared in the lib.rs file into the ms.the lib.rs and the main.rs files are part of the root by default.code in the main will only run if the codebase is being ran as an executable.this is rust version of the if name == main check as it is in python.the crate keyword is for bringing code from the main.rs into the namespace while the name of the crate is used for bringing code from the lib.rs file into the namespace.The main function should not hold any responsibiliry of the programs logic meaning it shouldnt decide much but its should rather combine functions in a way that assembles the program.

*the general go-to codebase structure is the starting script,logic scripts and the entrypoint script.Yhe starting script is where everything is mounted for execution.In react,its the main.tsx file,in nest js,its the main.ts file.Logic scripts are the scripts containing the different logical components of the codebase.in react,it is .tsx files and in nest js,it can be controllers,services,guards,pipes etc.The logical components are normally grouped into features in a feature-structure.The entrypoint file is the main file in each folder under the feature folder.since the feature folder is made up of many scripts,the entrypoint file encapsulates all the scripts in a particulatr feature into a single protable script.in next js,its page.tsx and in nest js,its module.ts.The entrypoint file can also be used to declare the import system of the scripts in each feature as it is required in nest js or the module system to define the module structure of the codebase as it is in rust.

*modules are only accessible to whee they were defined but they are to be required to  be public if its to be used in another file like importing modules from lib.rs into the main script

*i use the * pattern to import all the modules from the lib.rs file into the main file.

*nest js allows detailed control of the route system

*stack is for data that its allocation size is fixed not that the value itself is hardcoded into the codebase and not that the value cant be changed

*you can also do tuple destructuring.Tuples can also be used for returning multiple items from a function.Vectors cant be directly destrcutured so its good shift indexing logic into another function that will return a tuple

*a tuple is used for grouping data of any type but it is non growable.since tuples just purely group data,it might feel a bit arbritary to use when trying to meaningfully group data so tuple struct is used for that.vectors cant take multiple types because of runtime overhead and the only way to go around this is to use an enum of different types althoigh this is only used for preserving type information and each variant takes the largest size of its variant regardless of the actual size of the individual variant

*There’s a tendency among many Rustaceans to avoid using clone to fix ownership problems because of its runtime cost.It’s better to have a working program that’s a bit inefficient than to try to hyperoptimize code on your first pass.

*functions in rust should be mostly used for executing code or returning a value.If we want to return multiple values from a function,using a tuple will be good but if the multiple data returned requires more meaning to it,then returning a struct instance will be better as it structures the data.If it does this,it will be better to use object-based principles by turning the function into an associated function or method of the struct.object principles turns plain data to structured data.

*its possible that the function can fail if the user didnt use the program correctly so a robust error hadling is required.

*panicing is a developer problem when a codebase attempts to use another in a way that will lead to severe damage but for usage,returning a result is better because any operation that will come from the user that may fail will have to be handled robustly with the result type preventing the user's app from crashing and allowing it to continue.The main function can now decide how to handle the erro cases

*a robust error handling check will make early condition checks so that the rest of the function can continue to proceed under safe assumptions.The condition checks should be precise so that on each failure,the program can return the exact error to the user.

*the error value returned by any function is made to be handled by the main function and it cant be seen directly by the user.the best way to display this error is to use unwrap_or_else which is a non panic way of calling unwrap and more idiomatic than writing a match statement.It takes a closure which will print the precise error returned by the function to the standard output and exit the process not panic.

*The process::exit function will stop the program immediately and return the number that was passed as the exit status code.The difference between this and panic is that this unlike panic is user friendly as it doesnt expose any code details to the user and only displaying a user readable message.its a user friendly way of abrupting the program

*the main function sets up the program and handles all the error handling logic.other functions should return an error object in case of possible failure so that the main function can handle it.since the main function is mainly responsible for error handling,other functions shouldnt panic when they fail but rether propagate the error with the ? operator to the main function so that it can handle it.functions like this usually return unit structs or nothing wrapped around the Ok variant on success.This is because the function doesnt return a value we'll need but rather the status of the function.when this function does propagate an error,we dont use unwrap because unwrapping is used when the result wraps a value on success and since this function,doesnt return anything on success,we use if let because we only care about when the function fails.

*the trait object type allows a variable to be of any type that implements a trait.its the variable usage counterpart of allowing any type that implements a trait in function signatures.This is mostly used for returning an error thats one error type of a vast amount of error types.

^the codebase should transport standard messages to a file and only errors to the console

exiting the process,panicing ,result
*We’re also going to change the function name from new to build because many programmers expect new functions to never fail.

concept based vs project based documentation

match case,if let,let else,while let,unwrapping

*the fs module is for operating on the file system as a whole while the File struct in the fs module is used for handling file operations on an opened file in an object based way

*No module will be visible unless declared with the mod keyword.it can be in the root--main or lib preferrably lib or in any other module as a submodule.A feature folder will have many rs scripts and there will be an rs script that assembles all of them together by bringing it into its scope.That rs script is then declared as a module in the lib folder.

^11,12.4,12.5,14
^partial:17,tokio
^18,19,20

!install kali linux

^ascii art

^piping--creating dynamic programs
^game with plugging dangling sockets 

^whats a  linux x server for gui

*packets are like electricity.they need to complete their path for the devices that rely on them to work.packets unlike electrons are just information that are sent as em waves.electricity is giverned by natural laws but packets are governed by protocols like http,tcp,rpc,graph ql

code as object-java and c#
code as procedures--python
code as functions
code as data structures

^good to know:cobol,fortran,prolog,pascal,basic,abc,simula,lisp,ocaml

*queries--database and knowledge base as its in logic programming,querying a codebase with graph ql

^data wrangler extension
^mypy linter
^flake 8 linter
^pyright linter

what to do after submitting jamb exam

*in app purchases,micro transactions
logic programming,functional,data query

information as logic vs data
data--querying,analysis,machine learning

Related data
structured data
grouped data--by sorting,filtering or just grouping
plain data

database vs the file system--structured vs plain data storage
raw query,query builder,orms
compiler,interpreter,jit compiler,transpiler,mapper,macro

method chaining vs piping
tailwind to css--mapping
sass to css--compiled to css

json vs csv
polyglot,transpilation,ffi

structured files--csv,json,yaml,cfg,properties
plain files--log,scripts,text

*classes are just blueprints but in sql,the database is responsible for performing operations on the data
*objects are self contained.They are independent encapsulated pieces of data.The operations of the data and the data itself are in the same object.there is no external runtime performing operations on the data like a database.Objects are like smart data.

minecraft,hytale,teardown,lay of the land,lego fortnite

*Therefore, the only way to interact with an object is through its public API; code using the object shouldn’t be able to reach into the object’s internals and change data or behavior directly. This enables the programmer to change and refactor an object’s internals without needing to change the code that uses the object.

*By keeping data encapsulated,it becomes easier to make updates to the codebase that uses the object because the object is the single source of truth of all operations on that object meaning that the only place to modify the codebase on its uasge of the encapsulated object is only in the object itself and notr the code using it

*a trait in rust is like a class but only for methods.it can have many methods and each of the methods can be abstract or have default implementations that can be overriden or not.A struct object is then composed of traits not that it inherits the trait

*The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called polymorphism, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.

*polymorphism is when you code with any object that has a certain behaviour without caring about what the object actually is.so the use of generics and trait bounds is polymorphism

*Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it’s often at risk of sharing more code than necessary. Subclasses shouldn’t always share all characteristics of their parent class but will do so with inheritance. This can make a program’s design less flexible. It also introduces the possibility of calling methods on subclasses that don’t make sense or that cause errors because the methods don’t apply to the subclass. In addition, some languages will only allow single inheritance (meaning a subclass can only inherit from one class), further restricting the flexibility of a program’s design.

*so this makes mixins(multiple inheritance) and single inheritance less flexible and thats why rust uses composition

*dynamically sized types like str and vec cannot be stored on the stack and thats why variables that uses them are pointers to that data in memory location either on the heap or binary storage in the case of strng literals.A dynamically sized type just needs to be behind a pointer.so &str is a pointer to the string literal in the static storage but the variable doesnt own the data and as such,any ither variable pointing to a literal of the same text points to the same data.they both share the same string literal and its only an imutable reference.But you cant str behind a Box because str is always a borrowed type.if it needs to be owned,String should be used instead

*rust implicitly adds a sized trait bound to every function that uses a generic to ensure safety that every function works with a type thats known at compile time

*rust dont call their object objects.The struct and impl blocks are separate definitions that are associtaed with each other.they are not under one definution as it is in other programming languages

*the difference between code that uses a genric with a trait bound and one that uses a trait object is that generics are expanded into concrete types at compile time.the compiler will look for any definitions that uses a generic and expands it into concrete def at compile time by using type information from the callers.its a form of meta programming. while trait objects are substituted as the code is running making it work at runtime.Except that in generics,if a variable wre to take user input and is to be used in a function,the variable holding the user input must be type annotated so that the function using it as a generic works under safe assumptions while for trait objects variables,the exact type of tha variable isnt known and the program can only work under the assumption that the variable has a particular behaviour but not what specific type it is.

*rust has a cycle method so i dont need to index with modulus to cycle through a vector

*The advantage of using trait objects and Rust’s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn’t implement a method but we call it anyway. Rust won’t compile our code if the values don’t implement the traits that the trait objects need.

*the difference between generics and trait objects is that generics are only allowed in definitions and not variables because rust can expand the definition at runtime into concrete types at compile time but if variables were to take a dynamic type which can take user input,rust cant possibly get the concrete type fof the variable at compile time and thats where trait objects come in.For trait objects,rust will reoslve their concrete types at rutime based on what data type they are pointing to as their values.

*generics and trait objects both allow for dynamic types but generics are only for defintions while trait objects are for variables.

*so rust wont allow me to use a trait object variable if there is only one object implementing the trait,it will encourage me to use the struct directly,if there are more than one,it will encourage me to use an enum of the types that implements the trait.rust makes it difficult to se trait objects because there are work arounds to it.

*the reason why rust was so difficult in allowing me to create trait objects was because rust doesnt allow trait objects that define any static methods which are methods that operate on the state of the object.This is under the fact that a static method is as good as a function and rust encourages the programmer to use generics and trait bounds on those method definitions to have a dynamic type system and declaring any variable that will be used in the function should be of a type that respects the constraints meaning that ruat only allows trait objects for traits that only have instance methods.This is to prevent you flopping when writing your code as a result of ambiguity.This is because using a variable that holds a trait object can become unpredictable later in the codebase if you eventually care about the type that the variable holds as the variable could have undergone mutations that changed it from one type to another as long as the type implemented a trait which can be hard to follow but using an enum of all the types that implements the trait is better because at first glance,youll know the possible types that a variable is.so trait objets are best for variables were you absolutely dont care what the variable type is and just the method it has.

*rust will require that all variables to be type annotated for safety and if a variable must accept user input.rust will require you to call a method on it termed a parse method that will take the user input and return a string or an error ensuring that the variable will always be type safe.If the parsing meythod fails,it is conventional that it returns an erro object rather than panicing so that the caller can decide how to respond to the error.This means that the error must be handled to get the user input out whether by panicing by unwrapping or by recovering from it.So the error you'll get if it fails is a parsing error not one that reuslted because the variable was used in the codebase that assumed that the input confirmed to the type constraints.This is different from other programmin languages that lets your codebase to assume that the input confirms to the type annotation of the variable and will only crash after your codebase used it to a degree.But rust ensures that errors like this are explicitly caught by the programmer by enforcing that the programmer converts the input to the expected type before using it and it forces the programmer to handle the cases of a parsing error meaning that if there will be a runtime crash,its totally expected.The programmer can decide whether to crash the program or not.the only time rust will crash is if the program attempted to do illegal data access.If you want to collect args into a vector,collect will only parse it to strings so far from what ive seen making it safe since every piece of data can be inserted into quotation marks to create a string.its a guarantee that collect will never fail so its always safe.Collect only builds a vector from an iterator to the type that you want if the type is converting it to us guaranteed to parse.so if you want the vector to then become a vec of ints,you have to make a separate vec that maps through the old one and parse each element explicitly and still decide how the program should respond if the parsing fails.rust doenst care if you make it crash or recover,it just ensures that you dont leave the possibility it unchecked.

^correction:generics can be used in variables except that the generic type must be declared in the function or struct def so that code calling it will pass values that rust can check against at compile time allowing for  compile time polymorphism while trait objects types are declared on the variable that uses them allowing for runtime polymorphism.The focus on instance methods on trait objects ensures that  they remain flexible and predictable, avoiding ambiguity.

*stack trace-->file name,line number,call stack and context information as it is in python but not rust

*Rust has modes to increase the verbosity of the stack trace for more details but its more straightforward than in js and python and less friendly as it doesnt provide much information about its context and is not that well formatted.This is because stack traces are for unexpected runtime crashes but since rust has explicit error handling,you dont need a stack trace to tell you where your code crashed as the codebase gives you enough information about where your code may crash so theres nothing unexpected that will become of it undermining the need for stack traces.Rust's stack traces provide clear information about where a panic occurred, but they do not need to be overly detailed like js and python since developers are typically aware of the risks in their code.The focus is on clarity and utility rather than extensive verbosity, which aligns with Rust's philosophy of safety and predictability.the purpose of stack traces is just to identify where errors should be properly handled and because of rust design,this is not needed

*if the error is recoverable,then it can be logged out as a warning to a file or the console,if its something that requires the program to stop,it can be exited without panic by exiting the process and logging out why it exited but only if its critical level that it panics.

*if one wants to do errors as values in python,it must return a value or an exception and not a string to prevent the caller from thinking that he has a valid value.exceptions are objects in python so they wont crash the program unless expliciltly raised and type checkers like mypy will ensure that you check for the type of the variable before you use it providing a pattern similar to rust.

*the errors as value style does come at the cost of verbosity but its worth the benefits.it can save a lot of debugging time.This makes the software more reliable

*error context information is making different types of errors like python that has type error,index error,assertion error etc. to help with stack trace info by reporting the nature of the error while rust stack trace doesnt have this context by default unless you provide custom error types but one will hardly need it in rust.Python ensures that raised exceptions are among its variety of errors making it easier to understand the error

*js lacks this variety and only has a try catch for every error unless explicitly stated making js error handling model the least productive as it can complicate debugging.Since JavaScript does not enforce specific error types, developers often need to implement manual checks to determine the type of error. This can introduce additional complexity and increase the likelihood of bugs.This is why one relies more on logs in js than the stack trace but vice versa in python.

^stack trace,logging,debugging,error handling--by values or exceptions

generic exceptions
structured exceptions--built in or custom
checked exceptions
result type exception pattern

*java uses checked exceptions.Checked exceptions sit in between errors as values and exceptions in that checled exceptions come from functions that return a value or throw an exception and it forces the caller to catch the exception before proceeding.

*rust encourages centralized error handling with the use of the propagation operator ?

*the result type pattern is used to mimic error as value in an exception model language

^pattern vs builtin feature

*its best to create wrapper functions around the methods i call from external libs to use the result type pattern to make a consistent error handling model across my codebase

*there are two ways of doing centralized error handling;by calling the centralized error hadnler or by propagating the error to the parent function that encapsulates the entire app to handle it.

*encapsulation ensures a single source of truth for all state management in an object.the single source of truth pattern is heavily used by redux,prisma and graph ql

*One disadvantage of using an enum is every place that checks the value of the enum will need a match expression or similar to handle every possible variant. This could get more repetitive than this trait object solution.trait objects are best when you really dont care about the tyoe itself but only the method it implements.

*so if a struct has a field that can be one of many types but we only care about the method,then trait objects will make the code less verbose.With the state pattern, the methods on a struct type and the places we use them don’t need match expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.

^take vs unwrap

*encapsulation is not the state pattern.trait objects are used for implementing the state pattern

observer pattern,singleton,builder,encapsulation,result type,factory,template/black box,decorator
^design pattern
^Architectural pattern--mvc,component,feature based

*the state object pattern is where a field isnt of one type but one of many possible types.Its similar to an enum but the difference is that enums are used to hold state variants and the values dont transition or change from one to another once set because of its type annotation while states are objects that can allow transition to other object types because unlike an enum,states only care about the methods and not the type.Trait objects are used for states.generics to can do the same thing but its for polymorphism over the state pattern because since generics expand at compile time,the state cant transution to another type once it has been set making trait objects the perfect tool for this.

*a state is created by defining a single trait and multiple states that implements the trait.they decide how data transitions from them to another and the object that holds a state object knows nothing about the different behavior of the states or when to transition between states.

state pattern,encapsulation,generics

*the state pattern ensures that the state isnt manged by the struct but rather by the individual states

*the difference between an architectiral pattern and a design pattern is that architectural patterns for defining the structure of a project like mvc, component based,feature based etc while design pattern is for defining how to well design a solution in the codebase

*When we create a new Post, we set its state field to a Some value that holds a Box. This Box points to a new instance of the Draft struct. This ensures whenever we create a new instance of Post, it will start out as a draft. Because the state field of Post is private, there is no way to create a Post in any other state! In the Post::new function, we set the content field to a new, empty String.

*as ref and as mut are the method versions of & and mut  & respectively

*unit structs are just markers.I use them to represent states as their own instances over strings

*if a field isnt dependent on a state,it isnt part of the state pattern

*match is better for patterns as it shows my intent of managing states and i can easily handle more states later than changing how i handle the error each time unlike the unwrap family of methods

*the diff between print and println or write and writeln is that the latter adds a newline at the end of the output

*you can use the Any trait in Rust. This allows you to perform downcasting to determine the concrete type of the object at runtime.

*the trait:trait syntax means that trait A extends trait B

*the any type can be downcasted to a concretet type at runtime 

*rust doesnt allow you to deref from an immutable ref because there can be more than one owner.
*we make the transition method take box self so that the last state can return itself because if not,there is no way it can return self and satisy the return type if it took it as a ref and since the method is a trait,we have to change the definition in the trait block which will also cause others to change their def.we can make the last state to return Box::new(last) but since the previous state also does the same,it will reduce clarity

^the take method is to take ownership of a value in a method from an immutable ref without bothering the ownership rules and copying the data.Thats why we wrapped the state in an option.not because it rep a part of the state but because its what we need to implement the state pattern

observer pattern,state pattern

*take is about ownersip and unwrap is about handling

*theres a huge difference between generics and traity objects in how you can use them.if a struct took a genric as a field type,once expanded,the field type cant change to another type that impl the trait meaning that there can only be one type impl a trait thats used in a struct per instance which wont be able to do the state pattern thats why we use traiy objects for runtime polymorphism where the type that impl the trait isnt fixed but changes as the program runs allowing us to create states

^the take method does a move and replace.

*Each state is responsible for its own rules.a state decides how it transitions to a new state
state vs enum

*you van use unwrap if its guaranteed that something will never panic,else use a match case

state rules and state specific behaviour which is when different states behave differently to the same rule.They can behave the same way like transitioning to the next state but produce different results but if they behave the same and produce the same result,then its best to move it to the object struct

*the state pattern is when states manage a field of an object and not the object itself

*i prefer to use rc over lifetimes and i didnt make the relationship between app and device bidirectional because i dont want to maintain the complexity of managing a graph relationship but lifetimes are better because of compile time guarantees but when it comes to graphs,rc is better

*you can alsi use scopes to relax the borriw checker

*With the state pattern, the Post methods and the places we use Post don’t need match expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.

*state,payload-->new state

*the traitA:traitB syntax is used to tell all implementors of traitA to also implement traitB

component vs object/function--the former child can access parent data but not vice versa.a way around it is by passing data in the parent to the child for the child to mutate which will allow the parent to reflect the childs data but will cause prop drilling unless you use a global state management solution.the latter,parent objects or functions can access the data in a child but not vice versa unless a cyclic relationship is created.

linear relationship--a single flow of owners

recursive relationship--single flow of owners but a field can own the same type but its another one

failed cyclic relationships--owner to owner breaks ownership rules.owner to borrow breaks borrowing rules.this is because its impossible to create the relationship without making the borrow mutable so that after creating the two variables to be related,you then use the mutable borrow to make one to borrow the other.But you cant,since you cant mutate something thats already borrowed because of race conditions.

successful cyclic relationship--requires rc and refcell

*rc is good for creating a cyclic relationship where A owns B and B owns A. but i want is that Device owns cpu but cpu borrows the device .I tried to do this as it was spelt by creating two different structs one for device and another for Cpu and made device own cpu in one of its fields and made cpu borrow a device in one of its fields.It works with ownership rules but it doesnt compile because it doesnt work with borrowing rules.this is because i have to make the device's field to the cpu to be wrapped in an option so that it can start as none and after i create the cpu,it can then take the cpu.since the cpu is made after the device,i can make the cpu to directly borrow the device but doing that for the device requires mutation which isnt allowed because cpu borrows device already.so a way around it is to use RefCell in an Rc  but it doesnt create the relationship i want.it makes A to own B and vice versa so i just used refcell which allows me to take the borrowing rules to runtime allowing me to create a cyclic relationship where A owns B but B borrows A.Not only that but i also merged them into one struct to simplify it into a single encapsulation.cpu is now a field of A that borrows A allowing it to manage all of the fields of A without owning A iteself

owner to owner--one must be weak

*the problem about this though is that i cant create two separate impl blocks for cpu and dveice sep sice they are essentially composed the same way.so i have to give cpu its own struct

*so thats what unwrap or is used for.its used for quickly and safely handling none cases.also in ts,when you have a union,you can unsafely downcast it using assertion with the as keyword but rus forces you to check through all the patterns meaning that rust is more type safe than the king of typesafety;typescript

*and i guess there is nothing like default value for parameters unlike ts.this is to prevent situations where the programmer is unaware of the value that is being passed to a function.It ensures that the programmer is aware of all the inputs that will go to a function

*i cannot define inherent `impl` for a type outside of the crate where the type is defined because if i do,i will override the functionality of that type.instead rust encourages me to extend its functionality with traits.Traits can be used to compose and extend types.

*lifetimes can only be underscore in variable annotations but must be specified in definitions

*i figured it out.its not because the ref doesnt get dropped at the end of the scope normally but because i stated that the ref should live as long as the device which prevents any further immutable borrows

*replacing through take and replace can satusy the borrowing rules despite moving

*unwrap takes ownership of the data so you have to be careful of borrowing rules by using as_ref or as_mut

organ rot power
disuse of organs for regen
texture space
a space where changing the state of any mantter is a paradox and results in it compensating by returning a new matter to reflect the state while the original remains intact

*Theres a difference between a method thats associated with a class and one that belongs to the class.i wonder if the one that belongs to the class gets bundled with the object while the other doesnt

*module encapsulation vs class encapsulation

*classes are blueprints.interfaces are contracts.i wonder which one structs are?

*generics with traits create compile time polymorphism while trait objects with traits create runtime polymorphism.

*there is no inheritance in rust,so theres nothing like super in methods.theres only composition which is done by traits

one owner
one owner,one mutable borrow
one owner,many immutable borrows
multiple owners

put the device key in an rc

*rust borrowing rules prevents you modifying the vector you are looping over which will cause unexpected behaviour.

*Unexpected behaviour doesnt mean it will compromise the entire system but undefined behaviour does.System level languages like C++ are prone to undefined behaviour because of the low level access to resources while application level languages like python are prone to unexpected behaviour because of abstractions and hidden behaviour.rust is a language that provides safety for both scenarios

haskell,elm
haskell is safer because of immutability

Haskell is more powerful and safer than elixir
C++ is more powerful than C


*This is object based programming

object literals,class objects
prototype object,class object,rust version

*In other programming languages,composition isnt built in directly like in rust,rather it has to be done by using fields that references other object types.this means that composition in these languages are design patterns and not supported out of the box.

*The difference between a design pattern and a built in feature is that a design pattern is done using available constructs while built in features are supported out of the box.

*in rust,methids are just functions

*Prototype instances,class instances and struct instances.the first one uses object literals,the second uses constructor and the third uses struct literals.the first one can have an interface but its just a contract not a blueprint to construct the instances from.Only the fields are copied and bundled for each object but the methods are lookups/references to their defintions in the class in case of class instances and impl blocks if its struct instances as it is in rust.prototype objects or plain objects have their own defintions because they are not constructed from any class to reference to.

*the state pattern.the child cant modify the parent directly but can still influence it by taking the state of the parent which should be passed explicitly each time and its own fields to return a new value that can be set directly in the calling code.its immutable

reliability,scalability,safety,development time,robustness,performance,flexibility,verbosity,transparency

*rust strict rules heavily influence design decisions unlike ts.The complexity of the ownership model and borrowing rules forces devs to opt for a simpler approach after fighting the compiler.since ts is flexible,it doesnt have much influence on design decisions.The slope of rust software is that it may start with trying to implement a design that will be too complex to implement in rust strict rules making dev initially slow but when you make the painful refactor to a simpler choice,it becomes easier and faster to update not to mention that the code is more reliable.menaing that rust will create a need or may force early refactors that can make the code more reliable in the long run.

one-one dependent relationship.implemented as a linear flow of ownership-->state machine on the child

*i could have used rc for that relationship where device has an rc to cpu and vice versa but i think the state machine is better for this scenario since its just a one-one relationship where a directly depends on b.it wont make sense for cpu to own device,but i could have made the device have a weak ref to the cpu cant outlive it but it means that the device can somehow outlive the cpu if the cpu gets dropped and it wont make sense for the device to be going without a cpu.it must either have a cpu or drop with the cpu which i cant do with rc.if i use string rcs on both sides,it will be cyclic.if i use two weak rcs,then it isnt rc anymore because no one is keeping the count.The owner and borrow would have worked but its almost impossible without fighting the compiler for hours.its very difficult to pull off even basic features of the relationship so i believe the state machine is the best for this but if A and B were relatied but independent then it will make sense to use Rc

*the way a relationship should be implemented in the language should be the best one that reflects the model even though its not the original or intended design decision.

?model,design decision,implementation,architecture pattern,design pattern,paradigm

*Rust forces early refactors.Once the initial refactor is complete and the architecture is well-defined, scaling becomes more straightforward but in ts,there are hardly early refactors and can scale rapidly at first but then coming to a refactor later when it becomes less predictable and reliable

cobol--business oriented paradigm
sql---data query paradigm
prolog--logic programming

english words,programmatic words
cobol,sql--mainly english words

*functions dont have states and can only cause side effect.it can also be purely immutable.a class has states.

kotlin,java,c#,scala,closure
java,scala-entreprise apps
kotlin--mobile apps
c#-casual apps--desktop apps,games,mobile apps,web apps
js---web apps,desktop,mobile,server apps

script,module,library,framework,sdk

.java
.jar
.class
jre
jdk
jvm

entrypoint--main function,class,the class keyword in java and the namespace in c# is the same effect of the mod keyword in rust

entrypoint.encapsulation

*ive noticed two different ways of handling the import system in programming languages.either the file system or a declaration system(what i termed it).the first one is used in python,js and lua where you import scripts directy from where they are located in the file system.the second one which is used in rust,java and c# use a system where you have to declare the script as a module,package or namespace and you dont import their scripts directly but rather hook up the code you want to use from their package/module/namespace system

*in languages where they use file system imports like python,lua and ts,there is no entrypoint function neither a package/module/namespace declaration.you just start writing code directly in the script.I believe the reason for this is because since they use the filesystem for import/export,there is no need for starting your code in an entrypoint of a module you just do it directly but in java,c# and rust,you just dont write code directly in the script.it must always be in an entrypoint of a module/namespace.thats why they start their program with the module declration then the entrypoint to that module where execution of code can begin.this is because they use a declaration system for import/export.in rust and c++,you just start execution in an entrypoint without the entrypoint being in a module because they implicitly make the file that has the entrypoint a module.in rust,since you can only have one entrypoint per project,other scripts cant be implicitly declared as modules and as such,requires the mod keyword

*interpreted languages are called scripting languages because of how quick you can write something that works but it is isnt inherently structured but compiled or jit compiled languages are called programming languages because they are very structured but more complex.scripting languages are the ones that use filesystem imports.they are all programming languages non the less but scripting languages is a term particularly for interpreted languages

*Go uses a mixture of file system and declaration import.you declare the script under a package thats defined by the parent directory but you import it using its path to the package in the package system which resembles where it is in the file system.a single script isnt the package but rather,the package is divided in mutliple scripts.This is slighltly differnt from rust where one script is a module

compiled languages,jit compiled languages,interpreted languages
assembly
C,C++,Zig,Rust
Nim,Go
C#,Java
Python,Typescript

java--entreprise apps especially in banking
java is like cobol--used for entreprise software

*At first glance,macros and functions look like they do the same thing since they avoid repetition but there are subtle differences in their purpose and how they are implemented.functions are reusable isolated blocks of code that take parameters and use those parameters in its scope and are executed at runtime while macros dont take parameters and they expand to the actual code at compile time because they work at the ast level.Functions are for preventing repetition while macros are for writing a better syntax of doing the same thing.functions have to worry about ownership and borrowing rules to ensure they dont affect other code that will want to use those variables limiting the number of things you can do with them.while a macro doesnt worry about ownerhsip rules because it doesnt take parameters,it just uses it to expand into code

entreprise--java,scala
desktop apps-c#,swift
systems apps--c,c++,rust
mobile app--kotlin,swift,dart with flutter,javascript with expo,react native and lynx
web apps-javascript,php
backend web apps--javascript,ruby,elixir,python
scientific computing--julia
data querying--sql
data analysis software--python,r
machine learning--r,python
digita forensics--python
blockchain---solidity
security software---rust,python
taks automation on linux-bash
task automation on windows---powershell
Server/System/Network/Database Admin---powershell
quick scripting---lua
games--c#,C++
embedded systems--python,c
gpu apps---cuda,mojo,bend
cloud computing--go
developer apps/clis--any good programming language
plugin development--lua,teal which is typed lua

niche use case and wide use case programming languages

^note down arcane songs
*a script is just a text file thats marked to be read by a programming language

sql,prolog,cobol,graphql

^chapter 14,macro
raw query,query builder,orm

fs module,the file object

json,yaml,xml,csv,env,toml,property,cfg,ini,txt,markdown

*the structure of a database is on the interaction level but the actual storage is in a more complex and compact format and the database exposes its functionality as queries.You can programmatically interact with a database through a driver or an orm.Serializing data to a file stores the data in the way it is represented in the program like json directly represents how an object is stored,csv for tables and toml or cfg files for maps.if you store data through serialization,the program is the one that directly manipulates the data but for databases,the program doesnt do it directly but rather through the database

file based storage/serialization,database storage

*SQL injection attacks exploit vulnerabilities in the way applications handle user input, not the SQL language itself
zod---input validation.it implements that validaed type pattern

*the only way to be completely invulnerable to an attack is to not have the technology that the attack is designed for.

*xml is for serialiing objects using markup syntax
*json seriaizes objects in an object literal syntax which is c based
*yaml serializes objects in an indentation based syntax

*yaml is mostly used for configs while json is mostly used for data exchange between a server and a client
*markdown is a merge between a markup and a txt file.its mostly used for doc,website text content
*property is commonly used in Java applications for configuration settings.
*cfg is often used for application settings. The format can vary significantly between app as there is no strict standard because of its loose format nature.
*ini is commonly used for configuration settings in various applications, not limited to any specific platform.
*toml more complex and structured than ini

*macros are a form of meta programming

*declarative macro.Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.

*The #[macro_export] annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can’t be brought into scope.

*the $ sign is to declare it as a macro variable
*we use () to capture the entire pattern
*The comma following $() indicates that a literal comma separator character must appear between each instance of the code that matches the code within $()

*declarative macros,procedural macros.

*Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.When creating procedural macros, the definitions must reside in their own crate with a special crate type.proc macro reprsents a sequence of tokens

poe--for general research
perplexity--for more specific research

*In java,the .java file is the source code,the .class file is the bytecode of the .java file.Its an IR of the source code so its platform independent and the .jar file is a bundle of all the .class files into a single file

^databases with rust

*distributing as a dependency or for execution

*Dependency management in js is that you directly install the source code from the registry into your node modules folder as part of your project so that it gets jit compiled when your project gets executed.If you wwant to distribute your code as a frontend app,you use vite which bundles your code into a lightewight js file that can be deployed to a paas like vercel.when you want to distribute your code as a backend, you only ship your source code as it will be too heavy to also ship the node modules with it.This will make it lighter to distribute and youll typically use docker to distribute it so that the receiving end can use docker to install the dependencies.This is for distributing your code for execution but if you want to distriute it as a library,you directly upload the source code to the registry and state all of its dependencies.In rust,when you want to install dependencies,you have to download the source code directly somewhere in the target folder and when you want to compile your code,it compiles that source code with yours into a single exe.You can distribute this exe if its meant to be ran on the receiving end but if you want to distribute it as a library,you have to upload your source code to the registry and state its dependencies.In java,dependencies are installed as .jar files which is a bundle of multiple ir files (.class files) of the source code and the jvm can execute it.Its lighter to get the .jar files over the source code but not as light as an exe but its better because its platform independent.Its dynamically linked which means that its included in the source code at runtime meaning that it will have faster compile times but slower runtimes.C# does the same approach but the ir files are .dll files.C++ allows you to either install your dependencires as source code or compiled binaries(.exe) which can be statically or dynamically linked accordinng to preferences

for python--digital ocean,tutorialspoint,real python
for js--geeks for geeks,turorialspoint,doc
rust--the rust book
c++--cpp crash course that i downloaded

the official rust book
a little more about rust macros
rust reference
black hat rust
idiomatic rust

*pdf attack by embedding js because some pdf readers are in the browser.
*js can freakin hack my browser


*By keeping settings private and exposing methods for modification, you prevent unintended side effects and maintain control over how the internal state is altered.

*my device has a root access field in the settings but because the settings is private ,you cant accidentally change it unless you use methods on the device and the method will reluctantly try to convince you from doing this and if the process is interrupted like if the device battery dies ,the method will panic.so you can only do it if its intentional but even at that ,wont it be better if there was a way to revert from it.so what i'm thinking is that rather than the device owning the settings,it references the settings so that the device doesn't directly modify the settings even in its own methods but rather,the methods on the settings are state machines that return a new instance of the settings with the modifications so that the old setting object can still exist to be reverted to

*so even if the settings field is just a reference and as such,it cant modify the settings,leaving it private is still safer so that they dont change what the device refers to and the method that performs modification on the root field which is sensitive will perform a lot of early condition checks else panic, so that it ensures that it continues under safe condition

*i updated the code because try_enable_root must return the new state of the entire device and not just the settings.so it returns a device with all the root access and priviledges set.the dell can now own this new device making dell to have root access.but there will be a confirmation message before the code assigns dell to the new device and even after that,the old state of the dell is saved in a variable and can be stored in a cloud service for recovery.

*making the enable root method immutable seems like the only way to enable root priviledges on the device and allowing the user to change their mind after it has been set because it operates on a new instance.if the user changes their mind,the new device instance will be dropped so that it doesnt consume memory and it doesnt go to the cloud and the old instance copy is dropped since dell has gone back to its previous state but if the user decides to proceed,the dell will change to the new device but the old device wont be dropped and it will be backed up to the cloud.This is made on the assumption that if the user changes their mind,there is no reason to keep the root version and since the dell didnt proceed with the new device,there is no reason to keep the snapshot but if they proceed,they may later want to revert back

*my model where reading and modifying the settings is done.read operations are chained to the settings function that returns an immutable ref to the settings while direct modifications on the settings are done using the device methods.if you want to modify some parts of the device by leveraging the cpu,you can call any of the cpu methods which are state machines and you can assign the return values to the field of the device its meant for.

*use the trait+trait syntax to indicate that something implements more than one trait either its a generic or another trait

*The Debug trait is meant for developers. It provides a way to format your type for debugging purposes.The Display trait is meant for end-user output. It provides a way to format your type in a user-friendly manner.

io-->stdout,stdin
fs-->File and other file methods,
env-->args

*When you flush a buffer, all the data that has been written to the buffer but not yet sent to the output destination is immediately written out. This ensures that any pending data is processed.After flushing, the buffer is typically cleared or reset, making it ready for new data to be added. 

*In a console application, flushing ensures that messages are displayed to the user without delay.When writing to files, flushing guarantees that all data is saved before the program continues or exits.In network programming, flushing can ensure that data packets are sent without waiting for the buffer to fill.

*so buffers will only transport their data once its full but flushing forces it.io operations like transporting output,file operations and networking implictly use a buffer to prevent constant read/write operations to save runtime performance 

enum state pattern
functionally enhanced enum state pattern/functional enum state pattern
structurally enhanced enum state pattern/Structural enum state pattern
struct state pattern
type state pattern

They differ in their level of centralization and time of execution--compile time or runtime

*In the classic/struct state pattern, each state is represented by a separate struct that implements a common trait. Each struct manages its own transitions and behaviors.The field representing the current state is typically a trait object allowing new states to be added at runtime.Each state struct encapsulates its own behavior and transition logic, leading to a more modular design. However, this can also lead to more boilerplate code and complexity.

*The enum state pattern uses a single type to encapsulate all possible states making it easier to manage state transitions without needing separate structs for each state.The transition logic is handled within a method in the enum, which uses a match statement to determine how to transition from one state to another. This allows you to define the behavior of each state in a centralized location.

*The type state pattern is similar to the struct state pattern in that state is decentralized into multiple structs but they dont implement a common trait and are not under a single struct.Transitioning to a new state requires creating a new instance, often leading to repeated variable declarations.

*the enum state pattern is a compile-time state pattern.its far shorter and easier to read than the struct based state pattern and it creates a single source of truth for all possible states while the stuct based pattern is a runtime state pattern where state logic is decentralized between multiple structs.The choice between the (enum state pattern or the type state pattern) and the struct based oattern is based on whether you want compile time type safety or dynamism.


*for most state problems where you know the exact number of states at compile tim,the enum state pattern is a good solution.Although,one can use the type state pattern if each state has complex behavior that requires a significant amount of code where separating them into distinct structs can improve readability and maintainability.When states are fundamentally different in structure or behavior, and you want to avoid the overhead of fitting them into a single enum.If each state requires unique methods that don’t apply to others, using separate structs can help keep the codebase clean. You can define methods that are specific to each state without needing to handle them in a centralized way.Enums require exhaustive matching when you handle them, which can become unwieldy if there are many states. With the type state pattern, you can manage transitions more fluidly by simply returning new instances without exhaustive checks.

*the problem where: "each state has complex behavior that requires a significant amount of code where separating them into distinct structs can improve readability and maintainability" can be solved if we create separate functions that takes a specific variant that different variants can call once matched to prevent the match from being bloated.the problem where "states are fundamentally different in structure or behavior, and you want to avoid the overhead of fitting them into a single enum" can be solved because each variant can be a tuple containing a struct each with their own structure and implementations.

*In the structurally enhanced enum state pattern, each variant of the enum contains a struct that has distinct structures and methods. This allows for different implementations and behaviors while still being managed under the same enum.The structure and behaviour are decentralized but under the enum.

*The functionally enhanced enum state pattern involves using an enum where the variants share the same structure but differ in their implementations. You handle the functionality in separate functions that are called based on the matched variant.

*while the regular enum state pattern is when the state are the same in structure and behaviour making it completely centralized

*the only difference now between the structurally enhanced enum state pattern and the struct state pattern is that the latter is done at runtime and doesnt require exhaustive pattern matching.and in the enum based pattern,i dont require to implement a trait on the enum,i can just implement the enum directly

*so for states that are known at compile time,you can use the structural enum state pattern unless when you want to prevent exhaustive pattern matching while being ok with multiple redeclarations with the type state pattern

*the type state pattern cant be used in fields under any struct because it doesnt use an enum and requires redeclarations to change to a new type instance meaning that the state can never be under a field because doing so will not allow it to transition because you cant redeclare fields so its for states that arent being read or used by another struct but only functions specifically made for a type can be used on states that use the type state pattern.By using type-specific functions, the Type State Pattern ensures that only valid operations for a given state can be executed, enhancing safety and reducing the risk of invalid state transitions.

*so the choice between the type state pattern and the different enum state patterns depends on whether i want the state to be managed by a function or under a struct.

*the existence of state patterns is the requirement of a state type.A state an immutable type that can transition to other types by returning a new type using itself and payload data as information.

*Introducing dedicated types for specific design patterns (like a state type) would largely be syntactic sugar. It could make the code more readable and expressive, but it wouldn't fundamentally change how state management is handled.If programming languages start adding numerous syntactic sugars for various design patterns, it risks bloating the language.

^I may make a source-source compiler for syntatic sugar to design patterns.it will be shipped as a more expressive option not as a solution to a problem.it depends entrirely on preference and one doesnt have to worry about team adoption because it will turn it to the way many devs implement the pattern using your clear variable names.it is this that you show to the team.it converts this:state Level = High or Medium or Low; to #[derive(Debug, Clone)]pub enum Level {High,Medium,Low,}.

*the primary goal of syntax sugar is for readability and expressiveness not to make the code any shorter or change its functionality.You can use syntatic sugar without knowing the underlying code it generates

*src-src compilers work at the ast level.

poe,perplexity
windsurf,intellisense
tabnine,copliot,sourcery

vscode,visual studio,cursor,firebase studio,zed,jetbrains

*softwae architecture--minimum feature complete software but extended with extensions for customizability
code editor vs an ide

vscode is the linux and jetbrains the windows of the code editing world.vscode supports a wide array of languages and can be tailored for any use case.

node based programming
block based programming

*Although the code might be okay, if the Rust compiler doesn’t have enough information to be confident, it will reject the code. In these cases, you can use unsafe code to tell the compiler, “Trust me, I know what I’m doing.” Be warned, however, that you use unsafe Rust at your own risk: if you use unsafe code incorrectly, problems can occur due to memory unsafety,

*the reason why i dont have to do that module boilerplate like it is in C# and java is because rust implicitly uses the script name as the module.

*It’s important to understand that unsafe doesn’t turn off the borrow checker or disable any other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked. The unsafe keyword only gives you access to these five features that are then not checked by the compiler for memory safety

*In addition, unsafe does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you’ll ensure the code inside an unsafe block will access memory in a valid way.

*wrapping unsafe code in a safe api allows me to call the function without doing it in an unsafe block preventing my entire codebase from being under unsafe.is this called an unsafe leak

*rust warns of using the unsafe block if i dont use any of the unsafe features

*Reserve unsafe for situations where you need to perform operations that cannot be expressed in safe Rust, such as dereferencing raw pointers, calling C functions, or dealing with mutable static variables.Ensure that your unsafe code is well-tested. Since you bypass Rust's safety guarantees, bugs can lead to undefined behavior and its use should be reduced to clearly defined situations

*unsafe rust gives me access to raw pointers.They are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location.Aren’t guaranteed to point to valid memory,are allowed to be null,don’t implement any automatic cleanup



*you can use the raw borrow operator to create raw pointers.raw pointers to local variables are valid because they point to a variable that has valid data and you can write pointers to arbitrary memory addresses by using the assertion operator to turn a platform dependent int size type(usize) memory address into a pointer under safe code because a pointer is just a variable that has the memory address of another variable but there is no reason why you will want to write a pointer like this because the data at that address may be invalid but you cant dereference raw pointers or read the data being pointed to.The reason why creating a raw pointer is safe because it does no harm and it’s only when we try to access the value that it points at that we might end up dealing with an invalid value.Raw pointers allows us to go without the borrowing rules

*the two major times when youll use unsafe code is if you are interfacing with c libraries or building a safe abstraction that the compiler cant understand


*The second type of operation you can perform in an unsafe block is calling unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra unsafe before the rest of the definition. The unsafe keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can’t guarantee we’ve met these requirements. By calling an unsafe function within an unsafe block, we’re saying that we’ve read this function’s documentation and take responsibility for upholding the function’s contracts.

*calling an unsafe function in safe code will throw an error and it requires you to put it under an unsafe code to call it which tells rust that you take the responsibiluty of calling the function and you adhere to the contract

*unsafe blocks should be as small as possible ensuring that only operations that need it are in the block as unsafe operations may not be needed across the whole function body.

*assertion macro panics if a condition isnt met.

*you must call an unsafe function in an unsafe function but unsafe blocks can be wrapped in a safe api,so you can execute them in a safe function

*scopes and closures can access values from their parent scopes while unsafe scopes cant.This restriction is a safety feature. By requiring explicit access to variables, Rust helps ensure that you are aware of the potential risks involved with those variables.Pointers in an unsafe block cant point to variables outside the block.This means that variables in an unsafe block are only made in the unsafe block and arent accessible outside the unsafe block

*performing operations directly on a pointer is pointer arithmetic but accessing the value at that address is dereferencing

*calling code from external languages should be marked unsafe because the code doesnt uphold to rust rules and rust cant guarantee that

^ABI--for foreign function interface
^transpiling for interop
^understand how to call c++ code with unsafe
^ipc for interop

screaming snake case

*static variables space are fixed at compile time but you can mutate them at runtime

*the body of an unsafe function must also be unsafe

*for static variables theres nothing like ownership rules on it.thats why its unsafe to mutate it.because mutiple parts of the codebase can be reading the static variable and the variable isnt responsible for the memory at all.The requirement that references to static mutable variables can only be created via raw pointers helps make the safety requirements for using them more obvious.

*you cant use mutable static variables outside of unsafe blocks

*Whenever we write an unsafe function, it is idiomatic to write a comment starting with SAFETY and explaining what the caller needs to do to call the function safely. Likewise, whenever we perform an unsafe operation, it is idiomatic to write a comment starting with SAFETY to explain how the safety rules are upheld.

^more bout miri

*it is very dangerous to create a pointer to a random memory address

*rust doesnt allow you to directly uses the struct literal if there are any private fields

^Under normal conditions,i cant access any of the private fields under a struct outside of its public methods.But something interesting about structs is that the sequence of the memory addresses of the fields under the struct is tied to the order in which they were defined and according to their types.Fields of the same type use the same base memory address with consistent offsets between them.This means that if i have a pointer to a public field of a particular type in a struct,i can add a byte offset to that pointer to access all other fields of the same type under the struct regardless of whether its public or private.You can add a byte offset to a pointer of any public field to get the memory address of any private field of any type but they arent consistent from what ive seen and it has to be made on observations and feedback.But the interesting thing is that even when the memory address is to the one of the private field after performing the offset,trying to deref it to get the value will only get you scribbles because the type of the public pointer expects one thing but the type at the memory address of the private field is another type.so you get a random instance of the public field type with gibberish data.This can easily be fixed by casting the pointer to the type of the private field.If one attempts to do this,then using a pointer to the struct instance is better because it decays to a pointer to the first field thats a pointer giving you a place to start although you can use any field of your liking but the memory address of the struct feels better so you dont memorize fields.Also,since a pointer to a struct points to the first field that has a pointer,you can point directly to a private field by simply pointing to the struct if the private field is the first field with a pointer.Casting pointers can make the mem addresses incorrect because it may point to the next memory address that has the type your are looking for.Im not sure if this behavipur i stated is globally applied to rust programs or just mine.but all these deductions are based on my observations.All of this is only available under unsafe rust.^This isnt a vulnerability in the struct system,its just common knowledge about how memory addresses work.It will only become a vulnerability if there is a fault in the software's algorithm that doesnt safely handle pointers allowing users to craft inputs that will trick the program meaning that pointer arithmetic is dangerous and the program shouldnt use it to return values.Users can also use a memory address manipulator like cheat engine to directly change the values at memory addresses.This only works for local software and softwares can use anti cheat systems to debunk these methods.The layout of structs can change with optimizations, so relying on specific byte offsets can be fragile.Relying on specific memory layouts can be fragile because any changes in the struct's definition (like adding/removing fields or changing their types) can break your assumptions and my assumptions can fail on another platform.

^these are correct but fragile assumptions


^The only reason why i knew this because i could view the memory addresses in the console looking for the offset between them but for an app that i didnt build,i have to attempt to do this by deref at the addresses using the feedback i get to proceed but this will take so much longer time.


under normal behaviour
From an input basis,you cant attack a simple technology because there is no purpose in attacking it.You cant rewire something that it isnt yours i.e on the server as opposed to the client.
From a rewire basis,you can attack a technology so that others that use it,inherit exploits.--hacking

under unexpected behaviour
you can rewire what you cant own.if i have a sql database,i only borrow it to the client so i cant modify the database its only if i give it input to attack it
if i own it,i can rewire it

if its on the server ,the client cant own it but he can mutably borrow it to rewire it.

normal behaviour is when the user doeesnt directly modify the underlying technology.he only borrows it and gives input that can take advantage of the tech.This is an exploit

unepxected behaviour is when the tech doesnt give the expected output because it has been mutated directly.Cannot happen if its on the server because the user only borrows it.


Something that doesnt perform computation cannot be exploited like a potato.
A technology that performs one computation and performs it well to the letter can be exploited.

A software cannot be more secure than a potato.You cannot hack or explot it.


You dont own the software,you can only own the environment that the software runs on.This creates a mutable shell around it that allows you to rewire everything.

My hypothesis about cyber security:The most secure device is a device that cannot perform computation which is not possible as it will essentially become a potato.Every technology that always give the expected output for a given input can be exploited.a tech that does exactly what you tell it to do can be exploited.An exploit isnt a vulnerability an exploit means it can be taken advantage of.But the exploit in itself is useless because what do you want to take advantage of the technology.its when the technology is used in another software,that it becomes a problem.So every software that uses technologies inherit the exploit of those technologies.If that exploit is leaked/exposed to the client,it becomes a vulnerability.Safely handling the use of technologies in a software prepares against exploits.If you dont have the technology that has exploits,you have higher security than one that uses them even safely because the exploit isnt there to begin with.Every software is composed of exploits.An exploit is a trait that leads to a vulnerability.The more technologies you remove,you remove exploits but the less computation it can perform till it becomes a potato.

*rust has zero cost abstractions meaning that non of its abstractions cost runtime performance

*rust is the modern chad of systems programmig.C++ is bloated unnecessarily and retains a lot of legacy syntax

Swift--apple platform
C#--windows platform
Kotlin--android platform
Dart--android platform
javascript--react native,expo,ionic,lynx

*level of control
C,C++,Zig,Rust,Nim,Go

*easiness
GO,Nim,zig,C,Rust,C++ 

*feature rich
nim,zig,C,Go,Rust,C++
C,nim


*nim is the sytem level brother of python
*mojo is the gpu level brother of python

zig and nim use a single page documentation
rust has a multipage documentation

^legacy syntax vs modern syntax

*automation languages
powershell,bash,applescript

*you can use miri to safe check unsafe code

*associated trait types are used to defer type checking in traits to their implementations over their signatures

*associated types are identical to using generics in traits except that you dont have to supply them on every call to a trait method because its only defined once in the implementation

*generics can have a default concrete type

*rust doesnt allow you to create operators or overwrite them but you can implement them for your types

*we use a default concrete type to extend the functionality of the trait without breaking its implementation

*if you have different impl blocks for the same type but each of them implement a method under the same name,rust will by default call the one directlty implemented on that type over the trait implementations when called.if you want to specify,you have to call the methods in the trait impl blocks with the trait name then the method using the syntax Trait::method(self) syntax.This is similar to the static method syntax.Every instance methods can be called by their static methods.The only time when you do this is to clear disambiguity to the rust compiler.This is termed method ambiguity and its a counter form of ploymorphism but isnt termed counter polymorphism.Using this syntax requires that the method takes a parameter of self whetether immutable,mutably or by ownership.we use the fully qualified syntax: <Type as Trait>::method() if there is ethod ambiguity and the method doesnt take a parameter to self.This is because this situation has more method ambiguity because the trait doesnt know which type implementation of the trait to call.so casting a type to a trait resolves this.

*Traditional Polymorphism: Different types, different implementations of the same method.
*Counterform of Polymorphism: Same type, different implementations of the same method, leading to method disambiguation.

*specifying a trait bound on a trait is called a super trait.The trait that every type that implements another trait must require is called the super trait.The supertrait syntax is trait name:another trait

*It’s possible to get around the orphan rule restriction by using the newtype pattern, which involves creating wrapping the external type in a tuple struct thats local to our crate.There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.The reason why the orphan rule doesnt allow you to implement a trait on an external type is because the external type may have its own implementations of the external trait and if you implement an external trait on that,you will end up overriding it.The only safe operations are implementing an external trait on an internal type because the internal type doesnt have any implementation yet of that external type and implementing an internal trait for external type is also safe because there is no way that the external type implemented your local internal trait.The newtype pattern ensures that the external trait on the external type is converted to an external trait on an internal type.But the wrapper wont inherit the traits of its inner type unless we impl the deref trait that derefs the wrapper for us to call vec methods each time we use it.But if we want to be specific about which ones we want it to implement,we have to do it manually

states,units
newtypes--type aliases or tuple structs
type aliases-for providing simpler types over other ones and for adding units to our types

newtype pattern achieves a lightweight encapsulation

*custom types vs type aliases

*type aliases arent treated as new types so they are treated as their underlying types.However, using this method, we don’t get the type checking benefits that we get from the newtype pattern discussed earlier. In other words, if we mix up Kilometers and i32 values somewhere, the compiler will not give us an error.This requires operator overloading to specify how the specific type should be treated

*the point of type aliases is to reduce repetition and increase readability and expressiveness.You can also put a genric in the type alias

*the ! type is for types that never return.Functions tha return this are called diverging function
*the continue statement implicitly returns never.It can be used in match arms despite that match arms requires that each arm must return the same type because ! can never have a value and thus,rust decides that the type of guess is the one from the rest of the match arms.This decision is made because continue doesn’t return a value but instead, it moves control back to the top of the loop

*the panic macro has the ! type

*the two places the ! type is used is for the continue statement,the panic macro and a forever loop block because a forever loop will never give control flow back to the program.

*Void is different from never.In rust,unit structs termed as void in other languages refers to a function that returns a value while never means that the function will never return

*a slice is a structure that holds a pointer to the first element and the length of the slice as usize types.Usize is a platform dependent unsigned type.It is a reference into a collection.A slice will always be twice the size of an usize.

*indexes and memory addresses are of the usize type

*a trait is a dynamically sized type because different types that implement the trait can be of different sizes.we cant directly store dynamically sized types in a variable,we can only store a pointer in it to its location in the heap where it can grow and shrink in size at runtime.

*so for heap allocated data like vec and string,the sizes are dynamic but the allocated space for each memory block is predcitable and consistent at compile time but for trait objects,it isnt possible because of ambiguity.there is not enough information to know which type will implement the trait and as such,rust cant make consistent memory blocks for this type on the heap.So rust decides at runtime which type it points to and the allocator can use that type size to create the memory blocks for that type.This overhead is done at the rust level because the allocator always needs to receive predictable memory block sizes for a given type explaining why i have dyn trait.When you create a Box<dyn SomeTrait>, it contains a fat pointer with two parts:A pointer to the data (the concrete type implementing the trait) and a pointer to the vtable, which helps with dynamic dispatch for method calls.

*so is the reason why i cant have vec<dyn trait> is because despite that vec is dynamic,vec expects that the memory space for each block on the heap must be known at compile time and dyn trait isnt compatible with that but i can have a Box<dyn trait> because Box unlike vec is prepared for when the memory block will only be known at runtime. another interesting thing is that i can use vec in place of box to do recursive types because the type has a fixed memory block use but box is used for convenience as it only points to one value.

*Box can become a fat pointer

*Vec<enum> type where the enum is a variant of many types allows for heterogeinity but it only preserves type information.each variant of the enum still takes up the space of the largest variant making it take the same memory as a vector of homogenous types but a Vec<Box<dyn trait>> is the solution to the memory part.the problem here is that even if the elements only take as much space savings as they need,there is extra 40 bytes per element because of the fat pointer and allocator overhead.This dangerously increases the space complexity.so Vec<Box<dyn trait>> is used for polymorphism not memory efficiency

*so a slice is an array but it doesnt have a fixed memory size and can grow only because its normally a ref into a part of another collection like a vector or string and thats why the notation is &[type] while arrays are fixed sized collections meaning that they go to the stack and their syntax is [type;number].The addition of number is because arrays are fixed in size and because of stack overflow,we can use box to move the arrays to the heap to become Box<[type;number]> and this will be more runtime efficient than a Vec<type> because the boxed array only gets allocated once as it allocates all the space it needs in a single request while the vector will constantly reallocate if the size of the items exceed the capacity.while Box<[type]> is a slice but because its boxed,it means that its stored on the heap and the variable owns the data removing the & operator that signifies borrowing and since slices are not fixed,the boxed slice can increase in size and since the slice is a view to a vector,we can create it from viewing into a vector and cloning the vector to an instance that Box<[u8]> will own causing the allocator to allocate a large chunk of memory while still allowing it to increase in size

*so data types in general have default allocation strategies like i32,bool,char,arrays,structs,enums on the stack but Vec,String and Hashmaps on the heap but one can use Box to move stack values to the heap allowing for allocation strategies that can create recursive types,accept dynamically sized types,extend lifetimes,ensuring that stack data is not copied by ensuring ownership for efficiency and taking advantage of the properties of stack variables when they go to the heap for runtime performance making Box the rust way of controlling allocation.Other smart pointers like rc,refcell,arc,mutex,cow,weak are all variations of box but for other use cases

*By default, generic functions will work only on types that have a known size at compile time. However, you can use the special syntax ?Trait to relax it.A trait bound on ?Sized means “T may or may not be Sized” and this notation overrides the default that generic types must have a known size at compile time. The ?Trait syntax with this meaning is only available for Sized, not any other traits.Also note that we switched the type of the t parameter from T to &T. Because the type might not be Sized, we need to use it behind some kind of pointer. In this case, we’ve chosen a reference.

*Function pointers implement all three of the closure traits (Fn, FnMut, and FnOnce), meaning you can always pass a function pointer as an argument for a function that expects a closure. It’s best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.

*variables that their values are functions are function pointers and they have concrete fn pointer type annotations.

*Closures are anonymous functions that captures values from their environment.Variables that points to closures can be type annotated as function pointers provided that they are fn trait closures meaning that they dont capture values because they wont have the isolated nature of normal functions if they were to capture values from their environment.In function definitions,if you want to accept a closure,it has to be a generic that implements the respective closure trait and if its a return,the return type must use the impl trait syntax to state the function returns a type that implements the trait since closures dont have a concrete type.The reason they dont have concrete types is because each closure that captures a variable has a unique behaviour that cant be type annotated.Instead of having a concrete type, closures implement one of the Fn, FnMut, or FnOnce traits. This allows them to be treated polymorphically, meaning you can use them in contexts that require any function-like behavior without needing to specify an exact type.

*functions can accept generics that implement a trait,they can return any value that implements a trait and trait objects can be used for any type that implements a trait


declarative macro
procedural macro--function like,attribute like,derive like
using extern for ffi

asm and sql macros

11,14
12.4,12.5

testing,macros,tokio

pointers
allocators
smart pointers
ownership model
reference counting
garbage collector--ref,tracing
tunable garbage collector
auto free engine---no extra runtime like the gc.the variables arent deterministic like owners in rust.doesnt enforce rules like the rust borrow checker but places free where it believes it can safely be freed.its done at runtime so theres zero runtime overhead.the ownership model prevents memory leaks and dangling refs but the borrowing rules prevents race conditions

allocation strategies--compile time and growable heap allocation
*cloure

*ui languages

signature based detection
heuristic based detection
behavioural based detection

*low level access isnt root/kernel access

*so signature based analysis is when the antivirus scans the compiled binaries of the files and compare it to known compiled binaries that are malicious.it works only on known viruses and cant adapt.Behavioural analysis doesnt check the file itself but runs it and watches how it runs for any behaviour thats typical to malwares like attempting to access critical parts of the system while heuristic analysis examines the compiled binary for patterns known to malware but not exact matches to signatures

*malwares can evade signature detection by the following:
Malware can modify its code each time it infects a new system. This means that while its behavior remains the same, the actual binary signature changes, making it difficult for signature-based detection to recognize it.

Similar to polymorphism, metamorphic malware rewrites its own code entirely upon replication. This can lead to significant changes in its structure, making it even harder to detect.

Malware may encrypt its payload and only decrypt it in memory during execution. This means that the signature of the encrypted file appears benign, while the malicious behavior occurs during runtime.

Malware authors often use packers to compress or obfuscate the malware code. When the packed malware is executed, it unpacks itself, which can change the signature during the unpacking process.

*a code editor is a text editor supercharged for coding
visual studio,vs code,sublime text,jetbrains ides

*ml libs use c++ but they expose their functionalities in python
^ill try to make the auto free engine in rust as an experimental alternative to the borrow checker for rust code.

*so in user mode,any memory that isnt freed by a program will remain till the program exits but in kernel mode,it will remain till the system reboots

*Virtual memory is what prevents a program from pointing to the address another program is using.Each process runs in its own virtual address space. This means that the addresses a program uses are not directly tied to physical memory addresses. Each program believes it has access to a complete range of memory addresses.The operating system maintains a page table for each process, mapping virtual addresses to physical addresses. When a program tries to access a memory address, the CPU uses this mapping to translate the virtual address to a physical address.If a program attempts to access a memory address that it does not own,If a program attempts to access a memory address that it does not own.this typically terminates the offending program. This isolation helps prevent malicious or faulty programs from interfering with each other's memory, enhancing system stability and security.If one program crashes, it does not affect the memory space of other running programs.

*virtual memory is an os service

*In user mode,my program runs directly on the cpu but any form of resource access is done through system calls to os services

*Sytem level and app level languages have the same level of access i.e they both operate in user mode but the difference is how much they expose this access to the programmer.

*so to get things straight,programs run directly or indirectly on the cpu.Compiled programs run directly on the cpu while interpreted programs run on the interpreter but the interpreter itself runs on the cpu.The cpu just executes instructions but cannot execute instructions that interface with hardware resources.That functionality is managed by the os.The os is the complete software that allows software to communicate with the hardware.Its composed of system call,the kernel,device drivers.The device drivers are the closest to hardware you can get.They directly make commands specifically for the hardware that the computer uses as specified by the manufacturer.Because of how sensitive this is,it exposes its functionality to the kernel as a kernel api.The kernel uses the api to communicate with the device drivers.Its the part of the os that handles all the responsiblities concerning the hardware resources of the computer while each device drivers focus on a single responsibility.The kernel then exposes its services safely to programs through system calls.Programs can run in two modes;user mode and kernel mode.A user mode program uses system calls to safely interface with the hardware while a kernel mode app uses the kernel api provided by the drivers to interface with the hardware which operates on the same level as the kernel which is dangerous because the kernel safely handles the kernel api while the program may not.A kernel mode program is a kernel driver.all programming languages have the same levelof access to hardware but they expose this access at different layers of abstractions.They group multiple system calls that are probably written in asm into a system library.A system library is a collection of system calls provided by the programming language as a standard library to the programmer to make it easy to request os services.For example,a vector creation in rust is probably loads of system calls but exposed as a safe and simple api that makes it difficult for it to break but for assembly,you make barebones system calls.So the level of hardware control is System library--->System calls-->Kernel--->Kernel Api--->Device drivers-->Hardware

*programs are compiled to target two types of platforms;the os and the cpu.So for a program to be cross platform,it has run on many cpu and os platforms

*one can use system calls to programmatically do all these things.so is a utility software for packaging what one could have done programmatically into a software that makes it eaiser to interface with

user mode system software
kernel mode system software

cpu--registers
disk--os,bootloader,fs
Ram
Rom/flash memory
buses
motherboard

instructions are sent from the device driver to the hardware through a bus

*When a program is opened,its instructions are mounted onto the code segment of the ram and the cpu reads from the instructions from there.The initial values of static variables are baked into the compiled bin of the program and once it starts,it goes to the data segment of the ram where it remains globally available

*The ram is made up of the code segment,data segment,stack,the heap and the os creates multiple virtual rams complete with all the types of memory for each process that are all mapped to a single ram by using the page table.Each process has its own page table, which keeps track of which virtual pages correspond to which physical frames in RAM.

disk is split into partitions or divisions---boot loader

*rom contains firmware.which has the bios.It boots the hardware devices when the computer is turned on and it loads the bootloader from the disk into RAM to start the operating system.

firmware is a software thats embedded into a hardware like the bios.It contains the most basic functionalities of the hardware that device drivers can leverage.it goes to a non volatile memory like the rom or flash memory.Its not baked in

*A device driver communicates with hardware directly but leverage firmware if present

cpu uses buses for port i/o

every hardware device exposes an address which can be either a port address or a memory address

Hardware devices have registers, which are small storage locations used to control the device and hold data.

*so device drivers communicate with the hardware by using memory io or port io.Every hardware has data and control registers which have two types of addresses;a memory and a port address as specified by the manufacturer.For memory io,the cpu already has a range of addresses to access as specifed by the address bus width.when the cpu wants to communicate with any hardware,it directly reads and writes to the memory address of the hardware registers and the address bus transmits this signals to the hardware with the right address.it simulates a ram access to the hardware.Hardware registers also have port addresses but the addresses are not directly accessible by the cpu but rather,the cpu uses particular io instructions that leverage data buses to send data to the hardware that has the right port address.Unlike hardware devices, RAM does not have control registers because it is a passive storage medium. It doesn't perform operations on its own; instead, it simply holds data.Control registers in hardware devices are used to configure and control the device's operation.This means only hardware devices that can perform operations on their own that have control registers.memory io for hardware devices that are internal to the computer like disks,rom while port io are for devices that accept user input like keyboard or give output like monitor

*so hardware devices have some processing abilities but they are super specific in what commands they can accept and its only the cpu that can run various interactions leveraging specifc commands for different hardware devices.what the cpu is at the fundamental level is an orchestrator of hardware commands but the cpu can only understand binary because hardware devices only understand electricity and binary is a mapping to electric signals--on and off

cpu is made up of the alu,control unit,registers

*so the alu is actually the part of the cpu that performs computations.it has the simplest form of computations which are arithmetic and logical operations.the control unit reads the instructions from the code segment and feeds the alu and the alu delivers the outputs to registers.It also communicates with hardware through memory addresses by fetching instructions, generating addresses for data access, and sending control signals to manage operations.

a calculator is an embedded device
embedded devices-mini devices that have the simplest of hardware--arduino,raspberry pi


*The law of composability is that simple units that can only do a finite number of things at the most basic level can be combined to perform complex operations.like the cells in living organisms and instructions in computation

cpu architecture

*so hardware devices are electrical devices designed for computation but in the case of embedded devices,they are just electrical devices except for the micro controller.hardware can only understand electricity in both cases

*so markup is for the structure of the document and stylesheets is for the presetation and visual of the document 

*div is used to break your document into divisions

markups are turned to the dom which is an ast of the markup

lexer breaks the code into tokens
parser brings the tokens structurally to construct an ast
the semantic analyzer checks if the ast is syntatically and meaningfully correct
code generator converst the ast to an ir
The optimizer optimizes the ir for efficiency
code generator converts the optimized ir to asm
an assembler converts it to machine code

*when building a compiler with LLVM, developers primarily focus on the lexer and parser, while leveraging LLVM’s IR for code generation.

*in memory and file data structures.asts are an in memory data structure

*The ir is the level between high level src code and asm but ist not meant to be hand written.it serves different purposes depending on the nature of the language.for compiled languages,its used as a target to perform optimizations that will be tedious or ineffective at the asm level and not possible at the source code level.for jit compiled languages like c# and js,its used to ensure cross compatibility of code.for browsers,web asm is an ir to allow for interopability across languages in the browser and for interpreted languages like python and lua,its directly interpreted.

gpu asm
gpu shading language
gpu parallel language

*so processors are hardware devices that can perform fundamental computations to execute an instruction.CPUs and GPUs are the two kinds of processors but GPUs are specially designed for parallelism and rendering graphics without having the hardware orchestration of the CPU

*so the two types of gpu languages are shading languages and parallel processing languages.Shading langs are made for rendering graphics at high quality while parallel langs are for utilizing multiple gpu cores for processing.Glsl and hlsl are for shading and mojo,bend and cuda are for parallel processing.glsl,hlsl and cuda have a C like syntax making them the gpu counterpart of c
asm

hex binary
different java jit compilers---libjdk,oraclejdk

?directx,opengl,web gl
three js,babylon js

*so the three types of ui libraries are markup/component based ui,imperative widget ui and declarative widget ui.Markup/component based ui is when the ui is defined in a markup-like syntax tailored for a particular language like jsx for react and XAML for C#.They bundle the markup and the code that makes it interacive into reusable components.The markup and the code can be in separate files like in c# or together like react which i believe its the only one that puts them in a single file.Js,C# and Kotlin use this approach.The widget architecture is where the ui is a singleton object.The two approaches to this is the imperative or declaratove approach.The declarative approach is when the ui is written as an object tree in its literal notation form which looks more programmatic than markup.They are composed in a hierarchy.Flutter and swift employ this approach.while imperative widget architecture is the same as the declarative version where the ui is an instance of the widget class but its not written as an object tree but rather different instances of differnt widgets are added imperatively to the main widget instance.Python gui libs like kivy and pyqt do this approach although kivy also provides a declarative approach that uses a format that resembles markup but with indentation

react native,expo,lynx,ionic

dart is mostly known for flutter and flutter can make desktop and mobile apps making it a good UI language

Ui development languages--C#,Flutter,Javascript,Kotlin,Swift

*c# is mostly for ui development,after that game development and after that,backend and entreprise development 

*so the language to start to get bugged down to computer fundamentals is python.the best for those that want to start with ui development is either js,c#,flutter,kotlin or swift.If they want to get to web ui,js is the best,if they want to go for desktop ui,then ill say c# even though you can use js to build desktop apps but c# is more specialized for this.if they want to go for mobile dev,then kotlin.its their pick based on what platform they want it on or swift although js and c# can do this cross platform but mobile app isnt their main focus.If they want ui development in general whether mobile or desktop,then flutter will be the best because its 99% a ui language although c# is more dominant for desktop apps.If they want a language that will teach them the fundamentals from the system level,ill say they should start with either python or a ui language first because new devs will want to start with getting faster feedback cycles then,they can transition to system level langs if the details matter to them.if they want to start with game dev but also the computer fundamentals along with it,ill say c# over godot.because godot assumes some programming skills before learning their engine although beginner friendly.They can later go to C++ if they are interested in system programming for game dev.

sectional divisons and semantic dvisions of asm code

asm is instruction and operands like a + b but with an infix notation like add a ,b
instructions are cpu instructions that perform the most basic form of computation just like how arithmetic operators perform the most basic form of maths.

operation,registers,data

directives

there is a difference between learning programming from the mathematical aspect and from the engineering aspect

linuxfromscrath nasm assembler

register operand,memory operand,literal operand

*msys2 a package manager for system level languages

^i installed nasm and the c++ compiler by using msys2
*to make a language support extension,i have to make a lexer for a syntax highlighter and an lsp for intellisense.

^To get asm working,i installed nasm in msys2 to assemble it into an .o file and used gcc in mingw to link it to an exe and then executed it.

*i installed gcc and nasm in msys32 but i can only use both of them in msys64 because the bin files went to msys 64


*shell scripting--chaining multiple cmds to supercharge my workflow when doing something by automating tasks
^I ended up creating a powershell script to automate the entire thing as well as task.json in vs code so that i dont have to change the filename or dir each time.there is also terminal keeper for automation in vscode.

Task.json and terminal keeper are an in ide automation tool

^environment setup is annoying thing to get especially for js and asm.powershell is used to automate environment setups.

*pub use is used for reexporting an item that has been included in ypur name space.this allows you and others using your code to easily access the item you want deep in the module hierarchy without changing the module structure

*a library that is made up of multiple seprate libraries is called a workspace

^lldb and gdb are the debuggers for system level languages.code lldb integrates lldb in vscode

*i use lldb for rust,c++ because i can use it through vscode gui
*i use gdb for asm because i vs code doesnt allow me to set breakpoints in asm and has no gui support for debugging asm so i am stuck with the terminal thats why i use gdb for this

*The incremental folder is part of Cargo's incremental compilation feature, which aims to speed up the build process by only recompiling parts of the code that have changed. Here’s how it works.

*rust has incremental compilation making build times faster.

^Assembly is much simpler than most programming languages, learn the basic operations and registers and that's pretty much it. The hard part is keeping track of all what’s going on in your head and understanding the hardware

^uno edit

^The problem is that assembly language itself is deceptively simple

^many of today’s programmers have grown up with fast CPUs, whose speed has made up for poor coding habits and, as such, many of these programmers have never had to learn how to write fast code.

^Code optimization
^Algorithm optimization--optimizing the implementaion or choosing a more efficient algorithm

^Time complexity is important.

^DONT FORGET MY FORWARD COMPATIBLE PLUGIN SYSTEM

^Virtual file system

^msys2 is my best package manager.i installed c++,lua,nasm and gcc easily with it without looking for the individual compilers.

time complexity
space complexity
cyclomatic complexity

task.json and powershell

void,null,undefined,never

task.json,terminal keeper,code runner
powershell


custom css and js,token color customization,copying an extension folder

*language support in a code editor is just an extension that provides syntax highlighting and intellisense for the language and a code runner that when you click the button,it runs a cmd to run the script

preprocessor,compiler

^dummy require--used for getting intellisense without the line escaping to the compiled script.no runtime required.

^i want to make a dynamic timer variable for js so that sleeps will be faster.its done by subtracting runtime from the initial timer that was set giving the illusion that js ran in multiple threads in addition to its async behaviour

tradeoff visualizer
mimal vector layout

daylight song 

i can learn digital design through redstone
i can learn a bit of engineering if i want with the create mod

*game engine architecture
*plugin architecture

^rust is my main system level language for making system software exposed as tauri apps to create that fancy react ui

mlua provides interoperabilityu between rust and Lua by embedding an interpreter
Tauri provides interoperability between js and rust
I will just use a web server for python to provide interopability between it and rust

^Godot rust

shading languages
spline,blockbench,blender


godot and forge--a node or class that extends anoter with its own script attacthed to it
react--a function that returns a node


!I HATE OTHER PEOPLES SOFTWARE!!!!


auto save,stage,commit,branch off,revert

task manager forcefully terminates a process while quitting the app normally allows the app to do other things before terminating

hydrangea
monokai stone

Godot,Vscode,blockbench
Vscode,browser,api client

scene,nodes,properties,script,function

*as soon as im done learning godot,ill move to using rust for my godot games.
rust for system software,security software,tauri apps,godot games

game dev is a side journey.my main journey is python,ts and rust so ill learn rust but godot on the side

*The T-pose

*parent rigging changes the original organizational structure of the model.it saves hours of work

the cubes are not named but the groups are anatomically

bones that are for animation are prefixed with piv_ while those that arent arent prefixed with anything to prevent ambiguity on which bone to use to animate

so the direction of parental rigging depends on the anatomy of the model

flip and reversing keyframes

*self learning-course-post course effect
*application plateau/project paralysis
*Grass is greener syndrome/language hopping
*Course Project Disillusionment/false perception of project difficulty because of a course
*Competence illusion effect/Grinding leetcode in place of solving problems
*expertise dilution/being a generalist
*learning paradox
*tutorial hell
*imposter syndrome

course difficulty vs industry difficulty

awareness paradox
metacognition

scratch,java intro,lua intro,java intro 2,,html,lua,c++,go,python,c++,digital design,web dev,rust,asm,godot

ai pair programming
peer pair programming

the urge to escape frustration while remaining in programming often manifests as language hopping

Novelty Seeking: New languages provide temporary dopamine hits ("This syntax is cleaner!") without requiring deep mastery[^search3][^search6].

 Each new language resets your mental models, wasting time on basic syntax instead of solving harder problems

 leet code is a supplement

 *T-shaped developer vs generalist.has only one vertical bar(knwoledge by depth) and other horizontal bars(knowledge by breadth)

 *so js should always be the first choice for projects and adding others only when necessary as superpowers since im choosing js as my core expertise. This is the "JavaScript First, Superpowers Second" 
 
in programming languages,names in themselves dont do anything.they are just there for readability and expressiveness.the true behaviour of a program is by the values and how they are used in a program except in cases of strict conventions but these conventions are not requirements but more like a contract and other certain contexts

keyboard input is listened by keybinds

*keyframe editor and parental rigging reduces frame by frame animation

eggplant
eol