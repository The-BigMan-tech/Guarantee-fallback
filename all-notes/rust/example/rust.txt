so macros are like functions for reusable blocks of code but macro genrates the reusable blocks at compile time unlike functions that gets called at runtime.this allows for compile time optimizations and can generate different code structures based on the input unlike functions that have a fixed structure

When a macro is invoked, it expands into code at the call site. This means the generated code can be different for each invocation, leading to more efficient and tailored output.

Functions: Always call the same block of code regardless of how they are invoked, which can lead to performance penalties if the function is called frequently.

macros give a more expressive syntax

functions have a fixed signature while macros signature are flexible to syntax patterns although function overloading in langs like ts,make function signatures flexible based on input and generics with union types makes return types and input types very flexible

functions can also take a varible number of args by using the spread operator

function overloads are resolved at runtime while macros expand into code at compile time allowing optimizations

Macros are generated at compile time which can prevent errors early rather than functions throwing errors at run time when the wrong args are passed

cargo is the package manager for rust and its cargo.toml and cargo.lock as oppossed to package.json and pnpm-lock.yaml or packagelock.json as it is for js files.This is called local project management.Its better to install dependencies for a particuar project rather than globally on the file system.pip does this globally i believe and thats why there is somthing called virtual environment

the dependency file is for specifying the packages and the versions a project uses while the lock file is for ensuring that the versions of the dependencies remains consistent regardless of the environment

toml and json files are for project management
cfg files are for settings for an app or a tool
yaml and json files are for serializin data

dependencies in rust are called crates as it is called node modules in javascript

lock files are managed by the package manager while the dependency files acn be manged manualy

*ill use rust to convert the size of my compressed array to a smaller size by representing chunks in the smallest byte representation possible for that chunk rtaher than having a consistent size across all chunks

*Dont need pinno for logging,the vscode turbo console log extension is far superior as it automatically creates detailed log messages and can adap it when the code refactors.Its a log manager

js is interpreted by the browser,so it can run directly in the browser
js in frontend frameworks have to be compiled by the frontend framework into regular js dom manipulation and then bundled into on js file with a web bundler like vite before running it on the browser.
running js standalone requires node js 
ts needs to be compiled to js files before its ran in the browser or node js envirnonment

since rust is a compiled language language,it has to get compiled into an executable before it gets ran

cargo build
cargo run
cargo clean
cargo check

cargo build emits the executable in the target/debug folder for quick re-editing while cargo build --release builds it as a final program for use so its slower so only use it when the final build of the program is ready.

"General learning material for Language X" is a completely different scope from "Teaching the basics of programming using Language X". The former is suitable when you are a beginner to the specific programming language but not to programming in general, whereas the latter is required when you are a beginner to programming in general.

react requires that states must be immutable and editing them should return a new value which reps the current state and not directly modify the state itself the same as rust

*rust is one of those languages that uses an entry point function called main.It also uses curly braces to create blocks over indentation and it uses semi colons as a line terminator

*intellisense is provided by a language server

*compile time erros means that the program isnt safely doing what its suppose to do yet.

*In js and python,variables are mutable until explicitly declared immutable stated while in rust,variables are immutable by default unless they are explicitly declared mutable

*in c++ and rust,printing to the std output must be in a string literal.I belive that python and js do this under the hood by an abstraction

*constants are immutable together with the fact that they must be annotated and they can be declared in any scope and the value of constants must be known at compile time instead of run time like immutable values meaing that the values of constants must be hardcoded while immutable variables can be assigned the values of other variables upon declaration

*constants are best for having a single source of truth for all the hardcoded values that will be used in your program and it also makes them more readable while immutable variables are for enforcing safety

*You cannot change the type of a mutable variable

*Shadowing is redeclaring a new variable with the same name as a previous variable.This means that the new declaration shadows the old one and takes precedence.It is used when trying to change the value and type of an immutable variable without actually mutating it because its actually declaring a new varible but with the same name.This ensures that the variable always remains immutable across changes and it also prevents the need for creating many similar variables but with just different names.Its a false sense of mutation.It can be considered as a safer alternative to mutation

*Mutation means changing the value of a variable after its declaration while shadowing doesnt.

*Immutability leads to predictablility as seen in react and redux and its the same for rust.

*integer,float,boolean and character

*Unsigned integers are guaranteed positive integers while signed integers may be positive or negative
*You can use _ as a separator for long integer values and you can suffix the type of a variabe that holds an integer with the type in front of the integer

*when an integer overflows,it can cause two things:if its in debug mode,it will panic and throw an error but if its in release mode,it will wrap around the given range which is also an error.

*i,u,f

2^(n-1) is the formula for calculating how many numbers can be produced with n bits.

*boolean values in rust are one byte
*there is unicode and ascii way of representing strings or characters just like python because unicode can represent a vast array of characters including emojis

*chars use single quotes in rust while strings use double quotes

*tuples can be unoacked in pythin and rust as arrays can be destructured in javascript

*arrays,tuples and vectors.Tuples can be composed of any types while arrays cant and arrays are fixed in length

*an array is a fixed large chunk of memory allocated to the stack

*in python functions arent hoisted but they are in js and rust

^Change the folding strategy in vs code to indentation

*expressions and statements.expressions return a value while statements are a series of functions.defining a functions is a statement while calling a function is an expression.

*you can create scopes in rust

*statements use semicolons to terminate the end of it while expressions dont.if you use a semi colon to terminate an expression,it will become a statement

*rust is expression first meaning numbers and arithmetic operations themselves are implicitly treated as expressions.

*in js,anything truthy value can be used in a condition check while in rust,only expressions that evaluates to bool values can be used.

*in js,paranthesis are required for blocks
*in rust,they must be removed
*in pythin,they are optional

*switch case statements are just syntatic sugar over if-elif ladders

*Blocks of code evaluates to the last expression in them and they are denoted by curly braces.

*In ternary statements,each block must return the same type and this is because rust needs to know the type of a variable at compile time and not at run time.If they allowed it,the compiler will be more complex and will provide less reliable type checks if it relied on possible values of a variable.

*do while loop,while loop,loop
*iterators and range constructs.
*range constructs are made up of a loop counter,end and a step and it can be forward or backward

*The loop keyword is like the while loop except that it doest check for any condition before it enters the loop and it only terminates when explicitly stated in the program with the break keyword

*variables are only visible within the scope they are declared meaing they are not visible to sibling scopes.They are also visible to child scopes but parent scopes cant access the variable in child scopes unless the scope returns the variable.Child scopes cant shadow the variables in the parent scope and can only modify it if the variable is declared muatbable in the parent scope.This is an intentional design choice to allow for predictable code.

*Blocks are made using {}

*Because lines have to be terminated by a semicolon in rust,only the last line of any scope in a rust program can be implicitly made as an expression.

*Running a program in debug mode will only work when there are breakpoints as a debugger is just a detailed step through for a program.

*Break is for breaking loops while continue is to skip the current iteration of the loop

*Scopes are valid blocks like if statements,loops and functions.They are used for scoping code.the last line is implicitly the return statement for scopes meaning scopes can also be used as expressions

*the loop keyword just tells a scope block to repeat itself indefintely until there is a break.You can return a value from a loop block by writing the value you want to return after it

*in rust,before an element from an array is accessed,the compiler takes the extra step of checking if the index is valid.

*You cannot type annotate the loop counter in a for loop

*arrays can be generated by [1;5].The former generates one five times.

*To do range constructs,you iterate over a special array type particularly for this through:[1..5]

*You can also use the rev() method to do a reverse range construct

*js and python use a garbage collector to manage memory,c++ uses manual mem management and rust uses ownership

*the compiler checks for features of ownerships that if they are not met,the progam wont compile

*There are two places of memory in a program; the stack and the heap. The stack is for storing data that's of a fixed and known at compile time while the heap is for data that's of an unknown size. Data can only be added to the stack through the top and accessed by the first in, last out order or the rule of stacked plates and data in the stack only exists for the scope its called in.Once the scope finishes,the stack get cleared and as such,the stack manages itself and its very safe.function parameters and local variables are stored in the stack till they get cleared when the scope is finished.Its simpler and faster to manage than the heap as the program only has to manage only one contiguous block of memory.

*While the heap is for data that's of an unknown size at compile time or for variables that their values change often but the locations of each data block is sparse and can only be accessed by an allocator and since its sparse, it takes more time to allocate and access data on the heap. On the heap, its called allocating and deallocating while on the stack, its called pushing and popping.Data in the heap is left there until explicitly deallocated.You can only access data in the heap by following a pointer that leads to the address of that variable in the heap and since pointers are of known sizes,they are stored on the stack

*integers and arrays of fixed sizes are stored on the stack while flexible sized arrays and strings which grow and shrink dynamically are stored in the heap.

*strings and integers are passed by value while arrays and objects are passed by reference

*Dangling pointers are pointers that points to the address of a memory block that has already been freed and it can cause unexpected behaviour if accessed in the program and smart pointers are pointers that come with memory safety and more features.

*a null pointer means that the pointer doesnt currently point to any memory address.

*pointers get cleared like any normal variable when the scope exits but if they were left pointing to a memory,the memory remains allocated until explicitly freed

*Without pointers and references,you cant access data stored in the heap but for data on the stack,its direct through its variable names but many hll use references and garbage collection which is a manger for references as an abstraction over pointers.references are safer than pointers as they can never be null and it will always lead to valid memory

*For arrays,the pointer initially returned is the pointer to the first element of the array and since arrays are stored in a contiguos block of memory in the heap,the addresses of the elements are serialized and you can use pointer arithmetic to get the other data in the array.Array indexing is just an abstraction of using pointer arithmetic to access elements in an array

*There is a difference between a pointer and a reference.A pointer is a variable that its value is an address to another variable in the heap and can allow you to perform arithmetic operations on that value to create new pointers but doing so can lead to dangling pointers.Since pointers are just variables,they take their own space and have mem addresses on the stack while a reference is a direct alias or mapping to a variable in the heap meaning that it doesnt have its own space on the stack and it shares the same memory address as the variable is aliasing to.Pointers can be reassigned to another memory address while refs cant be reassigned this is because pointers are assigned at runtime while refs are assigned at compile time.References are safer because they cant be null which prevents dangling pointers.

^there is memory leak and memory fragmentation.

^Garbage collector,manual mem mangement and ownership are the different ways programming languages manages meory on the heap

*time allocation--single threaded,asynchronous,multi threaded,multi processing.

*strings and integers are immutable since they are passed by value 

*namespaces and import aliases are used for import safety to ensure that imports dont collide with existing functions in the same module.

*In js,you can do selective exporting and then import them under a namespace as a variable or use destructuring to import them directly in the namespace.

*rust uses the :: notation for accessing the methods in a type and the exports in a namespace/module and not the instance of that type But uses dot notation for instance methods and properties.Its a design choice for clarity while js and pythin use dot notation for both because of simplicity and consistency

*there is selective export and module export

*the string type is mutable while the string literal is immutable and is known at compile time and as such,its stored in the stack.

*when making string types,it makes a request to the allocator to get the space its need to store the string

*because integer values are known at compile time and they dont carry that much data,they can be created on each variable assignment and stored on the stack

*The pointer,the length and the capacity.The length is how much bytes the string is taking in memory while the capacity is the amount of memory in bytes given to the string by the allocator.This means that when you attempt to copy data thats on the heap,you actually copy the pointer,the length and the capacity of that variable on the stack and not the actual data.

*arrays will always decay into the pointer of their first element

*Data in the stack is accessed directly by the value such as integers,booleans,characters and fixed arrays and tuples while data in the heap is only accessed via pointers and references

*compilers can choose to copy the data on the heap but it will be computationally expensive in both memeory and at runtime since it takes the allocator some time to find free space on the heap and thats why variables that their values is another variable holding arrays are just shallow copies and not real/ddep copy because they still point to the same data on the heap but rust takes a different approach to prevent double free deallocs so it invalidates the first variable which is known as a move to ensure that only one pointer to data in the heap only exist at a time and as such,it is not a shallow copy meaning that you cant use the invalidated ref or it will throw an error

*Memory dangers can only be prevented when you call free at the right time mapped correctly to the right alloc.

*trying to deallocate memory on the heap twice will lead to memory coruption,unexpected behaviour and security vulnerabilities

*shallow copy and deep copy.

^dragon ball daima,manga

^in next js,a sidebar is loaded as a layout across many pages and the component that holds the content of what the sidebar leads to is a page that you get routed to by next js but in plain react,i used redux where the sidebar dispatches an action to change the current loaded data state and the content component will always reflect the current loaded data.The paradigms are different because of the way these apps approach rendering as next js creates multiple pages while react uses a single page,in next js apps,clicking on content on the sidebar routes you to the appropriate content while in react,it dispatches an action that changes the current state that the main page will always reflect

*discovering and building

*navbar and sidebar are for navigation

*rust takes a different approach.Once the variable goes out of scope,the variable that owns it gets deallocated so rust automatically calls a drop method to release the memory once the variable goes out of scope

*when you assign a variable to a new value on the heap,rust will automatically invalidate that reference but it will only drop it when the variable that owns it goes out of scope

*variables that have their data on the heap have stack data that contains pointer,length and capacity information and as such,when you copy that variable,you are only copying the stack data and not the heap data

*integer values are known at compile time and as such,they are stored on the stack meaning that variables that hold integer data dont get invalidated and the value actually gets copied when another variable attempts to copy it.This is the very reason why they get copied to a function when they are passed to a function as passing values to a function is just another form of assignment.

*integers,floats,boolean,chars and tuples of any of the types mentioned go to the stack.

*When you pass values to a function,they get copied into the function but when you pass refs like strings and vector arrays,you pass a ref to the function which means that modifying the variable in the function will modify the actual variable itself but rust also adds something else,when it also moves the ref or pass the ownership of that ref to the function meaning that when the function goes out of scope,rust will drop that variable and the variable cant be accessed in the caller after it called the function,it cant access the variable again

*This also means that in rust,when you pass variables that hold references,you also pass the ownership of that reference and when the function returns the variable back to another variable in the caller,it also returns the ownership of that variable back to the scope of the caller.

*This also means that all variables that hold references to data in the heap,are owned in the scope that declared them and when the scope is done,all the references it owns gets dropped.When a function returns a variable that holds a reference,it surrenders the ownership of that reference to a variable in the caller's scope.

*when a variable loses ownership of a reference,it gets invalidated by rust.So when you assign a variable a new ref value,the old ref has no owner,so it gets dropped.

^dropped and invalidated,ownership.

*This also means that in rust,anything that has to do with variables that hold references means transferring the ownerhip of that reference.

*but this is tedious as handing over and returning ownership becomes tedious

*rust goes through the ownership model and not the reference model used by garbage collectors

^exploit

*CORRECTION:so there is a difference between ownership and reference.Garbage collectors use references meaning that when you pass a variable that holds an array to a function,the function creates another ref and not take the ownership to the ref and the gc will clear it as soon as there are no refs again to the value but rust uses ownership meaning that array/object data doesnt get dropped till the variable that owns it gets out of scope and if a variable is given another data,the data from the old ref doesnt get cleared,it just gets invalidated.This also means that the ref no longer has a valid owner but it will only get dropped if the owner goes out of scope

^ownership,references and pointers.

*the ownership model of rust mimics the stack

^you can only access data on the heap through pointers and references.Ownership isnt a way to access data on the heap,its just a system that manages who owns a piece of data and when that data will be deallocated.

*Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference.

*references in rust is a way to pass data on the heap to a function without transferring ownership meaning that it can use the value but the value wont be dropped when the function goes out of scope because it doesnt own that value and the function doesnt have to return it back because it never owned it.

*references are immutable by default which means that any function that uses it only has read only access but there can also be mutable references which means that the function has read and write access.

*passing values to a function by reference over directly giving ownership is borrowing

*You can create many immutable references but once you create a mutable reference,you can no longer create or have any other refs to that variable again.This is to ensure safety because users of an immutable reference don’t expect the value to suddenly change when they want to use it and when they are using it.However, multiple immutable references are allowed because no one who is just reading the data has the ability to affect anyone else’s reading of the data.This restriction prevents data races as it gets caught at compile time because data races can cause undefined behaviour at run time.

*mutable references can only be made from mutable variables

*Many functions can use the same mutable reference.

*There can only be one mutable reference per scope and creating another mutable reference will have to be done in another scope.This is because mutable references stay as long as the life time of their scope and they only get dropped when their scope finishes.The same goes for immutable refs execpt that immutable refs get invalidated for use after a mutable one has been introduced.This rule prevents potential data races.If you were allowed to use immutable references after creating a mutable reference, it could lead to situations where one part of your code is reading a value while another part is modifying it, which could cause unpredictable behavior.

*Immutable references go out of scope from the point they were last used after their declaration.

*The reason why data that no longer has an owner or reference to it doesnt get dropped till the ref/owner goes out of scope in rust is to prevent the ref from dangling which is when the data is deallocated but the ref to that data still exist.This guarantees that a reference always points to valid data.Dangling references can still be created when a function returns a ref to a local variable which is invalid because the local variable goes out of scope after the function executes and as such,there is no value to borrow from meaning that the caller is referencing to nothing.Rust wont compile this.The right thing is to return the value itself,which surrenders ownership of the value to the caller.

*functions normally shouldnt take ownership of their arguments until when necessary.

^edits

*Python uses the variable[x:y] notation for slicing,js uses a function while rust uses the &variable[1..4] for slicing also known as the range syntax which is used in range constructs.

*string slices must occur at asciii character boundaries else,it will throw an error.

*slices are immutable refs to a part of a string meaning that slices dont take ownership of the data and you cant modify them.

*Just like how arrays decay to pointers of their first element,slices become refs to the first element of the array and its length.

^the stack,the heap,the binary read only memory

*string literals are immutable refs to string data on the binary read only memory

^data in the stack has scope lifetime.
^data in the heap has a persistent lifetime depending on the model used--manual,gc and ownership
^data in the binary read only memory has a static lifetime meaning that it never gets deallocated

*the stack also holds function call information

*The binary read only memory is a section of the data that is included directly in the compiled executable of a program and it can never be modified.This means that the data remains even after the program is closed and it is loaded back into the program's memory once the it is opened again.So in rust,string literals and constants get stored in this storage because it saves the allocator time from finding space in the heap to store this data and it can only be accessed by reference in the program because no variable can take ownership of it as its read only and cant be deallocated.But string data on the other hand,which is one that can shrink or expand throughout the program is stored in the heap.

*String literals are the only types that gets stored in the binary storage because they are hardcoded and known at compile time.even if integers are hardcoded and immutable,they are still stored in the stack because they are mostly shortlived and dont usually leave the scope they are defined in.The only way immutable integers can go here is if they are constant.

*The gc is a higher level abstraction that allows programmers to not worry about a thing about memory management while rust ownership model provides some abstractions only to guarantee safety at compile time but the programmer will still manuallay control the lifetime of data through borrowing and ownership and control which memory type every piece of data goes to by declaring it as immutable,mutable and const.

^libraries,modules,frameworks,the standard library.

^react state,rxjs and events are used to implement the observer pattern.

*With tauri,you can interpolate js and rust code in your apps.

*You can write secure code in rust but if you are going for exploitation code,you will want to go for C,C++ or python because the exploits are what rust is trying to prevent you from doing.

*dataframes are a way to create table structures in code.

^biome js and prettier are code formatters.Try out biome js

*for git,its safer to explicitly ignore which files you dont want to see rather than telling it to ignore all files except ...

*Gitignore is safe because an ignored file doesnt get removed from the repo.it just doesnt track any changes to that file for the next commit.

^Rustlings,the rust book,rust by example

^Approaches to memory management
*Through pointers--Manual memory management
*Through references--Garbage Collector
*Through the ownership model--Borrow Checker

*package managers are for managing dependencies and scripts across codebases like npm,cargo,poetry.
*project scaffolders/scaffolding utility are for setting up a structured folder for any type of project like vite,nest js.
*build automation tool which helps to auto compile,bundle and execute your code and optionally with auto reloading when the src code changes

*Build automation tools require one entrypoint file that intiliazes the app and manages imports.For rust its the main.rs file,for vite its main.tsx and for nest js,its the app.ts file.

*Package managers are often also basic project scaffolders
*in rust,cargo is not only a package manager and scaffolder but also a tool that compiles and run your program for you.its like vite that bundles your code for you and runs it with hmr and nest js that also compiles your ts files before executing it.

*It was js that i learnt the importance of a project/package manager.

^Bundler,compiler

^React--compiled,bundled,executed
^Nest js--compiled,live running

*intellisense suggestions are provided by a language server

*in rust,there is a difference between a string object and a string reference.A string reference is immutable,hard coded,known at compile time and stored in the binary storage since its just a ref to a string object in the binary storage while string objects can be mutable,can shrink and grow at run time and are stored in the heap.

^Typescript enforces type safety,Rust enforces memory safety.They both catch many errors at compile time

?Interfaces/Structures and Classes
?Land analogy--ownership model and gc

^Typescript with Rust

^Funk,Reverb,Nightcore and other musical effects

*nest js and angular are object oriented

*In rust,references to data dont outlive the owner of that data and as such,rust uses lifetimes to determine how long a ref is valid.Normally,ref get invalidated once the owner's scope is left.

*lifetimes are denoted by an apostrophe followed by a letter.they are used to tell rust how long a reference is valid for use before it invalidates it.Without specifying lifetimes, the compiler wouldn't be able to determine how long these references are valid which could to references that point to invalid memory and become dangling.

*Lifetime annotations are used to tell the compiler the lifetime of a reference.Rust implicitly creates lifetime annotations for simple assignments and function signatures but it is required in complex scenarios like struct.In assignments,lifetime annotations are implicitly tied to the owner meaning that if the owner goes out of scope,the reference becomes invalid.Rust doesnt infer lifetime annotations for structs because it can lead to ambiguity as each field might have a different lifetime.

*In situations where there is only one reference made at a time like in assignments,rust can infer its lifetime to be tied to its owner but when there are multiple refs to be handled by one entity like a struct or a function accepting many refs as pars,the lifetimes must be annotated explicitly so that the compiler can know the relationship between the refs

*in rust,the entire instance of a struct must be mutable if changes may be required after initialization as fields cant be mutable individually.This is so that refs to struct objects can only be mutable or immutable at a time and that no part/some of its fields can be immutable and mutable at the same time to prevent data races,ensure safety and prevent borrowing rules.

*in rust,data in the heap gets dropped if the owner gets out of scope,meaning that variables are local by default.

*Static storage is for data that will exist throughout the lifetime of the program menaing that variables in this storage are global and they are stored in the binary heap storage.

*News flash:By default,a ref can never outlive the data it points to but rust uses annotations so that it can keep track of how the ref is used in the function or struct to determine its lifetime and use it to know the relationship between future use of the refs in the same scope meaning that ref names must be consistent across the entire scope and lifetimes can only be defined in their definitions and no other lifetimes outside of what was defined can be used in the scope else,it will throw a compiler error and they are scoped to the function or struts that defines them.

*Lifetime annotations are just placeholders that can hold any arbitary name so you can use any name you like as long as its consistent across the scope.They can be either generic:a,b,c or descriptive:short long.Only the static lifetime annotation is hardcoded as it is used to tell rust that data must be global and must be stored in the static storage.Apart from this,other annotations are given lifetimes based on how rust infers it at compile time.

^This is similar to how react uses keys in list rendering to keep track of which values change to avoid unnecessary re-renders.React is the one that actually uses the keys,all the devs need to do,is to provide it.React relies on developer-provided keys to manage component rendering efficiently, Rust relies on developer-provided lifetime annotations to manage memory safely. Both mechanisms help their respective systems function effectively while placing the responsibility of clarity and accuracy on the developers.

*rust can just add annotations themselves if they wanted to but making devs to explicitly add names,allows for clarity as what the purpose of the ref is and clearly defining the relationships between refs

*so lifetime annotations are rust way of preventing dangling references as it states how long refs are valid

*The only lifetimes that can be used in a function or struct are the ones that are included in their definitions in the <>.

^You can use the field init shorthand syntax in rust when creating new objects from structs as it is in js.Rust also has a struct update syntax which is identical to js spread operator excep that in rust,it must come last but for js,it can be anywhere.This is just rust design choice.

*When you create a new struct object say object2 from an existing one say object1 using the struct update notation,any field data that is stored in the heap as defined by the structure will be moved from object1 to object2 if object2 doesnt create its own new value for that field as borrowing rules apply to the field level meaning that object1 has lost ownership to that field data to object2 and that field becomes invalid for object1.This is because,the update syntax essentially copies each of the field's data to create a new object but if any of that field data is in the heap,it moves the ownerhsip of the access to that data to the new object

^References and owners
^Redux provides state safety for react apps

*structs that dont use references in any of their fields dont need lifetime annotations.For fields that uses data on the heap directly,ownership applies.

?An object is just another way of storing grouped data like an array except that data access is by field name and not by index

^Tuples,arrays and vectors

*Tuples and arrays are both a sequential collection of elements that are known at compile time and as such,they are stored in the stack meaning that they implement the copy trait and not the move trait in rust.The only difference between the two is that all the elements in the array must be of one type while tuples can have elements of different types.Vectors are arrays that can grow and shrink during runtime and as such,they are stored in the heap.They are made to only hold one type because of type safety during runtime and you can only get different types if you use a vector of enums since enums can hold different types.

*Tuple structs are just a semantic layer over tuples by providing a struct nature.They take the name of the struct and a tuple definition which holds the type of the fields rather than raw values.They can be initialized unlike tuples.They are simply structs behaving like tuples where the field name is implicitly set as the index.Functions that take one tuple struct cant take another even if the tuple structs have the same types and number of elements.This is to ensure safety.

*so we can have a tuple struct or an object struct.

?How to access an array element with an index.
?unit type struct

^Unit-like structs can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself.They are a simple yet versatile feature in Rust. They allow for the creation of distinct types without associated data, which can be beneficial for type safety, marker patterns, and implementing behaviors via traits. This makes them a useful tool in Rust's type system, especially in more complex applications.

^Copy and move traits in rust.

*Unit like structs are for structs that dont need any data to implement methods

*In strucures in rust,we will want to have each object from that structure own all of its data so that it simplifies memory management and ensures safety.For example,in a struct,we will want to use the String type over the &str reference as the former allows the instance of the struct to own that string since its allocated to the heap but for the latter,the instance doesnt own its data and as such,it needs to use lifetime annotations to ensure that the reference to that data doesnt outlive the owner (in this case its the instance) to prevent dangling references

^Signature and definitions/implementations/concrete data
^Loose equality,Strict equality,Deep equality

*Typescript interfaces combine both data and method signatures while in rust,structs are strictly for data signatures while traits are for method signatures meaning that a ts interface is loosely equals to struct + traits in rust.

^The compilers are Clang,GCC,MSVC,intel C++ compiler

^msys2 is a development environment for C++ that provides a unix like shell for windows but it isnt integrated into a text editor.It is a collection of tools like compilers and package managers that can make ready C++ projects.I use msys2 to install c++.Msys2 allows you to install packages for C++ by using pacman as the package manager.Other options are the visual studio build tools,minGW that uses GCC.A dev environment takes you to the shell.

*An IDE is a development environment thats integrated into a text editor.In other words,its a supercharged text editor.

^llvm is a compiler framework that has compilers and allows developers to create their own.

^MinGW is a compiler suite/suite of compilers like GCC and other utilities

^The visual studio build tools is a set of tools for developing apps for windows.It uses a custom compiler called MSVC as its main compiler.

?Tuples-in terms of python and rust
?Coordinate geometry and Volumetric geometry

*so coordinate geometry data is an array of tuples where each tuple contains point data that can be related to form a shape while volumetric geometry data is an array of arrays where the outer array is the grid and each inner array is a layer that's stacked along the z-axis and each of those layers is an array of tuples which contain point data.They both come down to an array of tuples except that in the former,its just an array of tuples meaning that they are all just continuous number of points while in the latter,it has a finite number of arrays as each layer/inner array has many tuple data or voxel data

*in coordinate geometry the tuples representation of their data is the same as that of voxels in volumetric geometry as point(x,y,z) looks identical in structure to voxel(x,y,z) but i believe the difference is that since in coordinate geometry,there are no layers,the tuple just becomes the location of a point and a point can exist anywhere in the 3d space freely and the whole shape comes together when these points are related by many continuous points in between but for volumetric data,since each voxel is in a layer of fixed z-axis,only the x-y plane defines location while the z-axis represents the depth of the space it occupies as a volume and the whole object comes together with many of a finite number of of voxels.The reason for it being finite is that computers dont have the power to generate an infinite number of arrays that each hold voxel data.

*a grid is made up of number lines made to perpendicularly intersect at each other and thus creating multiple axis.

*Objects made from coordinates are hollow in the sense that they only represent surfaces and dont provide any information about the internal of the model while volumetric object encapsulates both the surface and internals of the object.

*Point data is best for 3d modelling and particle simulation while voxels are best for scientific purposes

*Triangle geometry is an extension of coordinate geometry, using triangles to connect points defined in a point data array, where each triangle is formed by indexing into the array of vertices.

^google made go and dart
^microsoft made typescript

^java and C# are object oriented while haskell and erlang is functional and python and js support the two.

^monad--a way for functions to do something with absolutely no side effects

*The concept of mutable state is mostly with classes than functions.Purely functional programming langaues promise no side effect whatsoever on the data the program use.

?poe crashed and reopened and now the ourple is more saturated.

*implementation in rust is a way to provide method definitions and concrete implementations to a structure.

*its best practice to borrow the self parameter as we dont want the method to take ownership of the ibstance

^class--interface + functions

*getters are a way to make fields private but the method public to ensure that the property is readonly

*C is procedural

*a pointer is like here is the address to the data of the variable on the heap while a reference is more of when i say x im referring to this particular data stored in the heap.

*Rust does automatic referencing and dereferencing when calling methods on instances meaning that any method that will use self i.e instance methods,an immutable borrow reference to the instance gets implicitly passed as the first parameter to that method

*constructors in rust implementation blocks can be named anything you like but a good convetion is new unless you have many of them in which you can then use descriptive names.
*in rust you can have many constrcutors to handle many cases in which an object of a class can be created.This is not supported in js and python as they only allow one constructor and the only way to handle multiple cases is with condition,type checks and default values and the reason its this way is because its dynamially typed and doesnt support method overloading unlike rust which is the opposite.

*in rust,the :: notation is used for namespaces and constructors while the . notation is used for methods.

*in rust,only expressions can end without semicolons if they are the last line of a scope

*Enums in rust are used for holding variant data.It is loosely equivalent to type aliases of interfaces and then a union of many of those except that for that version,it will have to implement a 'kind' property in each of the interfaces before it can decide what type of data it is because unions state what values a variable can accept but it doesnt state what variant of that data it is

^In coding,constants are normally used for making hardcoded values more readable over using arbritary number or string values so it is best practice to use them for any hardcoded value and in js and python,a data structure called an enum is used to hold a set of related constants but in rust,enums are used for creating variants of data.Also in an enum,each variant can have its own type and the amounts of unit data for that particular type.

?OCR technology with a flatbed scanner--converts images to text
?pdf tools--smallpdf and light pdf
^License agreement and privacy policy

^Markdown is better for structured notes but txt files are better for unstructured notes.

^my handwriting needs to be better for ocr tech

^make my own applock

^GCs like that in python also use weak referencing

^godot and unity uses the scene based architecture while roblox and unreal engine uses a component based architecture
*scene based architecture focuses more on scripts to define explicit behaviour
*component based architecture focuses more on triggering events to define behaviour

*There is also ecs too.but it isnt widely used

*A query language allows one to directly talk to a database but orms can prevent sql attacks since they provide abstractions that separate sql queries from your data. 

*abstractions protect you from mistakes that causes security vulnerabilities

*enums are better than unit structs.enums are also more concise than structs incases where you have many similar types.you can even make an enum of structs.this also makes function signatures more concise.You can also write implementation blocks for enums

*a prelude is a collection of items that are automatically included in every rust program

*Rust doesnt directly allow null values but rather it provides an option type which means that a value may be present or absent.Its safer than working directly with a variable thats initially declared as null because it forces you to handle both cases and its enforced at compile time.This is loosely equivalent to a typescript union of an actual type and undefined except that rust enforces handling all cases at compile time while typescript doesnt and rust provides methods that makes it easier to work with than ts.Another thing that option<T> in rust handles better than typesecript,is that a variable thats of this type cant be directly used in arithmetic or any operation until its converted back to a valid type and the rust compiler will never allow it to compile to none.this ensures that we handle the case of a possibly null value before using it.

*The option type is actually an enum.This makes its implementation easier.

*Match case statements can handle both simple values and complex patterns that cant be handled by switch case statements that are mostly used to check for fixed constant values as match cases are made to work with enum data which can hold many data variants.They are also enforced to handle all paterns/cases and as such,they are exhaustive unlike switch case statements.It also doesnt allow data to fallthrough all the cases like the switch case.The switch case has to have a break at each arm to prevent this.The switch case uses the 'default' case to catch all other cases that want caught by the ladder while the match case statement can do likewise by using an arrow function that uses an underscore or a variable name to bind the state of the data to.They both have to be the last case in the ladder

*_ in programming is used for signifying unused variables

*enums in rust cannot only hold a collection of constants but also data variants

*In rust,match case statements can bind to the state of an enum's data given that the enum data variant is made to hold data either as a tuple or a struct.This means that we can use the state of that enum in the function block of an arm.So you can match for patterns like Enum::Variant or bind to a value like Enum::Variant(state).

*In rust,arrow functions can only be used in match case statements while in js,it can be used anywhere

*Dunder methods in python are used to perform operator overloading which is changing the default behaviour of objects when used with built in operators.

*A trait is like a struct in rust except that a trait holds method signatures while structs are for field signatures.A trait is mostly used when multiple structs share methods and there's a need to define a stucture for the methods.It is implemented by impl blocks.

*Rust enforces snake case for function names whereas js and python dont.

*in rust,you can type annotate the type of data next to its variable name using the : notation or directly appended to the value.

*if let statement is like the match statement but for when you are interseted for matching for only one pattern and ignoring the rest.It is less verbose and less boilerplate than the match statement when matching only for a single pattern but you lose the exhaustive checking of match statements.Its essentially syntati sugar over one pattern match case statements.

*There is a difference between a return statement and return expression.A return statement returns a value from a scope to the caller and exits the entire function regardless of how deep the scope is within the function but a return expression returns a value from the scope without exiting the function.The return statement can be anywhere in a scope but a return expression can only be the last line of a scope.The return expression doesnt start with the return statement as it evaluates to a value.

*scope in coding usually refers to the visibility of variables.so scope in rust which can be created with {} allows me to create variables where their duration is only within the scope's definition.they are used to control the lifetime of variables by specifying them within a temporary context.

*lifetimes in rust can be controlled using lifetime annotations.

*There is a difference between a function scope and a block scope.The difference lies in who they give values to.All of these scopes can choose not to give values which will make the function scope a void function,the block scope a statement but they will become expressions if they do give a value.A function scope gives a value to the caller of the function.The caller of the function exists outside of the scope of the function and the function evaluates to a value and returns the value and flow control back to the caller of the function while a block scope gives a value to a variable but the flow control is still in the scope of the function as the variable that collects the value from these scopes exist within the function.This scope does this by just evaluating to a value which gives the value to the variable in the function scope without using the return statement to return flow control and the value to the caller of the function.

*So calling a function hands flow control over to the function but if you also pass variables whose data exist in the heap,you are passing both ownership of the variable and flow control to the function.The function will always return back flow control to the caller even if it isnt explicitly written but for the function to return back ownership of the data,it must be done explicitly.

*if statements,for and while loops tokens are just directives on how and when block scopes should be executed.

*A let-else statement is just a more readable way of returning from an if-let scope.

*statement and an expression.A statement doesnt evaluate to a value and end with a semicolon while an expression evaluates to a value and doesnt end with a semicolon.A statement like the if statement can be made to evaluate to a value and thus becoming an expression.

*enums can hold units,tuples,contants and structs in rust

*Nim has a completely tunable garbage collector meaning that you can disable it completely to switch to manual memory management

*Application level and System level programming languages

*Haskell is pure/declarative functional and one thing about the purely functional paradigm is that code is very predictable and reliable.It also provides a rich set of preludes/built in functions that makes writing many code instructions at an abstract level where you define what you want but you dont bother about how its done unlike the procedural programming paradigm.This means that the code is very minimal.

*procedural,imperative functional,concurrent,declarative functional,object oriented,data query language,markup,style sheet,multi paradigm

*The difference between declarative functional and imperative functional is that imperative functional produces side effects and also focuses more on how the steps are defined while declarative funtional is fully pure and provides a rich set of built in functions that abstracts away from the how.

*in procedural,everything is made of statements meaning that you describe control flow and how a program should achieve a result but in declarative functional,everything is made of expressions meaning that you define what the result should like rather than how it should be done.Declarative functional langauges are just another layer of sweet abstraction.Declarative functional languages also provide a more intuitive and expressive way to write code but it requires a different way of thinking than imperative langauges.

*programming paradigms are different from software design patterns

*python and js support declarative functional styles but are primarily imperative and as such have more of an imperative functional style over declarative

*js doesnt have direct control over memory and resources on the browser for security reasons but rather,it uses provided apis that exposes this functionality for js to use

^disassembler,decompiler,debugger,dll injection,windows api

*memory address and offset.Calculating offset with pointer arithmetic

*external and internal cheat

*system utilities and exploitware with rust

*system level-clis and app level--guis

*infecting a software with high priviledges

*user mode vs kernel mode anti cheat

*malware and cheat signatures

^Lynx js from tik tok
^Rs pack

*As you go down the programming iceberg from high level to low level,the dangers increase as priviledges increase.A software that has more priviledges is more unsafe and vulnerable to one that hasnt.

*A device driver is a software that allows an operating system to communicate with the hardware.It translates high level os commands to low level commands that the hardware can understand.There are kernel,user mode and virtual drivers.An OS acts as the middlema between the hardware and software ensuring that softwares reliably and safely interact with system resources.It uses a kernel driver as its core to directly communicate with the hardware.It is the core of the os and provides an interface for programs to communicate with the hardware through system calls to it.Kernel drivers operate at a high and unrestricted acces level to the hardware so its EXTREMELY DANGEROUS to create a software that operates at this level.Making system calls to the os is a safer way to do things.A user mode driver is a driver that allows the os to communicate with peripheral devices/hardware like a usb or printer in user space meaning that the interaction occurs in a restricted access space where crashes wont affect the entire system.It simplifies development and doesnt crash the entire system.

*Apps work on system calls.A system call is a controlled interface provided by the os that allows programs to communicate with the hardware through it.Code written in rust or c provides prelude methods and functions whereby when used,it gets compiled to machine code that makes system calls to the os for hardware access meaning that programs dont operate at a kernel level which makes it safer.In assembly,you can directly write system calls to the os in code unlike c and rust that provides abstractions over those system calls.

*low/system level languages are mostly compiled while high/application level languages are inetrepreted

*so when they say that low level languages give you direct access to hardware resources,this access is provided by the programming language compiler to directly make system calls to the os that can affect the hardware but its still restricted because the os is another abstraction/layer behind this layer and beyond this layer,is a direct and dangerous level of hardware access.So there are two layers between a program and hardware access and the compilers like c and rust can only give you access to what they have which is the first layer while interpreted languages bring in a third layer infront of these two through their abstractions provided by the runtime environment like the garbage collector meaning that your code doesnt directly make system calls.More layers equates to more safety but lesser control and possibly less performance because of the overhead of going through all these layers.

*rust allows you to write system level programs while also ensuring memory safety,type safety,concurrent safety and explicit error handling for runtime safety.

*system access is abstracted by the programming language and hardware access is abstracted by the operaring system

*The module system

*A crate is the smallest unit of code that is compiled by the rust compiler into an executable.A crate can be a binary crate which compiles to an exe or a lib crate which doesnt get compiled but rather,it is used by binary crates.A package is a collection of many of these crates.There can be many binary crate but only one library crate.A binary crate must have a main function that tells the rust program where to start once its loaded.The root crate is where rust starts to compile your program from.A package has a cargo.toml file that defines how these crates should be built and what dependencies your crates need.A package can have multuple crates by placing them in the bin folder

*A module is crate other than the root.The module keyword is used to declare a module in the module system for visibility and use.It is not used for importing modules.Rust will look for the module in the filesystem through the convention of the module's name.rs in the src file or mod.rs in a folder that has the name of the module or through an inline definition of the module which is supplied as a block scope next to the declaration line and then include that module in the module system.After declaring a module in the module system,you can access the module directly as rust will perform a lookup in the module system to see if the module you are attempting to use is present there.You can use the :: notation to access functions from that module and those functions can be made visible or public to the module system by using the pub keyword infront of the function's signature in the module where its defined.The use keyword allows you to import the namespace of a module directly in a file so that you only type a path once.

*To use a module declared in the module system outside of the main file,you have to use the use crate syntax to bring it into scope.The mod keyword is to declare and import a module while the use crate is used to import the module in a file other than the one that it was declared in.You can only declare modules in the main.rs file and sub modules in other modules.To access modules,you just use their names directly but for submodules,you use the names of the parent modules first before the submodule's name.

*The main.rs and lib.rs files are combined to form the root module because all other modules will fall under an hierarchy lower than these making that the root of the tree.This creates a module system which is similar to the filesytem but for organizing code.

*The main.rs file is the binary crate that acts as the entry point to the entire project structure of your rust program.It must have a main function which serves as the entrypoint to this file and it compiles into an executable file while mod.rs files or module_name.rs files are used to define modules that can be imported in the main.rs file to be part of the module system while the lib.rs file is for making a rust program as a library instead of an executable.

*The path of a module in rust is where a resource/rust script can be found.Paths to a script in rust can be relative or absolute.The absolute path is the full path to the module starting from the root of the module system.If you are using a module in the root crate/main.rs file or where it was declared,the path starts with the name of the module but if you want to use the module in another one other than where it was declared,you have to start the path with the literal,crate to tell rust that the path to the module starts at the root of the module system.

*The use keyword is just to bring a module to scope.Thats it.It isnt used for importing a module.Once a module is declared in the module system,it can be used or called in any other file in the codebase but the path.The pub keyword is used to expose certain functions from the module to be used externally.

*mod keyword,pub keyword,path

*Rust chose to make the functions of modules private by default unless otherwise stated to be public by the pub keyword in order to ensure that the dev knows exactly what code is being called or used throughout the module system

*the as keyword is an alias to prevent conflict

*There is a file-based import and a module based import.

*python and js use a different importing paradigm from rust.In python,you can import an entire module without the module explicitly allowing exports and by default,all the code in a module is public.This is the default behaviour but you can choose to do selective exports in python where only the functionality you want to export is used by other scripts.In js,selective exports is the default behaviour of exports although they also allow module,default export.In both of these paradigms,they are imported according to their paths in the file system and a script cant use a module unless they explicitly import them.But rust is a bit different,a module doesnt have to explicitly imported in a script as it can be used by any script regardless of where it is in the codebase because uses a module system to access resources rather than using the filesystem meaning that as long as the code you want to use elsewhere is defined in the module system,you can access that module's functionality by using its path in the ms to directly access its functionality.All the functions in a module are private unless stated otherwise.This is similar to js where only what you export is visible to other parts of the codebase except that the implementation is slightly different.Once a module is declared in rust,all its code is visible but not accessible while in js,only selective parts of the code is visible.
