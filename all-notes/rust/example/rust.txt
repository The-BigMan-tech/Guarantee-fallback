so macros are like functions for reusable blocks of code but macro genrates the reusable blocks at compile time unlike functions that gets called at runtime.this allows for compile time optimizations and can generate different code structures based on the input unlike functions that have a fixed structure

When a macro is invoked, it expands into code at the call site. This means the generated code can be different for each invocation, leading to more efficient and tailored output.

Functions: Always call the same block of code regardless of how they are invoked, which can lead to performance penalties if the function is called frequently.

macros give a more expressive syntax

functions have a fixed signature while macros signature are flexible to syntax patterns although function overloading in langs like ts,make function signatures flexible based on input and generics with union types makes return types and input types very flexible

functions can also take a varible number of args by using the spread operator

function overloads are resolved at runtime while macros expand into code at compile time allowing optimizations

Macros are generated at compile time which can prevent errors early rather than functions throwing errors at run time when the wrong args are passed

cargo is the package manager for rust and its cargo.toml and cargo.lock as oppossed to package.json and pnpm-lock.yaml or packagelock.json as it is for js files.This is called local project management.Its better to install dependencies for a particuar project rather than globally on the file system.pip does this globally i believe and thats why there is somthing called virtual environment

the dependency file is for specifying the packages and the versions a project uses while the lock file is for ensuring that the versions of the dependencies remains consistent regardless of the environment

toml and json files are for project management
cfg files are for settings for an app or a tool
yaml and json files are for serializin data

dependencies in rust are called crates as it is called node modules in javascript

lock files are managed by the package manager while the dependency files acn be manged manualy

*ill use rust to convert the size of my compressed array to a smaller size by representing chunks in the smallest byte representation possible for that chunk rtaher than having a consistent size across all chunks

*Dont need pinno for logging,the vscode turbo console log extension is far superior as it automatically creates detailed log messages and can adap it when the code refactors.Its a log manager

js is interpreted by the browser,so it can run directly in the browser
js in frontend frameworks have to be compiled by the frontend framework into regular js dom manipulation and then bundled into on js file with a web bundler like vite before running it on the browser.
running js standalone requires node js 
ts needs to be compiled to js files before its ran in the browser or node js envirnonment

since rust is a compiled language language,it has to get compiled into an executable before it gets ran

cargo build
cargo run
cargo clean
cargo check

cargo build emits the executable in the target/debug folder for quick re-editing while cargo build --release builds it as a final program for use so its slower so only use it when the final build of the program is ready.

"General learning material for Language X" is a completely different scope from "Teaching the basics of programming using Language X". The former is suitable when you are a beginner to the specific programming language but not to programming in general, whereas the latter is required when you are a beginner to programming in general.

react requires that states must be immutable and editing them should return a new value which reps the current state and not directly modify the state itself the same as rust

*rust is one of those languages that uses an entry point function called main.It also uses curly braces to create blocks over indentation and it uses semi colons as a line terminator

*intellisense is provided by a language server

*compile time erros means that the program isnt safely doing what its suppose to do yet.

*In js and python,variables are mutable until explicitly declared immutable stated while in rust,variables are immutable by default unless they are explicitly declared mutable

*in c++ and rust,printing to the std output must be in a string literal.I belive that python and js do this under the hood by an abstraction

*constants are immutable together with the fact that they must be annotated and they can be declared in any scope and the value of constants must be known at compile time instead of run time like immutable values meaing that the values of constants must be hardcoded while immutable variables can be assigned the values of other variables upon declaration

*constants are best for having a single source of truth for all the hardcoded values that will be used in your program and it also makes them more readable while immutable variables are for enforcing safety

*You cannot change the type of a mutable variable

*Shadowing is redeclaring a new variable with the same name as a previous variable.This means that the new declaration shadows the old one and takes precedence.It is used when trying to change the value and type of an immutable variable without actually mutating it because its actually declaring a new varible but with the same name.This ensures that the variable always remains immutable across changes and it also prevents the need for creating many similar variables but with just different names.Its a false sense of mutation.It can be considered as a safer alternative to mutation

*Mutation means changing the value of a variable after its declaration while shadowing doesnt.

*Immutability leads to predictablility as seen in react and redux and its the same for rust.

*integer,float,boolean and character

*Unsigned integers are guaranteed positive integers while signed integers may be positive or negative
*You can use _ as a separator for long integer values and you can suffix the type of a variabe that holds an integer with the type in front of the integer

*when an integer overflows,it can cause two things:if its in debug mode,it will panic and throw an error but if its in release mode,it will wrap around the given range which is also an error.

*i,u,f

2^(n-1) is the formula for calculating how many numbers can be produced with n bits.

*boolean values in rust are one byte
*there is unicode and ascii way of representing strings or characters just like python because unicode can represent a vast array of characters including emojis

*chars use single quotes in rust while strings use double quotes

*tuples can be unoacked in pythin and rust as arrays can be destructured in javascript

*arrays,tuples and vectors.Tuples can be composed of any types while arrays cant and arrays are fixed in length

*an array is a fixed large chunk of memory allocated to the stack

*in python functions arent hoisted but they are in js and rust

^Change the folding strategy in vs code to indentation

*expressions and statements.expressions return a value while statements are a series of functions.defining a functions is a statement while calling a function is an expression.

*you can create scopes in rust

*statements use semicolons to terminate the end of it while expressions dont.if you use a semi colon to terminate an expression,it will become a statement

*rust is expression first meaning numbers and arithmetic operations themselves are implicitly treated as expressions.

*in js,anything truthy value can be used in a condition check while in rust,only expressions that evaluates to bool values can be used.

*in js,paranthesis are required for blocks
*in rust,they must be removed
*in pythin,they are optional

*switch case statements are just syntatic sugar over if-elif ladders

*Blocks of code evaluates to the last expression in them and they are denoted by curly braces.

*In ternary statements,each block must return the same type and this is because rust needs to know the type of a variable at compile time and not at run time.If they allowed it,the compiler will be more complex and will provide less reliable type checks if it relied on possible values of a variable.

*do while loop,while loop,loop
*iterators and range constructs.
*range constructs are made up of a loop counter,end and a step and it can be forward or backward

*The loop keyword is like the while loop except that it doest check for any condition before it enters the loop and it only terminates when explicitly stated in the program with the break keyword

*variables are only visible within the scope they are declared meaing they are not visible to sibling scopes.They are also visible to child scopes but parent scopes cant access the variable in child scopes unless the scope returns the variable.Child scopes cant shadow the variables in the parent scope and can only modify it if the variable is declared muatbable in the parent scope.This is an intentional design choice to allow for predictable code.

*Blocks are made using {}

*Because lines have to be terminated by a semicolon in rust,only the last line of any scope in a rust program can be implicitly made as an expression.

*Running a program in debug mode will only work when there are breakpoints as a debugger is just a detailed step through for a program.

*Break is for breaking loops while continue is to skip the current iteration of the loop

*Scopes are valid blocks like if statements,loops and functions.They are used for scoping code.the last line is implicitly the return statement for scopes meaning scopes can also be used as expressions

*the loop keyword just tells a scope block to repeat itself indefintely until there is a break.You can return a value from a loop block by writing the value you want to return after it

*in rust,before an element from an array is accessed,the compiler takes the extra step of checking if the index is valid.

*You cannot type annotate the loop counter in a for loop

*arrays can be generated by [1;5].The former generates one five times.

*To do range constructs,you iterate over a special array type particularly for this through:[1..5]

*You can also use the rev() method to do a reverse range construct

*js and python use a garbage collector to manage memory,c++ uses manual mem management and rust uses ownership

*the compiler checks for features of ownerships that if they are not met,the progam wont compile

*There are two places of memory in a program; the stack and the heap. The stack is for storing data that's of a fixed and known at compile time while the heap is for data that's of an unknown size. Data can only be added to the stack through the top and accessed by the first in, last out order or the rule of stacked plates and data in the stack only exists for the scope its called in.Once the scope finishes,the stack get cleared and as such,the stack manages itself and its very safe.function parameters and local variables are stored in the stack till they get cleared when the scope is finished.Its simpler and faster to manage than the heap as the program only has to manage only one contiguous block of memory.

*While the heap is for data that's of an unknown size at compile time or for variables that their values change often but the locations of each data block is sparse and can only be accessed by an allocator and since its sparse, it takes more time to allocate and access data on the heap. On the heap, its called allocating and deallocating while on the stack, its called pushing and popping.Data in the heap is left there until explicitly deallocated.You can only access data in the heap by following a pointer that leads to the address of that variable in the heap and since pointers are of known sizes,they are stored on the stack

*integers and arrays of fixed sizes are stored on the stack while flexible sized arrays and strings which grow and shrink dynamically are stored in the heap.

*strings and integers are passed by value while arrays and objects are passed by reference

*Dangling pointers are pointers that points to the address of a memory block that has already been freed and it can cause unexpected behaviour if accessed in the program and smart pointers are pointers that come with memory safety and more features.

*a null pointer means that the pointer doesnt currently point to any memory address.

*pointers get cleared like any normal variable when the scope exits but if they were left pointing to a memory,the memory remains allocated until explicitly freed

*Without pointers and references,you cant access data stored in the heap but for data on the stack,its direct through its variable names but many hll use references and garbage collection which is a manger for references as an abstraction over pointers.references are safer than pointers as they can never be null and it will always lead to valid memory

*For arrays,the pointer initially returned is the pointer to the first element of the array and since arrays are stored in a contiguos block of memory in the heap,the addresses of the elements are serialized and you can use pointer arithmetic to get the other data in the array.Array indexing is just an abstraction of using pointer arithmetic to access elements in an array

*There is a difference between a pointer and a reference.A pointer is a variable that its value is an address to another variable in the heap and can allow you to perform arithmetic operations on that value to create new pointers but doing so can lead to dangling pointers.Since pointers are just variables,they take their own space and have mem addresses on the stack while a reference is a direct alias or mapping to a variable in the heap meaning that it doesnt have its own space on the stack and it shares the same memory address as the variable is aliasing to.Pointers can be reassigned to another memory address while refs cant be reassigned this is because pointers are assigned at runtime while refs are assigned at compile time.References are safer because they cant be null which prevents dangling pointers.

^there is memory leak and memory fragmentation.

^Garbage collector,manual mem mangement and ownership are the different ways programming languages manages meory on the heap

*time allocation--single threaded,asynchronous,multi threaded,multi processing.

*strings and integers are immutable since they are passed by value 

*namespaces and import aliases are used for import safety to ensure that imports dont collide with existing functions in the same module.

*In js,you can do selective exporting and then import them under a namespace as a variable or use destructuring to import them directly in the namespace.

*rust uses the :: notation for accessing the methods in a type and the exports in a namespace/module and not the instance of that type But uses dot notation for instance methods and properties.Its a design choice for clarity while js and pythin use dot notation for both because of simplicity and consistency

*there is selective export and module export

*the string type is mutable while the string literal is immutable and is known at compile time and as such,its stored in the stack.

*when making string types,it makes a request to the allocator to get the space its need to store the string

*because integer values are known at compile time and they dont carry that much data,they can be created on each variable assignment and stored on the stack

*The pointer,the length and the capacity.The length is how much bytes the string is taking in memory while the capacity is the amount of memory in bytes given to the string by the allocator.This means that when you attempt to copy data thats on the heap,you actually copy the pointer,the length and the capacity of that variable on the stack and not the actual data.

*arrays will always decay into the pointer of their first element

*Data in the stack is accessed directly by the value such as integers,booleans,characters and fixed arrays and tuples while data in the heap is only accessed via pointers and references

*compilers can choose to copy the data on the heap but it will be computationally expensive in both memeory and at runtime since it takes the allocator some time to find free space on the heap and thats why variables that their values is another variable holding arrays are just shallow copies and not real/ddep copy because they still point to the same data on the heap but rust takes a different approach to prevent double free deallocs so it invalidates the first variable which is known as a move to ensure that only one pointer to data in the heap only exist at a time and as such,it is not a shallow copy meaning that you cant use the invalidated ref or it will throw an error

*Memory dangers can only be prevented when you call free at the right time mapped correctly to the right alloc.

*trying to deallocate memory on the heap twice will lead to memory coruption,unexpected behaviour and security vulnerabilities

*shallow copy and deep copy.

^dragon ball daima,manga

^in next js,a sidebar is loaded as a layout across many pages and the component that holds the content of what the sidebar leads to is a page that you get routed to by next js but in plain react,i used redux where the sidebar dispatches an action to change the current loaded data state and the content component will always reflect the current loaded data.The paradigms are different because of the way these apps approach rendering as next js creates multiple pages while react uses a single page,in next js apps,clicking on content on the sidebar routes you to the appropriate content while in react,it dispatches an action that changes the current state that the main page will always reflect

*discovering and building

*navbar and sidebar are for navigation

*rust takes a different approach.Once the variable goes out of scope,the variable that owns it gets deallocated so rust automatically calls a drop method to release the memory once the variable goes out of scope

*when you assign a variable to a new value on the heap,rust will automatically invalidate that reference but it will only drop it when the variable that owns it goes out of scope

*variables that have their data on the heap have stack data that contains pointer,length and capacity information and as such,when you copy that variable,you are only copying the stack data and not the heap data

*integer values are known at compile time and as such,they are stored on the stack meaning that variables that hold integer data dont get invalidated and the value actually gets copied when another variable attempts to copy it.This is the very reason why they get copied to a function when they are passed to a function as passing values to a function is just another form of assignment.

*integers,floats,boolean,chars and tuples of any of the types mentioned go to the stack.

*When you pass values to a function,they get copied into the function but when you pass refs like strings and vector arrays,you pass a ref to the function which means that modifying the variable in the function will modify the actual variable itself but rust also adds something else,when it also moves the ref or pass the ownership of that ref to the function meaning that when the function goes out of scope,rust will drop that variable and the variable cant be accessed in the caller after it called the function,it cant access the variable again

*This also means that in rust,when you pass variables that hold references,you also pass the ownership of that reference and when the function returns the variable back to another variable in the caller,it also returns the ownership of that variable back to the scope of the caller.

*This also means that all variables that hold references to data in the heap,are owned in the scope that declared them and when the scope is done,all the references it owns gets dropped.When a function returns a variable that holds a reference,it surrenders the ownership of that reference to a variable in the caller's scope.

*when a variable loses ownership of a reference,it gets invalidated by rust.So when you assign a variable a new ref value,the old ref has no owner,so it gets dropped.

^dropped and invalidated,ownership.

*This also means that in rust,anything that has to do with variables that hold references means transferring the ownerhip of that reference.

*but this is tedious as handing over and returning ownership becomes tedious

*rust goes through the ownership model and not the reference model used by garbage collectors

^exploit

*CORRECTION:so there is a difference between ownership and reference.Garbage collectors use references meaning that when you pass a variable that holds an array to a function,the function creates another ref and not take the ownership to the ref and the gc will clear it as soon as there are no refs again to the value but rust uses ownership meaning that array/object data doesnt get dropped till the variable that owns it gets out of scope and if a variable is given another data,the data from the old ref doesnt get cleared,it just gets invalidated.This also means that the ref no longer has a valid owner but it will only get dropped if the owner goes out of scope

^ownership,references and pointers.

*the ownership model of rust mimics the stack

^you can only access data on the heap through pointers and references.Ownership isnt a way to access data on the heap,its just a system that manages who owns a piece of data and when that data will be deallocated.

*Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference.

*references in rust is a way to pass data on the heap to a function without transferring ownership meaning that it can use the value but the value wont be dropped when the function goes out of scope because it doesnt own that value and the function doesnt have to return it back because it never owned it.

*references are immutable by default which means that any function that uses it only has read only access but there can also be mutable references which means that the function has read and write access.

*passing values to a function by reference over directly giving ownership is borrowing

*You can create many immutable references but once you create a mutable reference,you can no longer create or have any other refs to that variable again.This is to ensure safety because users of an immutable reference don’t expect the value to suddenly change when they want to use it and when they are using it.However, multiple immutable references are allowed because no one who is just reading the data has the ability to affect anyone else’s reading of the data.This restriction prevents data races as it gets caught at compile time because data races can cause undefined behaviour at run time.

*mutable references can only be made from mutable variables

*Many functions can use the same mutable reference.

*There can only be one mutable reference per scope and creating another mutable reference will have to be done in another scope.This is because mutable references stay as long as the life time of their scope and they only get dropped when their scope finishes.The same goes for immutable refs execpt that immutable refs get invalidated for use after a mutable one has been introduced.This rule prevents potential data races.If you were allowed to use immutable references after creating a mutable reference, it could lead to situations where one part of your code is reading a value while another part is modifying it, which could cause unpredictable behavior.

*Immutable references go out of scope from the point they were last used after their declaration.

*The reason why data that no longer has an owner or reference to it doesnt get dropped till the ref/owner goes out of scope in rust is to prevent the ref from dangling which is when the data is deallocated but the ref to that data still exist.This guarantees that a reference always points to valid data.Dangling references can still be created when a function returns a ref to a local variable which is invalid because the local variable goes out of scope after the function executes and as such,there is no value to borrow from meaning that the caller is referencing to nothing.Rust wont compile this.The right thing is to return the value itself,which surrenders ownership of the value to the caller.

*functions normally shouldnt take ownership of their arguments until when necessary.

^edits

*Python uses the variable[x:y] notation for slicing,js uses a function while rust uses the &variable[1..4] for slicing also known as the range syntax which is used in range constructs.

*string slices must occur at asciii character boundaries else,it will throw an error.

*slices are immutable refs to a part of a string meaning that slices dont take ownership of the data and you cant modify them.

*Just like how arrays decay to pointers of their first element,slices become refs to the first element of the array and its length.

^the stack,the heap,the binary read only memory

*string literals are immutable refs to string data on the binary read only memory

^data in the stack has scope lifetime.
^data in the heap has a persistent lifetime depending on the model used--manual,gc and ownership
^data in the binary read only memory has a static lifetime meaning that it never gets deallocated

*the stack also holds function call information

*The binary read only memory is a section of the data that is included directly in the compiled executable of a program and it can never be modified.This means that the data remains even after the program is closed and it is loaded back into the program's memory once the it is opened again.So in rust,string literals and constants get stored in this storage because it saves the allocator time from finding space in the heap to store this data and it can only be accessed by reference in the program because no variable can take ownership of it as its read only and cant be deallocated.But string data on the other hand,which is one that can shrink or expand throughout the program is stored in the heap.

*String literals are the only types that gets stored in the binary storage because they are hardcoded and known at compile time.even if integers are hardcoded and immutable,they are still stored in the stack because they are mostly shortlived and dont usually leave the scope they are defined in.The only way immutable integers can go here is if they are constant.

*The gc is a higher level abstraction that allows programmers to not worry about a thing about memory management while rust ownership model provides some abstractions only to guarantee safety at compile time but the programmer will still manuallay control the lifetime of data through borrowing and ownership and control which memory type every piece of data goes to by declaring it as immutable,mutable and const.

^libraries,modules,frameworks,the standard library.

^react state,rxjs and events are used to implement the observer pattern.

*With tauri,you can interpolate js and rust code in your apps.

*You can write secure code in rust but if you are going for exploitation code,you will want to go for C,C++ or python because the exploits are what rust is trying to prevent you from doing.

*dataframes are a way to create table structures in code.

^biome js and prettier are code formatters.Try out biome js

*for git,its safer to explicitly ignore which files you dont want to see rather than telling it to ignore all files except ...

*Gitignore is safe because an ignored file doesnt get removed from the repo.it just doesnt track any changes to that file for the next commit.

^Rustlings,the rust book,rust by example

^Approaches to memory management
*Through pointers--Manual memory management
*Through references--Garbage Collector
*Through the ownership model--Borrow Checker

*package managers are for managing dependencies and scripts across codebases like npm,cargo,poetry.
*project scaffolders/scaffolding utility are for setting up a structured folder for any type of project like vite,nest js.
*build automation tool which helps to auto compile,bundle and execute your code and optionally with auto reloading when the src code changes

*Build automation tools require one entrypoint file that intiliazes the app and manages imports.For rust its the main.rs file,for vite its main.tsx and for nest js,its the app.ts file.

*Package managers are often also basic project scaffolders
*in rust,cargo is not only a package manager and scaffolder but also a tool that compiles and run your program for you.its like vite that bundles your code for you and runs it with hmr and nest js that also compiles your ts files before executing it.

*It was js that i learnt the importance of a project/package manager.

^Bundler,compiler

^React--compiled,bundled,executed
^Nest js--compiled,live running

*intellisense suggestions are provided by a language server

*in rust,there is a difference between a string object and a string reference.A string reference is immutable,hard coded,known at compile time and stored in the binary storage since its just a ref to a string object in the binary storage while string objects can be mutable,can shrink and grow at run time and are stored in the heap.

^Typescript enforces type safety,Rust enforces memory safety.They both catch many errors at compile time

?Interfaces/Structures and Classes
?Land analogy--ownership model and gc

^Typescript with Rust

^Funk,Reverb,Nightcore and other musical effects

*nest js and angular are object oriented

*In rust,references to data dont outlive the owner of that data and as such,rust uses lifetimes to determine how long a ref is valid.Normally,ref get invalidated once the owner's scope is left.

*lifetimes are denoted by an apostrophe followed by a letter.they are used to tell rust how long a reference is valid for use before it invalidates it.Without specifying lifetimes, the compiler wouldn't be able to determine how long these references are valid which could to references that point to invalid memory and become dangling.

*Lifetime annotations are used to tell the compiler the lifetime of a reference.Rust implicitly creates lifetime annotations for simple assignments and function signatures but it is required in complex scenarios like struct.In assignments,lifetime annotations are implicitly tied to the owner meaning that if the owner goes out of scope,the reference becomes invalid.Rust doesnt infer lifetime annotations for structs because it can lead to ambiguity as each field might have a different lifetime.

*In situations where there is only one reference made at a time like in assignments,rust can infer its lifetime to be tied to its owner but when there are multiple refs to be handled by one entity like a struct or a function accepting many refs as pars,the lifetimes must be annotated explicitly so that the compiler can know the relationship between the refs

*in rust,the entire instance of a struct must be mutable if changes may be required after initialization as fields cant be mutable individually.This is so that refs to struct objects can only be mutable or immutable at a time and that no part/some of its fields can be immutable and mutable at the same time to prevent data races,ensure safety and prevent borrowing rules.

*in rust,data in the heap gets dropped if the owner gets out of scope,meaning that variables are local by default.

*Static storage is for data that will exist throughout the lifetime of the program menaing that variables in this storage are global and they are stored in the binary heap storage.

*News flash:By default,a ref can never outlive the data it points to but rust uses annotations so that it can keep track of how the ref is used in the function or struct to determine its lifetime and use it to know the relationship between future use of the refs in the same scope meaning that ref names must be consistent across the entire scope and lifetimes can only be defined in their definitions and no other lifetimes outside of what was defined can be used in the scope else,it will throw a compiler error and they are scoped to the function or struts that defines them.

*Lifetime annotations are just placeholders that can hold any arbitary name so you can use any name you like as long as its consistent across the scope.They can be either generic:a,b,c or descriptive:short long.Only the static lifetime annotation is hardcoded as it is used to tell rust that data must be global and must be stored in the static storage.Apart from this,other annotations are given lifetimes based on how rust infers it at compile time.

^This is similar to how react uses keys in list rendering to keep track of which values change to avoid unnecessary re-renders.React is the one that actually uses the keys,all the devs need to do,is to provide it.React relies on developer-provided keys to manage component rendering efficiently, Rust relies on developer-provided lifetime annotations to manage memory safely. Both mechanisms help their respective systems function effectively while placing the responsibility of clarity and accuracy on the developers.

*rust can just add annotations themselves if they wanted to but making devs to explicitly add names,allows for clarity as what the purpose of the ref is and clearly defining the relationships between refs

*so lifetime annotations are rust way of preventing dangling references as it states how long refs are valid

*The only lifetimes that can be used in a function or struct are the ones that are included in their definitions in the <>.

^You can use the field init shorthand syntax in rust when creating new objects from structs as it is in js.Rust also has a struct update syntax which is identical to js spread operator excep that in rust,it must come last but for js,it can be anywhere.This is just rust design choice.

*When you create a new struct object say object2 from an existing one say object1 using the struct update notation,any field data that is stored in the heap as defined by the structure will be moved from object1 to object2 if object2 doesnt create its own new value for that field as borrowing rules apply to the field level meaning that object1 has lost ownership to that field data to object2 and that field becomes invalid for object1.This is because,the update syntax essentially copies each of the field's data to create a new object but if any of that field data is in the heap,it moves the ownerhsip of the access to that data to the new object

^References and owners
^Redux provides state safety for react apps

*structs that dont use references in any of their fields dont need lifetime annotations.For fields that uses data on the heap directly,ownership applies.

?An object is just another way of storing grouped data like an array except that data access is by field name and not by index

^Tuples,arrays and vectors

*Tuples and arrays are both a sequential collection of elements that are known at compile time and as such,they are stored in the stack meaning that they implement the copy trait and not the move trait in rust.The only difference between the two is that all the elements in the array must be of one type while tuples can have elements of different types.Vectors are arrays that can grow and shrink during runtime and as such,they are stored in the heap.They are made to only hold one type because of type safety during runtime and you can only get different types if you use a vector of enums since enums can hold different types.

*Tuple structs are just a semantic layer over tuples by providing a struct nature.They take the name of the struct and a tuple definition which holds the type of the fields rather than raw values.They can be initialized unlike tuples.They are simply structs behaving like tuples where the field name is implicitly set as the index.Functions that take one tuple struct cant take another even if the tuple structs have the same types and number of elements.This is to ensure safety.

*so we can have a tuple struct or an object struct.

?How to access an array element with an index.
?unit type struct

^Unit-like structs can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself.They are a simple yet versatile feature in Rust. They allow for the creation of distinct types without associated data, which can be beneficial for type safety, marker patterns, and implementing behaviors via traits. This makes them a useful tool in Rust's type system, especially in more complex applications.

^Copy and move traits in rust.

*Unit like structs are for structs that dont need any data to implement methods

*In strucures in rust,we will want to have each object from that structure own all of its data so that it simplifies memory management and ensures safety.For example,in a struct,we will want to use the String type over the &str reference as the former allows the instance of the struct to own that string since its allocated to the heap but for the latter,the instance doesnt own its data and as such,it needs to use lifetime annotations to ensure that the reference to that data doesnt outlive the owner (in this case its the instance) to prevent dangling references

^Signature and definitions/implementations/concrete data
^Loose equality,Strict equality,Deep equality

*Typescript interfaces combine both data and method signatures while in rust,structs are strictly for data signatures while traits are for method signatures meaning that a ts interface is loosely equals to struct + traits in rust.

^The compilers are Clang,GCC,MSVC,intel C++ compiler

^msys2 is a development environment for C++ that provides a unix like shell for windows but it isnt integrated into a text editor.It is a collection of tools like compilers and package managers that can make ready C++ projects.I use msys2 to install c++.Msys2 allows you to install packages for C++ by using pacman as the package manager.Other options are the visual studio build tools,minGW that uses GCC.A dev environment takes you to the shell.

*An IDE is a development environment thats integrated into a text editor.In other words,its a supercharged text editor.

^llvm is a compiler framework that has compilers and allows developers to create their own.

^MinGW is a compiler suite/suite of compilers like GCC and other utilities

^The visual studio build tools is a set of tools for developing apps for windows.It uses a custom compiler called MSVC as its main compiler.

?Tuples-in terms of python and rust
?Coordinate geometry and Volumetric geometry

*so coordinate geometry data is an array of tuples where each tuple contains point data that can be related to form a shape while volumetric geometry data is an array of arrays where the outer array is the grid and each inner array is a layer that's stacked along the z-axis and each of those layers is an array of tuples which contain point data.They both come down to an array of tuples except that in the former,its just an array of tuples meaning that they are all just continuous number of points while in the latter,it has a finite number of arrays as each layer/inner array has many tuple data or voxel data

*in coordinate geometry the tuples representation of their data is the same as that of voxels in volumetric geometry as point(x,y,z) looks identical in structure to voxel(x,y,z) but i believe the difference is that since in coordinate geometry,there are no layers,the tuple just becomes the location of a point and a point can exist anywhere in the 3d space freely and the whole shape comes together when these points are related by many continuous points in between but for volumetric data,since each voxel is in a layer of fixed z-axis,only the x-y plane defines location while the z-axis represents the depth of the space it occupies as a volume and the whole object comes together with many of a finite number of of voxels.The reason for it being finite is that computers dont have the power to generate an infinite number of arrays that each hold voxel data.

*a grid is made up of number lines made to perpendicularly intersect at each other and thus creating multiple axis.

*Objects made from coordinates are hollow in the sense that they only represent surfaces and dont provide any information about the internal of the model while volumetric object encapsulates both the surface and internals of the object.

*Point data is best for 3d modelling and particle simulation while voxels are best for scientific purposes

*Triangle geometry is an extension of coordinate geometry, using triangles to connect points defined in a point data array, where each triangle is formed by indexing into the array of vertices.

^google made go and dart
^microsoft made typescript

^java and C# are object oriented while haskell and erlang is functional and python and js support the two.

^monad--a way for functions to do something with absolutely no side effects

*The concept of mutable state is mostly with classes than functions.Purely functional programming langaues promise no side effect whatsoever on the data the program use.

?poe crashed and reopened and now the ourple is more saturated.

*implementation in rust is a way to provide method definitions and concrete implementations to a structure.

*its best practice to borrow the self parameter as we dont want the method to take ownership of the ibstance

^class--interface + functions

*getters are a way to make fields private but the method public to ensure that the property is readonly

*C is procedural

*a pointer is like here is the address to the data of the variable on the heap while a reference is more of when i say x im referring to this particular data stored in the heap.

*Rust does automatic referencing and dereferencing when calling methods on instances meaning that any method that will use self i.e instance methods,an immutable borrow reference to the instance gets implicitly passed as the first parameter to that method

*constructors in rust implementation blocks can be named anything you like but a good convetion is new unless you have many of them in which you can then use descriptive names.
*in rust you can have many constrcutors to handle many cases in which an object of a class can be created.This is not supported in js and python as they only allow one constructor and the only way to handle multiple cases is with condition,type checks and default values and the reason its this way is because its dynamially typed and doesnt support method overloading unlike rust which is the opposite.

*in rust,the :: notation is used for namespaces and constructors while the . notation is used for methods.

*in rust,only expressions can end without semicolons if they are the last line of a scope

*Enums in rust are used for holding variant data.It is loosely equivalent to type aliases of interfaces and then a union of many of those except that for that version,it will have to implement a 'kind' property in each of the interfaces before it can decide what type of data it is because unions state what values a variable can accept but it doesnt state what variant of that data it is

^In coding,constants are normally used for making hardcoded values more readable over using arbritary number or string values so it is best practice to use them for any hardcoded value and in js and python,a data structure called an enum is used to hold a set of related constants but in rust,enums are used for creating variants of data.Also in an enum,each variant can have its own type and the amounts of unit data for that particular type.

?OCR technology with a flatbed scanner--converts images to text
?pdf tools--smallpdf and light pdf
^License agreement and privacy policy

^Markdown is better for structured notes but txt files are better for unstructured notes.

^my handwriting needs to be better for ocr tech

^make my own applock

^GCs like that in python also use weak referencing

^godot and unity uses the scene based architecture while roblox and unreal engine uses a component based architecture
*scene based architecture focuses more on scripts to define explicit behaviour
*component based architecture focuses more on triggering events to define behaviour

*There is also ecs too.but it isnt widely used

*A query language allows one to directly talk to a database but orms can prevent sql attacks since they provide abstractions that separate sql queries from your data. 

*abstractions protect you from mistakes that causes security vulnerabilities

*enums are better than unit structs.enums are also more concise than structs incases where you have many similar types.you can even make an enum of structs.this also makes function signatures more concise.You can also write implementation blocks for enums

*a prelude is a collection of items that are automatically included in every rust program

*Rust doesnt directly allow null values but rather it provides an option type which means that a value may be present or absent.Its safer than working directly with a variable thats initially declared as null because it forces you to handle both cases and its enforced at compile time.This is loosely equivalent to a typescript union of an actual type and undefined except that rust enforces handling all cases at compile time while typescript doesnt and rust provides methods that makes it easier to work with than ts.Another thing that option<T> in rust handles better than typesecript,is that a variable thats of this type cant be directly used in arithmetic or any operation until its converted back to a valid type and the rust compiler will never allow it to compile to none.this ensures that we handle the case of a possibly null value before using it.

*The option type is actually an enum.This makes its implementation easier.

*Match case statements can handle both simple values and complex patterns that cant be handled by switch case statements that are mostly used to check for fixed constant values as match cases are made to work with enum data which can hold many data variants.They are also enforced to handle all paterns/cases and as such,they are exhaustive unlike switch case statements.It also doesnt allow data to fallthrough all the cases like the switch case.The switch case has to have a break at each arm to prevent this.The switch case uses the 'default' case to catch all other cases that want caught by the ladder while the match case statement can do likewise by using an arrow function that uses an underscore or a variable name to bind the state of the data to.They both have to be the last case in the ladder

*_ in programming is used for signifying unused variables

*enums in rust cannot only hold a collection of constants but also data variants

*In rust,match case statements can bind to the state of an enum's data given that the enum data variant is made to hold data either as a tuple or a struct.This means that we can use the state of that enum in the function block of an arm.So you can match for patterns like Enum::Variant or bind to a value like Enum::Variant(state).

*In rust,arrow functions can only be used in match case statements while in js,it can be used anywhere

*Dunder methods in python are used to perform operator overloading which is changing the default behaviour of objects when used with built in operators.

*A trait is like a struct in rust except that a trait holds method signatures while structs are for field signatures.A trait is mostly used when multiple structs share methods and there's a need to define a stucture for the methods.It is implemented by impl blocks.

*Rust enforces snake case for function names whereas js and python dont.

*in rust,you can type annotate the type of data next to its variable name using the : notation or directly appended to the value.

*if let statement is like the match statement but for when you are interseted for matching for only one pattern and ignoring the rest.It is less verbose and less boilerplate than the match statement when matching only for a single pattern but you lose the exhaustive checking of match statements.Its essentially syntati sugar over one pattern match case statements.

*There is a difference between a return statement and return expression.A return statement returns a value from a scope to the caller and exits the entire function regardless of how deep the scope is within the function but a return expression returns a value from the scope without exiting the function.The return statement can be anywhere in a scope but a return expression can only be the last line of a scope.The return expression doesnt start with the return statement as it evaluates to a value.

*scope in coding usually refers to the visibility of variables.so scope in rust which can be created with {} allows me to create variables where their duration is only within the scope's definition.they are used to control the lifetime of variables by specifying them within a temporary context.

*lifetimes in rust can be controlled using lifetime annotations.

*There is a difference between a function scope and a block scope.The difference lies in who they give values to.All of these scopes can choose not to give values which will make the function scope a void function,the block scope a statement but they will become expressions if they do give a value.A function scope gives a value to the caller of the function.The caller of the function exists outside of the scope of the function and the function evaluates to a value and returns the value and flow control back to the caller of the function while a block scope gives a value to a variable but the flow control is still in the scope of the function as the variable that collects the value from these scopes exist within the function.This scope does this by just evaluating to a value which gives the value to the variable in the function scope without using the return statement to return flow control and the value to the caller of the function.

*So calling a function hands flow control over to the function but if you also pass variables whose data exist in the heap,you are passing both ownership of the variable and flow control to the function.The function will always return back flow control to the caller even if it isnt explicitly written but for the function to return back ownership of the data,it must be done explicitly.

*if statements,for and while loops tokens are just directives on how and when block scopes should be executed.

*A let-else statement is just a more readable way of returning from an if-let scope.

*statement and an expression.A statement doesnt evaluate to a value and end with a semicolon while an expression evaluates to a value and doesnt end with a semicolon.A statement like the if statement can be made to evaluate to a value and thus becoming an expression.

*enums can hold units,tuples,contants and structs in rust

*Nim has a completely tunable garbage collector meaning that you can disable it completely to switch to manual memory management

*Application level and System level programming languages

*Haskell is pure/declarative functional and one thing about the purely functional paradigm is that code is very predictable and reliable.It also provides a rich set of preludes/built in functions that makes writing many code instructions at an abstract level where you define what you want but you dont bother about how its done unlike the procedural programming paradigm.This means that the code is very minimal.

*procedural,imperative functional,concurrent,declarative functional,object oriented,data query language,markup,style sheet,multi paradigm

*The difference between declarative functional and imperative functional is that imperative functional produces side effects and also focuses more on how the steps are defined while declarative funtional is fully pure and provides a rich set of built in functions that abstracts away from the how.

*in procedural,everything is made of statements meaning that you describe control flow and how a program should achieve a result but in declarative functional,everything is made of expressions meaning that you define what the result should like rather than how it should be done.Declarative functional langauges are just another layer of sweet abstraction.Declarative functional languages also provide a more intuitive and expressive way to write code but it requires a different way of thinking than imperative langauges.

*programming paradigms are different from software design patterns

*python and js support declarative functional styles but are primarily imperative and as such have more of an imperative functional style over declarative

*js doesnt have direct control over memory and resources on the browser for security reasons but rather,it uses provided apis that exposes this functionality for js to use

^disassembler,decompiler,debugger,dll injection,windows api

*memory address and offset.Calculating offset with pointer arithmetic

*external and internal cheat

*system utilities and exploitware with rust

*system level-clis and app level--guis

*infecting a software with high priviledges

*user mode vs kernel mode anti cheat

*malware and cheat signatures

^Lynx js from tik tok
^Rs pack

*As you go down the programming iceberg from high level to low level,the dangers increase as priviledges increase.A software that has more priviledges is more unsafe and vulnerable to one that hasnt.

*A device driver is a software that allows an operating system to communicate with the hardware.It translates high level os commands to low level commands that the hardware can understand.There are kernel,user mode and virtual drivers.An OS acts as the middlema between the hardware and software ensuring that softwares reliably and safely interact with system resources.It uses a kernel driver as its core to directly communicate with the hardware.It is the core of the os and provides an interface for programs to communicate with the hardware through system calls to it.Kernel drivers operate at a high and unrestricted acces level to the hardware so its EXTREMELY DANGEROUS to create a software that operates at this level.Making system calls to the os is a safer way to do things.A user mode driver is a driver that allows the os to communicate with peripheral devices/hardware like a usb or printer in user space meaning that the interaction occurs in a restricted access space where crashes wont affect the entire system.It simplifies development and doesnt crash the entire system.

*Apps work on system calls.A system call is a controlled interface provided by the os that allows programs to communicate with the hardware through it.Code written in rust or c provides prelude methods and functions whereby when used,it gets compiled to machine code that makes system calls to the os for hardware access meaning that programs dont operate at a kernel level which makes it safer.In assembly,you can directly write system calls to the os in code unlike c and rust that provides abstractions over those system calls.

*low/system level languages are mostly compiled while high/application level languages are inetrepreted

*so when they say that low level languages give you direct access to hardware resources,this access is provided by the programming language compiler to directly make system calls to the os that can affect the hardware but its still restricted because the os is another abstraction/layer behind this layer and beyond this layer,is a direct and dangerous level of hardware access.So there are two layers between a program and hardware access and the compilers like c and rust can only give you access to what they have which is the first layer while interpreted languages bring in a third layer infront of these two through their abstractions provided by the runtime environment like the garbage collector meaning that your code doesnt directly make system calls.More layers equates to more safety but lesser control and possibly less performance because of the overhead of going through all these layers.

*rust allows you to write system level programs while also ensuring memory safety,type safety,concurrent safety and explicit error handling for runtime safety.

*system access is abstracted by the programming language and hardware access is abstracted by the operaring system

*The module system

*A crate is the smallest unit of code that is compiled by the rust compiler into an executable.A crate can be a binary crate which compiles to an exe or a lib crate which doesnt get compiled but rather,it is used by binary crates.A package is a collection of many of these crates.There can be many binary crate but only one library crate.A binary crate must have a main function that tells the rust program where to start once its loaded.The root crate is where rust starts to compile your program from.A package has a cargo.toml file that defines how these crates should be built and what dependencies your crates need.A package can have multuple crates by placing them in the bin folder

*A module is crate other than the root.The module keyword is used to declare a module in the module system for visibility and use.It is not used for importing modules.Rust will look for the module in the filesystem through the convention of the module's name.rs in the src file or mod.rs in a folder that has the name of the module or through an inline definition of the module which is supplied as a block scope next to the declaration line and then include that module in the module system.After declaring a module in the module system,you can access the module directly as rust will perform a lookup in the module system to see if the module you are attempting to use is present there.You can use the :: notation to access functions from that module and those functions can be made visible or public to the module system by using the pub keyword infront of the function's signature in the module where its defined.The use keyword allows you to import the namespace of a module directly in a file so that you only type a path once.

*To use a module declared in the module system outside of the main file,you have to use the use crate syntax to bring it into scope.The mod keyword is to declare and import a module while the use crate is used to import the module in a file other than the one that it was declared in.You can only declare modules in the main.rs file and sub modules in other modules.To access modules,you just use their names directly but for submodules,you use the names of the parent modules first before the submodule's name.

*The main.rs and lib.rs files are combined to form the root module because all other modules will fall under an hierarchy lower than these making that the root of the tree.This creates a module system which is similar to the filesytem but for organizing code.

*The main.rs file is the binary crate that acts as the entry point to the entire project structure of your rust program.It must have a main function which serves as the entrypoint to this file and it compiles into an executable file while mod.rs files or module_name.rs files are used to define modules that can be imported in the main.rs file to be part of the module system while the lib.rs file is for making a rust program as a library instead of an executable.

*The path of a module in rust is where a resource/rust script can be found.Paths to a script in rust can be relative or absolute.The absolute path is the full path to the module starting from the root of the module system.If you are using a module in the root crate/main.rs file or where it was declared,the path starts with the name of the module but if you want to use the module in another one other than where it was declared,you have to start the path with the literal,crate to tell rust that the path to the module starts at the root of the module system.

*The use keyword is just to bring a module to scope.Thats it.It isnt used for importing a module.Once a module is declared in the module system,it can be used or called in any other file in the codebase but the path.The pub keyword is used to expose certain functions from the module to be used externally.

*mod keyword,pub keyword,path

*Rust chose to make the functions of modules private by default unless otherwise stated to be public by the pub keyword in order to ensure that the dev knows exactly what code is being called or used throughout the module system

*the as keyword is an alias to prevent conflict

*There is a file-based import and a module based import.

*python and js use a different importing paradigm from rust.In python,you can import an entire module without the module explicitly allowing exports and by default,all the code in a module is public.This is the default behaviour but you can choose to do selective exports in python where only the functionality you want to export is used by other scripts.In js,selective exports is the default behaviour of exports although they also allow module,default export.In both of these paradigms,they are imported according to their paths in the file system and a script cant use a module unless they explicitly import them.But rust is a bit different,a module doesnt have to explicitly imported in a script as it can be used by any script regardless of where it is in the codebase because uses a module system to access resources rather than using the filesystem meaning that as long as the code you want to use elsewhere is defined in the module system,you can access that module's functionality by using its path in the ms to directly access its functionality.All the functions in a module are private unless stated otherwise.This is similar to js where only what you export is visible to other parts of the codebase except that the implementation is slightly different.Once a module is declared in rust,all its code is visible but not accessible while in js,only selective parts of the code is visible.

*Pythons paradigm has implicit visibility control.This is for readability and simplicity

*Levels of abstractions:1.runtime environments--interpreters,browsers,containers,virtual machines,coding environments,database engines. 2.Compiler--compiles to instructions and optionally perfroms safety rules like type and memory safety. 3.direct instructions. 4.OS 5.Hardware

*so modules that are defined in files and not as separate scripts have to be marked as pub in order to make them available to the codebase through the module system unlike modules that are declared in a file but the actual data of that module is in another script like mod.rs.Also making a module public doesnt make its content public.

?Memory mapped files

^Just an idea:defers allocation,skip the lines that uses unallocated strings,log the line and current state of strings that are already allocated to be used in the next execution cycle,deallocate old strings and repeat the execution cycle.Out of order string usage is an edge case for this.

*in rust,the :: notation is for modules and class methods while the dot notation are for instance methods.When structs are declared public,all the fields will be private by default unless otherwise marked a spublic but for enums,once it is marked as piblic,all the variants will be public

*the reason for this design choice is because enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with pub.

*The shortcut provided by the use keyword is only available for the module its used in meaning that if you use the use keyword to bring a module into scope,the shortcut wont be visible to inline module declarations

*We can also use the use keyword to bring the parent module into scope so that we can use all its functions but through the parent.This is to minimize the paths we have to write to use a function in that module and also ensure that we prevent naming conflicts by not bringing in any of its functions into scope.

^There is type alias,import alias and reference alias.

*we can use an import alias to prevent naming conlicts when bringing two imports with the same name into the namespace of the scope.

*The pub use keyword is essentially re-exporting the module.It allows a shortcut defined by the use keyword to publicly available to the codebase.This is useful when you want to create two domains of how programmers will think of your library.People that want to work on it will think of accessing the module system through its individual components but programmers calling the library just want to use the features they want directly without having to know the different level of components to get there.

*You can also use the super keyword to access content relative to the parent

*To include external packages in your codebase,you should write them as a dependency in the cargo.toml file but each codebase has its own module system and the module system of an external codebase cant be included directly in another.so in order to use any of its content in a script in your own codebase,you have to bring the content from the external module system into its scope/namespace.This allows you to work with those items without having to reference the entire crate each time.

*You can also use the wild operator to bring all the content from a  module into scope but itsnot recomended because of possible naming conflicts.

*You can shorten the number of use * lines we have in a script by factoring out the common path and put the subpaths that differ in curly braces.

*The recommended style to use for module files is the module_name.rs styel over the mod.rs style because having multiple mod.rs files can be confusing to navigate about if they are all opened in the editor at the same time.

*low poly,high poly

*Vectors can only hold a single type.

*Rust needs to know the type of data that a vector will hold at compile time or else,it will throw an error.Rust cant infer the type of data a vector will hold if it is constructed with the vector constructor without pushing any element to it after its assignment i.e it isnt initialized with any elements since the contsructor doesnt take any arguments.It  will then require an explicit type annotation but most of the time,vectors will be initialized with at least a value for rust to infer the type so the annotation will be rarely needed and rust also provides the vec! macro that automatically creates a vector along with its type annotation for us.

*get returns an option object which can be handled for out of bounds index while indexing will panic.Pick your pick based on the scenario

*The push vector method in rust takes a mutable reference to the instance of the class.This will allow the method to modify the vector without taking ownership and since there can only be one mutable ref at a time,it ensures safety to ensure that only one mutable operation is done at a time

*Looping over a vector in rust requires you to use a mutable ref to that vector.this is to ensure that you dont modify the vector while looping over it as there can only be one mutable ref in a scope.

*An immutable ref invalidates a mutable one but not vice versa.This is because when you create an immutable ref after a mutable one,rust takes the mut one out of scope as it believes that its job is done

*In rust,when reading a value from a vector through indexing,you can choose to access the data by an immutable ref which will allow you to read it or you can copy the data to that variable by directly assigning it to the data at that index as long as the data implements the copy trait like integers or chars.For types that do not implement Copy (like String or Vec<T>), assigning the value will move the data, which means you cannot use the original value after the assignment unless it's wrapped in a reference.Using the immutable ref means that you cant read the array before any mutable refs to that array is made so that later in the program,you dont read any unexpected data but since immutable refs can invalidate mutable ones,you can read the data using an immutable ref after modifying it with a mutable one as it is in push.

*a string object in rust is a wrapper around vectors.u can either use the to string method on the str literal type or the string object constructor directly

*The push_str or push (for a single character) method of a string object is used for copying the content of a string slice or a string literal to the end of a string object by using a reference to it to access its data.Concatenation with the + operator is used for adding a string object to another string object and assigning it to a new variable.It does this by moving or transferring ownership of the left operand string object to the new variable so that it remains memory efficient by not copying the data and for the right operands,it requires you to pass them as immutable references since the data to be appended to a string object must be a reference to a string literal data so that it can copy its contents to the end of the string.But since a &String ref is not the same as a &str ref as the former is a reference to data in the heap,rust does a deref coercion where it turns the ref to &str so that it matches the function definition and the reason why &str is used over &String when appending data is because its easier to read and work with so its purely out of rust preferences.This always ensures that the right operands continue to own their data.The reason why the content of a &str ref is copied instead of directly appending the ref to the string object is because a string object has its data stored in the heap and the variable that references to that data must own all of its data and not having to borrow data from another place and the reason why the right operand string objects are not just moved into the new variable is so that those string objects still retain ownership of their data for use later in the codebase.

*But why not just move all the string objects in concatenation for memory efficeiency why is it the left operand that gets moved but not the right.Who is to say its the right we will need to preserve ownership to reuse later over the one on the left?The reason is because of the components that makes up string concatenation.We have the primary data and secondary/source data.The primary data being the left operand is the one to be modified so it makes sense to move the data to variables rather than copying it every single time it needs to be modified while the ones on the right are the secondary meaning that its a source of data that is to be used to modify one to many string objects and as such,it serves as the source data.Because the source data might be reused across the codebase to modify various string objects,it makes more sense to copy them over rather than moving it which will make it difficult to reuse later

*Immutability over efficiency

*format! is like formatting in println but it returns the data to a variable rsther than printing it to the standard output.It doesnt take ownership of any of its parameters but rather copies the content of each string object.This alternative to direct concatenation makes it less memory efficient than concatenation but it is less cumbersome and allows for flexibility as you can opt into the method you wish for your strings to be handled when bringing them together.If you pass a borrowed type like &str,it takes a ref to it.The format method is more time efficient because for concatenation,the string might be reallocated to a new address on the heap if the space allocated to the string isnt big enough to hold the concatenated data meaning that there might be a new allocation for each concatenation which is more time consuming while the format macro doesnt append data to an existing string but rather,it creates a new string which means that there will only be one allocation and it will be big enough to hold its entire content but might take more space since it copies all of its operands in the case of string object.After copying the string data  over to a new memory in the heap after each reallocation that might happen during string concatenation,rust will automatically drop the old memory to prevent memory leaks and update the memory address that the variable points to to prevent dangling references

*strings in rust dont support indexing like in vectors

*The stack is for integers and floats that are fixed i.e they dont vary in size and known at compile time and function call frames like local variables.The heap is for data that might change over time and is not known at compile time.Data in the heap can grow and shrink over time.Stack allocation is done at compile time while heap allocation is done at runtime so its dynamic.References to data in the heap are stored in the stack but the data itself is in the heap.Strings go to the heap because they are can change throughout the program.Strings in python and js are stored in the heap because they are variable in size which will require the dynamic memory allocation of the heap but they are immutable meaning that any apparent modification to the string actually creates a copy of the string and it means that strings passed to functions are passed by value.This is to ensure preditability and safety by avoiding side effects over memory efficiency but in case of mem efficiency,you can use a join method which takes all the strings from an array to create a string which means it only copies once since arrays are mutable and thus,pushing to an array doesnt copy the array while in rust,the String object is directly mutable and is passed to functions by reference meaning that if you pass it as an mutable ref to the function,the function can create side effects on the string.In rust,you can choose where the string data will go by either using a ref to a string in the static storage which is fixed in size and doesnt copy the data but rather borrows it or by using a string object which allocates its data in the heap.so the final string from format is more time efficient but less memory efficient than concatenation although concatenation can lead to temporary memory spikes during the reallocating process.Format is preferred when working with larger strings

*The &str is a borrowed type so assignments to it is by reference while The String type is an owned type so assignments to it transfers ownership

*There is assignment by copy,borrows it and by taking ownership

*A slice must be a reference because the value cannot be known at compile time and it shouldnt own but borrow the data since its used for read-only operations.Since they borrow data,any changes to the original string will be reflected in the slice unless a modification is done to it that requires a reallocation which will not reflect the changes in the slice as the slice still reflects the old memory address and not the new one.The reason why slices dont change the address they point to because they dont own the data,they are just referencing the data for borrowing.

*String characters can be represented as Unicode or Ascii.Both of them are converted to their byte representation when storing their data in a string since a string in rust is a vector of raw bytes.Since they are stored as a sequence of bytes,indexing is a direct access to a byte and not a character.When indexing for bytes that hold for ascii character data,rust implicitly converts it back to its character representation since an ascii character will always correspond to 1 byte but if you access a byte from a unicode character,it will panic and throw an error because in unicode,no single byte corresponds to a valid character as a unicode character is made up of more than 1 byte but rather,it takes a variable length because and depending on the encoding.Common unicode characters are 2 bytes while more complex ones like emojis are 4.Although,if rust allowed the indexing feature even for unicode characters,it will just return the bytes directly if it cant convert it to a valid character because rust will have to return some data but doing this will create unexpected behaviour later in the code if not careful.So rust prvents errors like this from ever happening by totally removing the indexing feature.

*Slicing is a safer way because it guarantees that the slice will correspond to a valid character given that the slice is valid.Rust will then convert it back to its character whether unicode or ascii.But slicing can lead to runtime errors if they are invalid.Indexing makes it impossible to read unicode characters from a string but slicing allows it but you have to care about character boundaries.

*Because slicing can be invalid,rust provides another method of safely accessing the characters of a string.By using the chars method which will iterate through the string and stack up the bytes till they create a valid character called a code unit and return each code unit to a new array which is closer to how other programming languages like js choose to expose strings to the programmer;as a sequence of characters.But you cannot index into that because it isnt literally an array so you can only utilize it by looping over it.

*Rust uses utf-8 while js use utf-16.Utf-8 can take both ascii and unicode characters.Utf-8 is a variable length encoding which can manage space flexibly but can create complications as it is in rust while utf-16 is a consistent character encoding.For example,utf-8 encodes ascii characters as one byte while utf-16 encodes all characters into at least 2 bytes allowing a wider range of characters to take up consistent space but less common characters like emojis can take up to four bytes in both algorithm.Utf-8 is termed that way because characters can take at least one byte or 8bits while utf-16 takes at least 2bytes.The reason why utf-16 is consistent because many values can be encoded in 2 bytes.This consistent space allows js to represent arrays as a sequence of characters which abstracts from the complexities of representing it as an sequence of bytes as it is in rust so indexing in js is by character offset or code unit.It allows for a character oriented access over a byte oriented access to strings like rust.In other words,many programmers wont have known about any of this if they didnt learn languages like rust that didnt choose to spoil them with sweet abstractions but at some point,you'll care about space.

*Utf-8 is more memory efficient but more complicated as you have to care about character boundaries.If you return a byte thats not valid,youll get the byte and not the character which will lead to unexpected behaviour later while utf-16 is less complicated but can consume more memory for the same characters.So js uses a code unit representation through utf-16 while Rust uses a byte representation because they use utf-8 that encodes the data directly in bytes due to its memory efficiency.Its a system programming laguage so it has to deliver performance.Python uses utf-8 only when storing or sharing the data and actually holds the data in a sequence of unicode points internally which is an intermediate rep of unicode character data.This allows for simplicity and abstractions like js but memory efficiency when sending or storing the data like rust.

*A code unit is the collection of bytes that makes a valid unicode character while a code point is a unique number assigned to each character in the unicode format which gets converted to code units

*C++ like rust use utf-8 but allows for direct indexing but this is only safe when the characters are ascii.So you wont have to worry about boundaries and encoding until you start using unicode characters that span more than one byte unlike rust where it prevents you from ever indexing into a string so you have to care about this from the first time you want to access specific characters from a string upfront.Apart from this,the level of abstraction and control are the same.In both of them,if you need to safely access unicode characters from a string,you loop over a sequence that tokenizes the bytes into code units except that in rust,its provided in the standard library while in c++,its provided by user made libraries

*in these system languages,you will be forced to learn about low level details even if you dont want to as long as you want to use these languages because you will literally not go anywhere using them without attempting to understand the details that you will normally wont care or procrastinate to learn if you are using python and js.

*The char method returns an iterator of the unicode units that makes up a string.

*There are two ways to create a sequences;a random access sequence or an iterator sequence.A random access sequence like a vector will require an allocation on the heap that will cost memory and reduce time performance because of allocation time but once complete,it becomes very fast for lookup operations while an iterator doesnt take any data from the heap because the data is yielded value by value as the code runs rather than storing it in a collection that will require allocation and thus,it optimizes space performance but its slower for lookups.An iterator is a function that yields values and retains state of where it is in the sequence.Yielding means that it will return the current value and hand over execution till its called again.

*Char and slicing are both different ways of accessing unicode units from a string except that char is safer but requires you to loop over the iterator every time which might be less accessible when trying to access many characters as you have to store all of them in a vector first which will bring allocation costs on memory and speed while slicing allows you to directly access the data but requires upfront knowledge of the right character boundaries.They both conserve memory since they both dont take memory as slices just borrow the data while char iterates over the data.But slicing is more accessible for accessing many characters and its faster since it doesnt loop over anything as its direct access and it will even conserve more space if multiple-character accessibility is needed So these two methods are a trade-off between (speed and easier multi-character accessibility) or (safety and lack of prior boundary knowledge).Its better and recommended to start with chars for safety as it aligns with rust principles but use slicing for performance

*The keys and values of a hashmap must be of the same type.

*A vector is basically a heap allocated array

*When treating an option object from a vector or hashmap,we can return a referece or a copy using the .copied method.If we don't want the value of returned to the variable to reflect any further changes to the vector or hashmap in the program but it will increase memory consumption although insignificant in the case of small integers,chars or booleans but we can choose to use a ref and not a copy if we want to opt for more memory savings and its ok or needed for it to reflect any changes to the collection in the program.

*if the collection doesnt get updated in a way that affects previous values like push or insert operations,using a ref is better since it saves that extra 4 bytes or more and will still provide the same output as copying it.

*You can use the .copied method on anything to copy data thats on the heap.

^Borrowing it,owning it,copying it are the different ways to do assignments.A copy becomes independent of the source.The owner becomes the source while a borrow becomes dependent on the source

*When looping over a collection in rust,we should use a ref to ensure that the loop doesnt own the data.An immutable one for read and a mutable one for write operations.

*For keys and values that their data are on the stack,the heap owns the data but for data on the stack,the map copies its data

*I cant pass references to a temporary heap allocated data like string objects used directly on the fly without an assignment.This is because it will lead to a dangling reference as the data will be dropped immediately after use because it doesnt have an owner.Rust prevents this from happening but not c++ where it will lead to undefined behaviour.You can work around this by lifting the temporary value to a variable that will take ownership of it and the program will execute safely without creating a dangling reference but if it were an integer,there is no need to lift it as its in stack memory and will be copied if needed.

*The ownership model is the solution to all these mem management pitfalls but rust requires you to figure out how to work around it to still execute what you want but in a memory safe manner like through lifting temporaries which one will have to discover on his own making the programmer fully responsible for the memory usage of his program

*You cannot have a mutable ref after an immutable one to prevent undefined behaviour in parts of the code that wants to read the same value and accidental modifications to the value before its used.

*You cannot borrow a value mutably if the owner isnt declared to be mutable.This is to ensure that any data mutations is intentional and not accidental.Its a double check.Thats why variables are immutable by default.This is different from python and js where variables are mutable by default which can cause unintended side effects like when arrays are passed to functions.New devs wont know that they are passed by ref and can cause accidental modifications while in rust,even a vector thats passed by ref still requires permission before its modified.

*Hashmaps must have unique keys so inserting a value with an existing key overwrites the old one

*rust requires that you either have one mutable borrow or multiple immutable borrows but not at the same time.you can only create immutable refs after a mutable one which will invalidate the mutable one.The borrow checker is like a permission controller;immutable refs have read-only access while mutable ones have read and write access.

*integers,booleans and chars are stored in the heap only when they are inside collections which are stored in the heap.So using those values requires a ref.The vector structure itself is stored in the stack because the pointers go to the stack but the intger data goes to the heap.So you can control the allocation of the integer data to either the stack or on the heap

*mutability and immutability is independent of whether the data is stored in the stack or heap.the reason mutable integers go to the heap is because its allocation is fixed regardless of how the data is mutated which means that whether data goes to the stack or heap isnt about whether it will be changed later but whether rust knows that the allocated space for the data wont change after compile time.Integers have a predictable memory allocation according to their type regardless of how large the value is.The same for character and boolean which have a predictable allocation of one byte so all of these go to the stack.But we can never predict the space that a vector or a string will take and as such,they go to the heap.

*You can read the value that a reference holds by directly using it but if you want to modify the data that mutable references borrow,you have to use the dereference operator *.This is to ensure that you are intentional about using the mutable reference to modify the value at a particular part of the codebase when you mistakenly meant to use it for reading at that point.

*Assigning a variable that has stack allocated data to another variable copies the data unlike for heap allocated data like string which transfers ownership.If the variable holding the integer data doesnt change,copying it to another variable will be memory inefficient so using an immutable ref to another variable is better.But there are some complexities about opting for immutable refs because of memory efficiency;

*There are three ways to modify the data stored in a variable:by overshadowing/redeclaring,by mutating it and by reassignment.Modifying a variable by directly assigning the variable to a different value after its initialiation and declarartion as mutable is modifying by reassignment.You cannot modify a variable like this after it has been borrowed like incrementing a variable after it has been borrowed by a ref.This is because it will hold its newly assigned data in a different location whether on the stack or on the heap and making the older one invalid.This will make the borrowed variable a dangling reference because it no longer references a valid memory.So there are three ways around this;You either perform the reassignment before borrowing it,2.you use a mutable reference to change it because it directly modifes the data at that address without changing its location unlike reassignment or 3.overshadowing the variable.This is because overshadowing is pretty interesting in how it works.Overshadowing redeclares a variable not just reassign it.It allocates data in a different address but it doesnt invalidate the old one because it declares the variable as if it were a new one entirely meaning that any borrows to it before it was overshadowed is still valid.The preferred approach is to use mutable refs unless you dont want mutability where you will then use overshadowing another way to prevent all of this as a whole so that you can still reassign to modify the variable after its been used by another variable,is to copy the data over to the other variable and not accessing it by reference.

*order of priviledge:read-only,read and write,ownership

*so one can start with rust if they dont want to shoot themselves in the foot but they will learn about mem management by working with the compiler when it throws them errors while starting with c++ means you are starting out writing buggy software then coming to rust for safety later.Rust is better for beginners,it forms good habits early unlike c++ where you suffer enough from the bad ones and then learn why the good habits exist.This is the nature of Rust to C++ and C++ to rust transitions.

*panics and fallbacks are different ways of handling unexpexted behaviour.A panic will make the program to abort while a fallback will give the program a way of handling the situation.A fallback is more user friendly while a panic is necessary from stopping something critical from happening to the program.A fallback creates fault tolerant code that happens under expected conditions while panics should happen when under any normal circumstance,should something happen else allowing it to execute can lead to critical damage.The get() method fallbacks while indexing panics in vectors and unwrap panics while unwrap_or() fallbacks.

*entry doesnt overwrite.It only writes a value to a key if the key doesnt exist and returns a mutabl ref to it to the map.

*another thing is that panics shouldnt give stack traces as error outputs because every piece of this data can be used by attackers to know where in the codebase and perform variations of what they did to understand how the code responds to errors and over time,get full information about the error handling checks of the program and try how to crack their way around it by creating unchecked circumstances but having writing the program in rust will slow this down since memory and race condition vulnerabilities are removed by rust

*Any information thats meant to be used only development that gets exposed to production environments is called a leak.A leak in itself doesnt mean an instant defeat to the program but it can expose enough information that hackers can use to craft sophisticated attacks.Using environment configuration files like .env files with a tool like Git leaks can help prevent this and anonymizing logs can prevent this isssue.

*rust also ensures that you pay more attention to your code.

*The or_insert method returns a mutable ref to the value of a specified key in a map.If the key exists,it returns a mutable ref to the value as it is else,it inserts the new value and return an immutable ref to that

*attacks by memory corruption,by unsanitized inputs,race conditions,program intel

*Inconsistent outputs

*so a hash table is a function,an array and an optional linked list layer.The function takes a key and uses a function called the hash function to generate an index to the underlying array.The underlying array holds the data.But in the case of collisions which is when two keys maps to the same index,a method called chaining where the value at that index in the array is a pointer to a linked list where series of k-v pairs occur and secret key is like salting against rainbow tables where even if they get the input right,it will never collide with another key.It is used by the siphash function which rust implememens.It may not be the fastest but rust prioritizes security over performance.Hackers can take advantage of collisions by creating a vast amount of inputs that collides with others which creates multiple linked lists that can crash the program and slow it down for other users leading to Dos attacks.If they create keys that collide with legit data,they can use those keys to overwrite that data.Because of the way collisions are handled,keys dont get access to the same data even if they collide but existing entries can be overwritten and attackers can exploit dos attacks

*Python and js use general purpose hashing for typical use cases and overall good perfromance but its not highly collision resistant like siphash that rust uses.

*An implementation is a variation of a programming language in terms of its compiler or interpreter.It represents a different way of writing the compiler or interpreter for that language, often with unique optimizations, features, or behaviors.Js has different implementations based on runtime environments like node js and the browser engine like v8,spider monkey.Python has cython,pypy etc.Different implementations have various optimizations.

^Pypy is a jit compiler for python.its just like java rather an interpreter like cython.Old js usef an interpreter but modern engines now use a jit compiler.Its like C# and java.cython is a transpiler of python that converts python to c

^In linux,bash is the go to programming language because of its command-oreiented nature.it is not like other programming languages for building but rather for utilizing the usage of many clis.You write prompts or commands not code

^Compiler,Interpreter,Transpiler,Jit compiler

^Web assembly is a compilation target.

*A server and a database is just like your os to the file system

*Jit compilers compiles code to bytecode which is a platform independent and intermediary format that can be compiled later to a specific platform

^Api client,text interface,command interface,graphical interface
*We use api clients to communicate with js servers

*Commands are like queries.They are declarative and focus on getting data

*You can choose panic and clean up or panic and abort.Clean up will step up through the code from where it panicked and free any memory that was used by the function while abort skips this.

*Rust libraries can panic in response to code in our own codebase

*Accessing a vector beyond its index will panic but in c,it will read past the memory block of the array leading to a buffer overread which is a vulnerability.The reason why rust panics here is so that it prevents this vulnerability from continuing running

*You can allow backtraces.A backtrace is a display of the series of function calls that lead to the error.

^result and option enum

*Enum destructuring is taking out the encapsulated data from an enum variant.You can do this by pattern matching statements like match,if let and let else

^Array unpacking,object destructuring and enum destructuring

*if let and let else are when you only care about one pattern like option but match is better for patterns that returns the Result type

*You can match an enum against a pattern and choose to destructure it

*Pattern matching can be a bit verbose and as such,rust provide methods that shorten it;unwrap--which destructures the enum variant and panics if it isnt a success and expect which is the same as unwrap but allows us to control the panic message.The message in expect shouldnt be why it failed but why what assumption was wrong that made it to fail by convention

*throw/assert and catch
*Result type,panic,validation and expect

*Rust chooses to propagate errors to the caller

*the code should panic when assumptions that should always hold true have been violated and executing further can be insecure and harmful.Panic is also useful when an external library is bugged somewhere that your codebase cant fix so it panics as it isnt under the control of one's codebase

*The standard library in rust panics when one tries to operate on invalid data because of safety vulnerabilities and returns a result for other errors.

*There is a difference between recovering and fixing.Recovering means that even if there's an erro,the caller can go around it but when it panics,it can only proceed further when it fixes the way it calls it.A function can also panic if its contract as defined in its signature has been violated.

todo:Read rust chapter 9.2

*validation by parsing or by a class constructor

*A way of validating user input is by using parsing which will parse the input to the correct type and return a result which can be an error if the parsing failed

*Repeating many checks for data validation becomes cumbersome across many functions.We can instead lift the validation logic to a type that always guarantees that the data that we are working with is validated.We do this by using a struct that encapsulates the data we want to validate in a private field so that the caller cant directly modify this value.The constructor will validate the input and return an instance of the class if its valid or panic if its invalid.The data can then be accessed by a getter since we made the field private.This is more readable and safe

*so there are two different paradigms in handling runtime errors;the error as value and error as an exception.Error as an exception is aimed for simplicity and primarily for user experience.Every runtime error that uses this paradigm stops the program as it throws the exception not because of a possible harm or vulnerability but because the programming language doesnt know what to do next and as such,it has to be caught explicitly by the program to guide the language on what to do or the programmer fixes his code.The programmer can fix his code if it isnt expected or catch it if its expected and can also throw an error explictly when an operation is meant to fail for some reason but the thing here is that every error can be caught allowing the program to proceed using the codebase with a possibility of mitigating security while Errors as value is a different approach.This paradigm goes for security and predicatbility.Errors here are explicit.Under normal circumstances,rust and the codebase wont throw an error that stops the program to stop at runtime but rather,any possibility of an error failing has to be explicitly stated by the programmer and the error is handed over to the user of the codebase to decide how to recover from it but when the program attempts to do something that violates normal conditions,rust or the codebase will throw an error that cant be recovered or done around as it is in exceptions where every exception can be caught.This is not because rust or the codebase doesnt know what to do but because if it proceeds,it may lead to severe damage to data or the user of the codebase.The reason why js and python go for exception is because of its use for developing user friendly applications while rust goes for error as value because being a system level language means that it has to be secure when using the resources it has priviledges to

*Variable data that goes to the stack must be written at the signature

*so are tuples fixed at compile time because its not possible to create a data structure that has different allocations for each element on the heap.So in vectors when i say vec i32,it tells rust that whenever i want to modify this vector,it only allocates and deallocates 4 bytes but if it were to hold multiple types,it will have variable allocations and rust cant predict the best allocation for the element that will be inserted into the array and if it did,it may lead to wasted memory.But js and python allow arrrays of different types but this is because they have runtime overhead that will come at the cost of performance which rust cant afford and even at that,in js,i cant create a typed array that has variable allocations like one is int32 and the other is int8 at runtime.So the overhead that js and python do for an array of different element types at runtime is resolving their types and not predicting variable allocations

*Any predictable knowledge must be given at compile time.

*Tuples are fixed at compile time because its not possible to create a data structure that has different allocations for each element on the heap.So in vectors when i say vec i32,it tells rust that whenever i want to modify this vector,it only allocates and deallocates 4 bytes but if it were to hold multiple types,it will have variable allocations and rust cant predict the best allocation for the element that will be inserted into the array and if it did,it may lead to wasted memory.But js and python allow arrrays of different types but this is because they have runtime overhead that will come at the cost of performance which rust cant afford and even at that,in js,i cant create a typed array that has variable allocations like one is int32 and the other is int8 at runtime.So the overhead that js and python do for an array of different element types at runtime is resolving their types and not predicting variable allocations

*Runtime information cannot be known ahead of time.

*Dynamic allocation is done at runtime but the individual elements that makes up the collection must have a fixed allocation size known at compile time

*In c,c++ and zig,i can control the allocated space at runtime using condition checks except that zig allocators are safer and the intuitive way of using the language while c and c++ offer this at the cost of safety while rust doesnt give me control over the allocator so despite that it does dynamic allocation at runtime for shrinkable types like vector,the space to be allocated for each of the elements in the collection must be known by rust at compile time.Rust does this to ensure safety.

*C,C++,Zig,Rust,Nim

*so ? is a shorthand like unwrap.They both check for variants,destructure them and return it to a variable except that when unwrap encounters an error,it panics,for unwrap_or it recovers by returning a default value and for the ? operator,it propagates the error to the caller.? is good for propagation,unwrap is good when you are certain that an error shouldnt occur and unwrap_or is good for recovering from the error by providing a default value to fallback to.

*Ways of matching and destructuring:match case block,if let block,let else block.

*The structure of the struct and enum itself is stored on the stack as pointers but the actual allocation of the data varies on the type.If the data is of a fixed allocation,it is stored directly with the struct or enum but if its dynamic like string or vector,its stored on the heap and the field or variant is a pointer to its location in memory.

*i32 for example,is stored on the stack but if its in a collection like vector or hashmap,it goes to the heap in a contiguous block but the actual vec structure is stored on the stack and it becomes a pointer to the first element.

*So for vectors,structs and enums,the structure of it is on the stack but the data itself will be stored on the heap if its a vector or on the stack or heap if its a struct or enum. data can go to the stack or heap depending on whether its allocation is known ahead of time through a type annotation that has information of allocated space but vecs and hashmaps of anything moves data to the heap.

*so with i32 in a vector,i can tell rust to only allocate 4 bytes for each data in the heap.so even if its 0 when i allocate 8 bytes,it will always take 8bytes of space regardless of whether the value fully uses the space.So type annotations can help me to control allocated spaces

*An enum will take the size of its largest variant that means that even if a variant takes 1 byte of data,the entire enum instance itself will still take 8 bytes assuming that 8 bytes is the largest variant.This is a design choice because rust doesnt allow variable allocations for safety and predictability.Rust ensures that all allocation information is known at compile time.

^Ill create an allocator that allocates the smallest space that can contain a particular variable at runtime but it means that the variable itself cant be modified after it has been pushed because it might be bigger than its allocated space after modification so it will be immutable but the collection itself can still be used to add or remove elements.If there is any needed to modify an element after,it will lead to a reallocation where the allocator will then calculate the smallest space that can hold it and then take it to the vector by replacing the one at the original index with it although it will lead to consnat reallocations on every modification so each element will be immutable by default.This is because the allocation itself is determined by its initial value.i want to use this to create an optimized vector since all the elements of a vector must take the largest allocated space for any of the elements which might lead to unused space from other variables

*Rust allocates more space for strings than required to prevent constant reallocations

* strings themselves also have predicatble allocations.its actually a vector of 1 byte per element.So strings have the perception of taking the smallest amount of size required for the string seeming like variable size allocation but its actually a predictable allocation.Its true that strings and vectors themselves have variable allocations but the elements in them have predictable allocations.

*the problem about predictable memory allocations is that they must be true for all elements in the collection which is too general of an assumption that may lead to unused memory by some elements thus causing fragmentation

^so this is the normal vector:Vec<i32> = vec![12345, 6789, 1000000, 2, 56, 789, 12, 345]; taking up 32 bytes but mine:Vec<i8>[12,34,-5,67,-89,10,-105,-2,-56,78,-9,12,34,-5].the 105 reads 5 zeros in this chunk.the positive number to the negative number concatenated together after removing the neg sign reassembles the original element separately from others.this will take 14 bytes.

*so the rule is simple:chunk the integers in the vectors into two digits.the last one or two digit chunk that's part of the integer will have the - sign to indicate that its the last chunk so when it needs to get reassembled,all the elements from a positive chunk down to the neg one will be concatenated to give the original integer.the - will not be involved in the concatenation as its just an indicator that will be ignored during the concatenation process.To represent something like 100000,where zeros will be a chunk but will lose info as it will just be 0,it will use 200s to rep the count of zeros in this chunk by ignoring the leading two and reading the values after.This means that at most,it can rep 55 zeros which is big enough for many numbers.100s will be used to indicate that a chunk is negative.this will always be the starting chunk of an intger if its negative.it will ignore the leading 1 and count the remaining two digits as the chunk so 199 will be read as -99.The choice of purpose for the 100s and 200s is so that a large range of zeros can be rep while also allowing neg integer chunks of any size to be a valid i8 type as a chunk wont exceed two digits.The 100s can have the neg sign to indicate that its the last chunk for that integer.216 no longer rep 16 zeros but 6.the offset is 10 since 201-209 is used for sparse zeros 

*this algorithm makes the individual elements of a vector to take the smallest amount of space it can take rather than every element taking the space of the largest integer that will not be utilized by all elements.A direct solution would have been to create an allocator that does variable sized allocations for each element in a vector but that will be complex.a workaround is the algorithm i made.It gives the perception of a variable sized allocator but it actually just takes advantage of the problem to create more accurate predictable allocations.it manipulates the problem to become the solution.thats a workaround rather than a direct solution to the problem like a new allocatorA vec<i32>[123456,90,12000] will have 12 bytes because rust will make each element take the size of the largest integer for predictable allocations but only the first is 4,the second is 1 and the third is 2.So my algorithm rerepresents the vector in a way that ensures that the element doesnt take more than required.My algorithm will turn this vector to: vec<i8>[12,34,-56,-90,12,-213].This array then takes 6 bytes.which is what it would have been if rust did variable based allocation.The first three chunks 12,34,-56 is 3 bytes.123456 can actually be rep in 3 bytes but because rust doesnt have i24,it rounds to 4 bytes but my algorithm makes it to only take 3 bytes.it reads from the first chunk and concatenates it with the adjacent one till it hits a chunk with a neg sign which indicates that that chunk is the last one for this number.the fourth chunk -90 is for the second element 90 which only takes one byte and 12000 is 12,-213 which reps 12000 in two bytes.If you use the vector from this algorithm it will seem like a normal vector that somehow uses some variable allocator but really,it represents the vector in a way that leads to more accurate space savings.its still uses an i8 so it is actually still using a predictable allocator

*so a workaround is just a reinterpretation of the problem.It doesnt directly solve it but rather,it manipulates the limitations cleverly to become the solution which doesnt require changes to the underlying system .While a direct solution will require a new different approach to the underlying system which is more complex but leverages standard approaches that guide its implementation.Since the workaround doesnt actually change the internals,it leads to code thats easier to understand and doesnt require any new integrations.The workaround is a clever approach while the direct is a standard approach but both can achieve the same effect like my algorithm over using an actual variable allocator.

*so in rust,the constructor explicitly returns an instance and its the instance methods that have access to self implicitly but in other programming langs like js and python,the constructor doesnt explicitly return an instance of the class but rather uses self to set parameters that belongs to that instance

*match case,if let,let else,while let

*its only &str slices that i can safely slice into

*If you attempt to read past an array,it will lead to a buffer overread and if you attempt to store a larger integer than what was allocated,it will wrap around the value which will lead to heavy data loss

*turbofish syntax is for supllying type annotation to functions that accepts them as generics

*so usize is just a platform dependent unsigned integer.whats so different about this from u32 or u64.This ensures it can address the maximum possible size of a collection on the given platform.

*all slices must be a ref because the size cant be known at compile time.A slice is just a view into a portion of an array or vector.

*"" is for string literal while '' is for a character

*References to temporaries are only valid in cases where the function copies the content from the reference and not borrow it like that in concatenation

*To convert a string to a number,we use the parse method and for vice versa,we use the to string method.the parse method returns an option object.

*generics are resolved at compile time

*By using rust ownership system,you can create a function with an empty body and a signature that takes ownership of any variable passed to it to directly control deallocations.although this isnt a common practice and its still safe,its recommended to allow rust control the deallocations for you.

*data on the stack can never escape its scope.it can only be copied to another while heap data can live beyond its scope by transferring ownership to data to another scope.This means that the lifetime of heap data can be extended while stack data cant.Box allows us to make stack data go to the heap for extending its lifetime

*Box makes it easier to manage the lifetime of any data by making it have ownership semantics which is easier to understand than returning copies even if its at the end of the scope where it will be immediately dropped

*Rc allows to create multiple owners ensuring that the data is only dropped after all the owners have gone out of scope.This is good for shared data

*unsafe is a block of rust where rust allows the programmer to use raw pointers and the rust compiler wont check if its safe because there are no guarantees or rules.Its like proceed if you have acknowledged the consequences.

*Any literal used in code without being assigned to a variable like in an if statement will be dropped after that line.does this temporary data go to the register

*smart pointers are best for dynamic sized types,complex lifetimes and shared ownerships

*The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the length of a vector, which specifies the number of actual elements within the vector. If a vector’s length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.

*in order programming languages,if statemenst cant return values outside of its body to a variable directly but only to outside of a function like python and js and thats why there is a ? operator while rust allows any scope to return values directly from itself to a variable.this allows for explicitness

*I cant typeannotate in function calls and loops only in signatures

*Literals can also have type info appended to the end of their value in the case of integers

*In rust,i cant directly access instance methods like i can in js because in js,a barebones instance is implicitly created first before my constructor uses it to set values which also allows the constructor to call instance methods directly but in rust,constructors can either create an empty instance,modify it and return it or they can directly return an instance of the struct in the end of their definition.For the first option,i have to create the self instance object first before accessing instance methods and then return that same object.For the second method,its more explicit but i wont be able to access instance methods or getters in the constrcutor.if i made an instance explicitly but returned a new struct instance at the end of the constructor it wont be the same object.So there is no valid way of combinin g the two options in rust

*in rust,objects are actually instances of structs which means that they belong to the struct they were instantiated from.The are direct representation of the struct with concrete values.While typescript objects dont belong to their interfaces as they are literals/plain objects and only conform to the contract of the interface.They dont belong to anything unless you do so with classes.An interface cant have concrete methods defined on it meaning that an object that coforms to the interface must provide their own implementation of the method in order to use it while in rust,structs provide concrete implementations of methods ahead of time for objects instantiated with them

*Structs and classes are similar but struct objects dont have to use the struct constructor.They can directly assign themselves as instances to the struct using the struct literal while classes require that the objects must be created from the constructor and structs dont support inheritance and polymorphism

*the new keyword tells ts to create an instance and implicitly pass it to the constrcutor

^Rust doesnt have null or undefined,it has option.it doesnt have void but rather,it has the unit struct() and it doesnt have the never type but rather the Result type.

*A method that doesnt have self is a class method but if it has,its an instance method.Instance methods are the only time when rust implicitly passes self to the method.its that what the dot notation is for.

*Rust has the following notations; the : notation,the :: notation,. notation,<> notation,::<> notation and the -> notation.If i want to specify type annotations,i use the : notation.For instance mtehods,its the . notation,for accessing anything from the module system and struct methods,its the :: notation, if i want to specify that a function takes generics and has lifetime information,i have to do it in its signature using the <> notation.if i want to call that same function and specify the type,ill use turbofish notation which is ::<>.If i create a struct and i want to type annotate the specific generic,its the the struct<> notation.To specify the return type of a function,we use the -> notation.In rust,i cant do methods on a generic directly without specifying the traits it implements.i can do that using the : notation infront of the generic or the where statement.

*if a function makes minor modifications to a vector,its better to pass it a mutable ref to the function.if it significantly modifies it,its best to pass ownership of the vector to it and the function can return it back once its done using it.

*The extend method copies the elements of right operand vector to another.append moves them  while + copies both vector operands to produce a new vector.Im sure the best here is append cuz its memory efficient

*Copying creates reallocations while owning only adds a ref to that vector in memory and invalidates the previous vector from accessing it. and instance methods that takes immutable refs to self only intend to use methods and read values from it while those that a mutable ref to self are those that use its setters

*so the clear method in rust doesnt remove the capacity meaning that if one wants to push to the vector after clearing it,there wont be any reallocations till it reaches the size of th evector before it was cleared while reassigning it to an empty vector refreshes the capacity meaning that there will be constant reallocations.clear is better if its going to be reused again very soon while reassigning it is better if its going to remain empty long term so that there is no wasted space

*Use shadowing when you want to transform a value without modifying the original and want to limit the scope of the new variable.use mutation when you need to change the state of a variable throughout its lifetime

*Lsb and Rsb in bitwise operators

*To get the binary of any number,you convert it to base 2 and pad it till you get 8 bits

*binary shifts,bitwise or,not and and
*logical operator

*the zeros padded infront of a binary number till it reaches 8 bits are empty slots or placeholders while the last bits are the filled slots.When i do a bin num << 2,im telling the cpu to shift/move the position of the value in the occupied slots to two empty slots to the left leaving the previous slots empty for use.when this is converted back to base 10,it gives a differnt number entirely but since we are operating at the bit level,our concern is the internal rep of the number as bits and not the overall value.if i said bin >> 3,im telling it to shif the value to the next three empty slots to the right.Padding doesnt affect the value it only allows for consistent presentation.When you shift bits to occupy a different space on the byte when there is no more space,the bits that spilled out of the byte will be trashed

*Box is also used to prevent stack overflow which can be caused by recursion.

*Bitwise shifting can lead to spillage while lower number representation can lead to wrapping.The difference in the result of the effect is based on binary arithmetic principles.

^bitwise operators can store more information at zero memory costs.
^bitwise and,or and not
^different scenario when wrapping.whats a buffer overflow
^Lsb,Msb
^buffer overflow

*unsigned integers use the msb to store sign information while a signed integer uses all of its bits to store information.

*a buffer is used in batching data to a temporary storage till its transferred somewhere like from disk to memory instead of directly writing to the destination which may take time.This allows the programmer to process the entire chunk at once instead of constant read/writes.file operations,input data and network data all utilize buffers for efficiency.when more data is taken to a buffer more than the allocated space,it lead to a buffer overflow which leads to memory corruption and unexpeted behaviour as it unintentionally affects adjacent memory blocks

*Bitwise operators perform logical operators on the individual bits that makes up a value.Bitwise AND filters bits,OR combines them and NOT flips them.Bitwise AND is used for masking bits by isolating one and clearing others.Bitwise OR is used for enabling many flags/bits at the same time

*in rust,i can write any variable's value in its value literal,binary literal or hexadecimal literal.You can in js but binary literals are always 8 bytes so its not as memory efficient as it looks but in rust,you can make it one byte or more.i can use binary directly to store many flags all in just one byte instead of many booleans that will take a byte each.

*You have to declare generics in the function signature before you use them

*The <> notation is used for defining generics.Generics can lead to a mismatch error if many field use a genercic type but dont actually use different types at compile time.Its best to have only a few generics

*When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.

*You can define generics on individual methods/functions but if you define generics in struct definitions,the entire impl block must have the generic type defined in its signature but it doesnt have to use it in any of its methods.This is so that any method in the impl block can get ready to use a field from the instance thats a generic.The reason this is so is that whenever you use the struct that has the generic,you must provide a type to it.you can provide a concrete type or another generic.impl blocks arent the struct so they cant access its generic directly so it has to supply types to it like everything else in the codebase.If it provides generics,it must use a generic from its scope which means that you have to define the impl block with its own generic using the <> notation.it can also supply a concrete type

*Generics have zero runtime cost because rust expands the method,struct or enum that uses the generics for each concrete type used in the source code into duplicates at compile time.

*Since rust is object based and not oop,you cant directly make struct fields private but you can work around it by encapsulating it in a module scope which keeps everything private unless explicitly stated public.which means that all the fields in the struct will be private and can only be accessed through methods and can only be instantiated by a constructor unless you mark specific fields public with the pub keyword.

*Modules can be accessed through a relative path if they are declared in the same file where its used

*Generics are too arbitrary so rust needs more informations on generics to validate their operations.Thats what a trait is.A trait is a method that a type implements

*A struct,an impl block all encapsulated in a module is rust equivalent to a class. this class equivalent is made by composing a struct and an impl block together.Rust calls their methods associated functions that can behave like constructors.

*impl blocks are associated with the struct.They dont belong to the struct.

*traits are just contracts like structs.combined together,they are the equivalent of an interface in typescript.They are just contracts and any implementation must be done by impl blocks or providing concrete values in its assignment

*traits are mostly used with generics because they are used for defining shared methods so that you can work with the same method but on different types.

*polymorphism is when multiple objects or types have the same method signatures but different impls meaning that traits provide a form of polymorphism

*all the methods from a trait are public by default cuz they are shared

*we use the impl for block for traits

*A method that takes self is an instance method and one that doesnt is a class method.

*when you have a library of classes,you dont have to code a new object from scratch but you can just inherit from any class you want and override some functionality.

*There can be a default trait.which has an implementation but can be overriden.

*the From method on any struct is a special constructor that takes an object of one type and return the struct type's equivalent of it

*A trait encapsulated in a module block allows for a form of abstract classe.The difference here is that traits arent inherited,they are only implemented which means that a struct can impl the traits it chooses and override it.

*The best part about implementation over inheritance is that one doesnt have to worry about inheritance heierarchy especially in languages like js that makes this difficult.you only focus on th functionality that it has.This means that new structs can be created by composing it of other blocks

*string from,to string and format

*A method in a trait can use self to call another method from the same trait even if that method on the trait doesnt have a default impl.this is because any struct that implements a trait must provide concrete impls to all the methods from that trait.but a method defined in a trait can use self to call any field or method particular to a struct that impls it.this is because traits arent meant to be shared so they are not directly associated with any struct that impls them.

*A function can take a trait as a parameter instead of providing a concrete type which means that it takes any type that implements the trait by using the impl Trait syntax.It can take it as a ref or own it.The impl trait syntax is just syntatic sugar over the trait bound syntax.The impl trait syntax is better if each of the parameters take different types but implement a particular trait meaning that the function only cares about the traits the type has and not any relationship between the parameters types but if the function requires the parameters to be of the same type and implement the same trait,then the more verbose trait bound syntax is used.The + operator is used to specify that the paramter must have more traits.The where clause syntax is used to remove the clutter from the trait bound syntax by separating the trait information into its own block separate from the generic information.A function can also return a trait to specify that it returns any type that implements this trait.This is done with the impl trait syntax although you cant have the possibility of returning more than one kind of type that implements the trait meaning that if a function returns a type that implements a particular trait,it cant return one type in a conditional block for example and return another in another conditional block i.e they must be consistent

*You can conditionally render implementations for an instance of any type by specifying trait bounds in its generic type info signature of the impl block.It means that it only renders implementations for that instance if the type it provided as a generic to the struct has the specified traits.The implementation block can also be made to conditionally implement traits and not just methods.This is called a blanket implementation.It ensures safety as it will be wrong for the impl blocks to assume that every instnace of the struct uses types that satisfy a particular trait

*the conditionally rendered method impl block is for implementing methods only when a trait is satisfied while the conditional trait impl block is for implementing another trait when another trait is satisfied.

*undefined is a variable that has been declared but hasnt been set to any value as the value is indeterminate till its initialized.So if an unitialized declared pointer is used in the code,it will lead to undefined behaviour as the memory address the pointer points to is undetermined and its very unsafe.a null pointer is a safer option as it tells the compiler that the pointer doesnt point to any valid memory address.

*Dereferencing means accessing the value a pointer points to.If you try to dereference a null pointer,you are attempting to read/write to an invalid memory address which will lead to undefined behaviour.

*An uninitialized pointer is a pointer that is declared but without a value.Rust doesnt allow it.

*a bug in a c++ program that will cause undefined behaviour is one that c++ doesnt explicitly handle,understand its behaviour or state what should happen and they are left in the hands of the environment the program runs on which can cause unpredicatble and inconsistent results.

*string literals go to the static storage which has a permanenet lifetime
*you can write binary literals on any type.for a binary literal for a byte,you use a binary literal on u8

*the static storage is storage that is directly included in the program's binary in the read only section of the program.Data stored in the static storage cant be computed at compile time

*References in rust get invalidated when they go out of scope meaning that if the lifetime of the data they ref has a more extended lifetime like string literals,the ref gets invalidated but the string literal remains in the program which means that the data a reference refers to can outlive it and to prevent the otherwise where a ref mistakenly outlives its data which can create a dangling ref.

*string literals are created at the compile time of the program and are more memnory efficient than heap allocated data because of no need for allocation costs.the compiler can reuse literals rather than creating unique instances each time.

*a constant allows me to move any data that would have gone to the stack to be included in the programs binary to have a permanent lifetime while immutability doesnt affect its location but it prevents the data from accidentally mutated

*a let variable is tied to the lifetime of its scope so outside its scope,it gets invalidated even if it holds a ref to static lifetime data but constants arent tied to the lifetime of their scope.they live throughout the program but arent visible outside of their scope so they dont get invalidated outside of their scope,they arent just visible.Its about Validity vs Visibility.Constants can be declared top level since they arent tied to any scope while let variables cant even though they ref static storage

*lifetime annotations are just constraints that we must follow.They are used in functions to indicates that the returned reference will have the same lifetime as defined by any of the parameters of the function's choosing provided that its valid.They are used to ensure you dont mistakenly create dangling references.Rust replaces the lifetime placeholders with concrete values using the lifetimes of the parameters. if the params have the same lifetime annotation,rust takes the smaller one to ensure that the returned one isnt used beyond its scope but if they are different rust uses their separate lifetimes.the problem about using different annotations is that there you have to ensure that you return the one that lasts longer as rust cant know ahead of time which one will outlive the other.If you try to use the returned reference beyond the lifetime of the shorter input, the compiler will produce an error, preventing potential runtime issues.

*lifetime annotations should have more descriptive names about the data over generic names

*0b is for binary literal while b"" is for byte string literal.The first is for manipulating data at the bit level while the second one is for writing strings in abyte format over utf-8.


^----TO BE SUMMARIZED-----------^
*A ref is a shell over a pointer

*smart pointer,pointer and a ref.so they are the same thing in implementation.they are encapsulate pointers and have meta data but smart pointers manage themselves while refs are managed by the gc

*a ref in rust is a pointer to the addres of an owner.since the ref doesnt point to heap allocated data,it doesnt need to be managed by itself,rust or the programmer,the stack pops this out automatically but a ref in js directly points to the heap allocated data so it has to be managed by the gc.so the difference here is that the first is an indirect/borrowed ref while the second is a direct gc ref

*Reassigning changes the memory location of the data it holds on the heap.Redeclaring creates a variable with a new memory address on the stack that has the same name as the owner.It will also point to a separate memory address on the heap.It creates a new variable that overshadows the previous ones meaning that subsequent uses of that variable is to the new one not the old one.Mutating doesnt change the memory location of the data it holds.it changes the data directly at the location in the heap.

*so a weak ref is direct ref to the heap allocated data but it doesnt increase the ref count in the gc for that data this means that in a gc language,all ref are direct refs and as such,they have to be managed by the gc but in rust,there can only be one direct ref which is the owner thats a smart pointer.all other refs are indirect and only point to the address of the owner.

*To access the data that a pointer points to,you have to dereference it with the dereference operator * buut rust automatically does this when you want to access the data an owner points to.

*ref to variable and ref to data
*an owner is a smart pointer.
*A pointer is a variable that holds the memory address of data on the heap

*an owner becomes a ref only whenit encapsulates a pointer.a ref is a shell over a pointer and if an owner can have a pointer,its a ref except that in rust,an owner is a special kind of ref that can only be created once.other refs will have to be a borrowed ref. but in js,all references are treated equally.

*The owner itself is stored on the stack.it contains a pointer,length and capacity information but the data it owns is on the heap.it uses internal pointers to access that data so the key here is to ensure that the stack data doesn't outlive the heap data.By keeping onwer data on the stack,it can get deallocated by the stack memory automatically.rust just checks that if it does,the heap data is dropped.C++ pointers to are stored on the stack but any heap allocated memory must be explicitly freed.whwn you transfer ownership in rust,rust copies the owner metadata from the original location in the stack and transfer it to the new variable in the new scope and invalidates the old one
*the ref points to the owner and the owner points to the data if the data is on the heap. ref stores the location of the owner on the stack
*if the ref is a pointer to the data,then isn't it the same as an owner in rust or is the difference that in rust,only one variable can hold the pointer data at a time while in js,many variables can hold that same pointervdata
*a ref uses a pointer to access the data on the heap
*a ref encapsulates a pointer and since it's a shell over a pointer,pointer operations can't be directly done on the reference
*the owner of data is actually a ref to that data but the difference between this and refs that borrow is that refs that borrow points to the owner on the stack not directly to the heap data while owners point directly to the heap data
*But if the owner only has an integer,the owner won't have any pointer.it has the integer directly in one of it's properties

*so the gc has three types of algorithms;reachability,generation,compaction and when it runs
*reachability--to free memory--runtime ref counting,marking
*generation--splitting memory to young and old
*compaction--trace and compact
*when it runs---incrementally or concurrently

*The gc uses more than one algorithm besides ref counting.Ref counting and marking are the two ways of determining reachability.Its limitation is that it cant handle cyclic ref.Another one is generational collection which is when younger refs are collected more frequently and older ones are collected less.This is based on the observation that younger ones have a shorter use case.It involves dividing the heap;reachable and unreachable,young and old.

*so a cyclic ref doesnt affect the fact that they will both point to the same heap data except that cyclic ref will never allow any of the refs to drop to zero as there will always be a ref to the ref so it will never be garbage collected leading to a leak.A cyclic ref will be dropped once they go out of scope but if there is nay ref to any of the refs in the cycle,it prevents the other from dropping its count.

*They also perform tracing which is when they mark and compact instead of cleaning to reduce fragmentation.also stop and copy to prevent fragmentation

*so in rust because there is only one direct ref i.e the owner,the variable can drop the data after it goes out of scope but because in gc languages there is more than one direct ref,no variable can choose to drop it once it goes out of scope as it will invaldate others so ref counting has to be done where each direct ref increases the count and as they go out of scope,they drop the count.its only when the gc guarantees that there is no direct ref to data i.e all the direct refs have gone out of scope,it clears it.reachability means if there is anyone using the data

*Gcs do their work incrementally or concurrently

*so marking is by crawling through all direct refs in the code,if there is no direct ref to data on the heap which means it has gone out of scope,the gc will drop that memory on the heap

*the gc doesnt run as the program runs but rather,at intervals like when the memory is reaching a threshold,when its explicitly called by the programmer or when there isnt enough space.This means that gc languages dont free memory as the program runs but only at intervals which can be less efficient if some data being used is very short lived.while in rust,rc doesnt include a gc,there is no code that manages ref counts.the owners are smart pointers so the last owner will deterministically free memory once it goes out of scope meaning that ref counting in this case,frees memory as soon as its not in use.

*The owner cant outlive the data and a ref cant outlive the owner

*the ownership model in rust as enforced by the borrow checker isnt a memory manager like the garbage collector.The gc is its own codebase that manages the memory of the application's codebase that uses the memory while the borrow checker doesnt manage the memory of my code.it only enforces rules.Its the owner themselves that manages deallocations.They are responsible for managing their own memory and the borrow checker ensures that they do.This is a smart pointer.It doesnt rely on anything to manage itself.This is because that since rust only allows one direct ref,each owner can be responsible for the memory they use but since gc languages use multiple direct ref,no direct ref can take an action or a decision on what should happen to the data it points to in memory so it requires the gc that watches out for them.but how does rust rc allow multiple direct refs without a gc and why cant other programming langs do mimic rc for a more efficient mem management unless it will require the programmer to understand the mem usage of their program as thats what they want to prevent so that they can focus on their apps

*so in rust,every owner has a destructor thats called when they go out of scope.their scope lifetime is handled automatically by the stack because the owners themselves are on the stack.when their destructors are called,they free the memory they were pointing to.This makes them smart pointers.In rc,there can be multiple owners or multiple direct refs but this will create a scenario for making a gc like it is n js but this will lead to having another runtime which will not free mem as soon as the owners go out of scope and together with the runtime costs,it is not very efficient especially for rust standards.so rust makes many owners of the same rc instance to share a state called ref count.each time thy go out of scope and their destructor is called,they decrement this shared state and if another owner's destructor is called when the ref count is already zero,it frees the memory.This shifts ref counting ti the owner themeselves and not a separate runtime making the owners still smart pointers and deterministic unlike direct refs in js an python that dont manage themseleves and require the gc as a separate runtime

*the difference between a ref and a smart pointer is that a ref doesnt manage any memory.in gc languages,refs dont manage the memory they use,so they are called refs.in rust,refs are indirect refs,they only point to the owner so there is no memory they need to manage and as such,they are termed refs while owners of String,Vec,Hashmap manage the deallocation of those data so they are termed smart pointers as part of a collection while Box and Rc,are smart pointers that only focus on the memory they use

*memory usage in rust is more predicatble than in gc languages because memory is dropped as soon as its no longer in use

*the algorithm used determines the speed and effective memory usage of an app regardless of either it provides abstractions or not but coding an app in a more memory controlled environment like rust can lead to unmatched performance if used well thoughtfully.even if you apply the same thought to another pl that uses gc,will rust outperfrom in terms of memory

*for loop uses a ref and not ownership of the vectors so that each loop counter doesnt own each element of the vector which will make it unusable after the loop.so vectors dont allow for loops to consume them unless they become iterators through the into iter method which rust calls implicitly if you try to directly consume a vector in a loop.i can also loop over it as a ref annd put both of them in a scope and continue execution in the outers scope to free the vector after loop is done.the scoping of the vector and the loop in a scope to drop the vector after the loop is good if maybe after the loop,i may use the vector for a few more lines but after that,its no longer needed

*we dereferce twice when deref refs in rust because one is to get the address of the owner and the second is to get the address of the data it points to

*i have to convert a vector to an iterator before doing functional operations

^closure before io

^-----------------------------^

xcode vs vosual studio
swift vs c#.net


^Rust has a bunch of ways of providing full and explicit access to the stack,heap and static memory.

C--raw pointers
C++--smart pointers
Zig--safe allocators
Rust--Ownership
Nim--Tunable garbage collector

^&100u8,index as u32--Type casting
^self hosting compiler

^porting vs calling--interopability
^work around,direct solution
?errors as value vs exception
?Abstraction vs control

*rust closures are anonymous functions unlike functions,closures can capture scope meaning that they are not isolated like funtions that require data that enters them to be explicitly stated.Closures allow one to skip type annotations.apart from the pipeline operator,a closure is syntatically similar to functions.liuke arrow functions,closures can remove the braces if they only have one expression.Closures must evaluate some expression on the variable they use so that rust can infer its type annotation in input and on return.if there is no expression for rust to infer the type,the first use case of the closure creates the inference info that rust will use subsequently.a variable can bind to a closure definition, and we can later call the closure by using the variable name and parentheses as if the variable name were a function name.

*a closure is an anonymous function that can be stored in a variable.depending on what the closure captures the variables from its env for,it can capture it as an immutable ref,mutable ref or by ownership.The move keyword tells a closure to take ownership of all the variables it captures.

*an fnonce trait is a closure that can be called.by default,all closures implement this trait.a closure that moves values applies only the fn once trait and can only be called once because the variables required for it to work have becom invalidated.FnMut is a closure that mutates the values it captures but it doesnt take ownership so it can be called more than once.Fn trait is applied to closures that dont mutate the variable they capture or dont even capture variables at all.they can be called multiple times safely.

*Traits for closures in rust are rules on how a closure can be called.A higher order function or method can define traits in its signature that the caller must hold if they want to pass their closure to the function

*anonymous functions are syntatic sugar over functions in all the languages but they have unique properties depending on the language.

*An iterator is a special kind of generator.a generator is a function that yields values to the caller.Theres a difference between returning a value and yielding a value.returning a value returns a value to the caller and surrenders control flow back to the it while yielding a value gives the value to the caller but it doesnt terminate the control flow from the generator.the generator can be called again to resume from where it stopped to continue giving values.a generator is lazy.an iterator is a generator that iterates over a data structure and sequentially yields the value to the caller.Generators are lazy functions meaning that they compute their values on the fly instead of all at once like functions

*calling next on an iterator eats it up or consume it.which is when calling the next value on the iterator increases where it is in the sequence.you can only call it as much times as it can yield values.The iter function only takes an immutable ref to the vector so that consuming the iterator doesnt take ownership of each element in the vector or modify it but you can use methods liek iter_mut that makes the iterator take mutable refs to each item in the vector and into_iter for ownership.

*consuming adapters are methods that are called on iterators.they automatically call next on the iterator till they consume the whole thing.an example is sum.consuming methods take ownership of the iterator

*iterator adapters like map are methods that are called on iterators that dont consume the iterator empty but rather,creates a new iterator that applies a closure on each element of the prev iterator but because these closures are called lazily,they must be consumed before they can be used and thats what the collect method is for.its for consuming iterators from iterator adapters.so the collect method collects the value from these iterators into a vector.

^next,consumer adapter,iterator adapter

*iteratiors in rust dont yield values like generators do,they instead use a struct to manage state and determine which values they should return.so they are actually just normal functions that give the perception of a generator while a generator in other programming langs can yield and resume execution and the state is managed by the langauge's runtime

*the statement for zero cost abstractions is: you dont pay for what you dont use and you dont pay when you use it

*range construct syntax [start..end] is analogous to the slice syntax in other langs; [start:end]. the range construct syntax in rust can create slices of arrays or vectors and iterators that produces values within that given range.This is also called range notation.The range object which is when its used directly without slicing doesnt directly create an iterator but rather an object that can be turned to an iterator to produce values sequentially as its implicitly done in for loops.

*There are three types of doing ranging in for loops--range function like python,range object in rust and loop counter in c++ and js

^11,12,14

**Smart pointers like String,Vec and Hashmap only store data structures in the heap but if you want to store data that would have normally gone to the stack but on the heap like integers,char and bool,you can use the Box smart pointer but putting a single value on the heap isn’t very useful, so you won’t use boxes by themselves in this way very often. 

*Having values like a single i32 on the stack, where they’re stored by default, is more appropriate in the majority of situations and box doesnt provide any better memory performance.it just stores the data in the heap instead.But box is useful to preserver runtime in functions that return stack-allocated data so that rather than copying the data and returning it which will cost time,you can just transfer ownership of that value instead.

*The reason why structs are allocated the sum of their fields is because the space will be big enough to contain all the fields that will be present while enums are allocated the size of their largest variant because only one variant can occur at a time so summing the two will be inefficient,if it were to allocate it the size of the smallest variant,it wont hold a variable thats of a larger variant and rust cant do flexible allocations at runtime to flexibly allocate space for it as rust ensures that all allocations must be predictable or known at compile time.

*so a two way relationship breaks the ownership system because it becomes a recursive or cyclic structure and rust decides the memory allocation for a struct by summing the sizes of their fields or enum owner at compile time by giving it the size of its largest variant and if it were a recursive type,it will allocate an infinte amount of space to that type but it wont destroy the heap because rust will be lagging on determining the space to allocate to the type before it does use the space on the heap.

*The enum owner itself will be the size of the largest variant and its stored on the stack but the data of the variant itself is stored on the heap and the amount of space it uses depends on its type annotation


*A linked list is just an array that distributes its elements to random locations on the heap instead of a continuous block of memory.Since the memory address of each element is random,it cannot be indexed using pointer arithmetic to retrieve values which prevents access by index because a linked list disperses the elements on the heap and the only way to get the next element is by using the pointer of one element that will lead you to the next one but it will require you to start at the first element because lists like arrays decay to the pointer of the first element.The type of each element in a linked list has to be a struct that holds a value and the pointer to the next node in the list.

*the cause of memory leak is not freeing memory after use and the cause of fragmentation is constant reallocations and reallocations also cost runtime.

*Resizing vectors will create a reallocation where the compiler will look for a contiguos block that can hold its current size but to prevent constant reallocations,rust assigns a capacity which is extra space than the vector needs at the moment thats proportional to the size of the vector each time the vector grows to prevent the need for future reallocations if it grows in size.This may cause internal fragmentation because of the possibility that the vector will not use up all that space but if its not done,constant resizing like pushing will lead to  reallocations that will cause external fragmentation and external fragementation can cause resizing and future allocations to fail.clearing a vector removes the elements but keeps the capacity to prevent reallocations that will cause fragmentation but

*but because external fragmentation will only affect Strings and Vectors and HashMaps because they each use contiguous blocks of memory for their implementation,linked lists can be allocated despite this because each of its elements are scattered bypassing external fragmentation.

*stack data is for holding one value while heap data is for holding a bunch of values together.

*structs and enums only take one block since rust calculates the size required for them so they go to the stack

*null terminator or length as part of the metadata so that the compiler doesnt read past the block.

^heap data is for collections
^owners are stored on the stack but their values can be stored in the heap but the const are owners that are stored in static storage
?is an owner a k-v structure
^single linked lists in rust are created with recursive types using the Box pointer
^recursive type and a cyclic type
?does rust allow optional fields
^boxes can do recursive type but not a cyclic type
^smart pointers like vec,hashmap and string move stack allocated data to the heap but stores it in a collection that can grow and shrink.String is a smart pointer of characters
?why do characters take 2 bytes

*the heap doesnt have a neat grid structure or a particular layout
*the stack is like putting wooden blocks of various heights on top of each other while the heap is a wide wooden board where the wooden blocks can be placed anywere without any layout drawn on the board like a grid that will define where the blocks should go.Each variable in the stack is its own memory block and each scope creates a stack frame which is a collection of these blocks stacked together in a collection and when the function exits,the stack frame is popped off.

*if a struct is so large that it will lead to a stack overflow,you can use the box smart pointer to move it to the heap

*the size of a vector is the number of elements it has while the capacity of the vector is the amount of space allocated to it whether its bigger or smaller than the actual size needed

^enums is rust safer version of unions
*so it isnt just rust where each element in the vector takes the largest memory that any of the elements take.even when using enums in rust or unions or variants in c++ to store a vector that seems to store elements of various types,it only keeps track of the type and doesnt affect the fact that each element will take the size of the largest type.Its just use to preserve type information.This is for simplicity,reduced overhead and to prevent inconsistency that can have undefined behaviour

*the dynamic size is just determined by how many memory blocks it has.its flexible that blocks can be added and removed but the blocks themselves take a fixed space.by the functionality of heap to provide dynamic sizing which is just the placement or removal of memory blocks makes the heap just used for managing multiple memory blocks for a variable that stores other data

*Data on the heap has a lifetime thats not tied to the scope of the program because they exist outside the program so they must be freed manually but rust enforces borrowing rules

*The stack is for variables where the number of memory blocks that will be used for a variable must be known in advance or at compile time while the heap is for when the number of memory blocks to be used for a variable can be known at runtime

*the stack can also hold multiple memory blocks for a variable but the reason why memory blocks cant be removed or added anywhere in the stack other than the top is because it will dirupt the lifo order which will cause the other blocks crumble down from the stack but in actual implementation:it will complicate predictability but in the heap,the memory block can be removed without affecting any other one

*since the data on the stack is in a lifo order,you cant remove any block,you have to pop off the entire stack frame at once to clear any variable in a scope.

*Because a Box<T> is a pointer, Rust always knows how much space a Box<T> needs: a pointer’s size doesn’t change based on the amount of data it’s pointing to. This means we can put a Box<T> inside the Cons variant instead of another List value directly. The Box<T> will point to the next List value that will be on the heap rather than inside the Cons variant. Conceptually, we still have a list, created with lists holding other lists, but this implementation is now more like placing the items next to one another rather than inside one another.

*deref a box means taking ownership although one can reference the dereference to avoid ownership.

*You cant return an option and another type in a match.they both have to return option so that the programmer explicitly handles the cases of no value

*Its better to make structs own all their data for simplicity and removing the overhead of managing lifetime annotations even if the data wont shrink.

*the diff between a smart pointer and a ref is that a smart pointer can manage its own mem while refs cant.refs in rust are indirect refs while smart pointers are direct refs


*Using a pointer uses the memory address and not the actual value.To use the actual value stored at the address,you have to dereference it using the * operator,it is an operation on a pointer where you retrieve the data from the memory address that it points to.But now there are two types of smart pointers in rust;one-one smart pointer and a one-many smart pointer.You can only explicitly dereference a one-one smart pointer like Box and a mutable ref.for the Box,when moving a value out of the it,it is expicitly dereferenced but if i try to access fields on it,rust will automatically deref it for me so trying to deref it in this case will deref it twice and rust prevents it from compiling.After this operation, the Box is no longer valid for accessing the data since ownership has been transferred.It only allows explicit dereferencing on mutable refs and one-one smart pointers because if rust were to allow one to deref a one-many smart pointer like pointers to collections like vec,string or hashmap,it will lead to confusion and raises a lot of questions of what doing that actually means.Some may think that it will deref the entire collection but others and rust assumes that you typically want to access an element rather than the entire collection as it is consistent with how collections are usually used. so rust provides methods over these pointers and direct usage of the variable in reading and assignments that makes it clear what you are trying to do with that collection through the pointer.You cannot use an immutable ref to deref at all because if you use it to deref and assign,it will modify the value which can lead to races if anyone is going to use the immutable ref and if you use it to deref and return,it may transfer ownership which will make the immutable ref dangling.You can only deref an immutable variable in two strict conditions;if the data you are dereferencing to implements the copy trait or you are printing it to the standard output so that you dont move it out but rust does this implicitly in this way but mutable references have to be explicitly dereferenced when assigning the variables they point to to a new value and when they want to mutate the value they point to.

*There is explicit and implicit dereferencing.You can explicitly dereference in two ways;dereference and assign or dereference and return.When the deref operator is on the left hand side of the assignment,its deref and modify but if its on the right,its deref and return.You can only deref and assign with mutable refs to data.You cannot deref and return with a mutable ref if the data doesnt implement the copy trait as rust doesnt allow mutable refs to move data form their owners if the owners are one-many smart pointers but you can for one-one smart pointer like the box and it will transfer ownership.


*both get and indexing must return a reference to an element in the vector while remove removes it from the vector and give ownership of that value to a variable meaning that i cannot directly index into a String and give it to a variable.You have to do referencing and indexing at the same time to do this.If you remove an element from a vector,trying to access it will give index out of bounds error if the index of what you removed is greater than the new size of the vector 

*boxing doesnt provide any better memory savings for integers or chars as their allocations are known at compile time and it only provides ownership.Boxing collections is pointless because vectors,strings and maps are smart pointers themselves designed to manage the memory they hold.Boxing is useful for structs when the structs have recursive and not cyclic types.

*A tuple struct in Rust is a type of struct that is defined using a tuple-like syntax. Tuple structs allow you to create a new type with named fields, but unlike regular structs that have named fields, the fields in a tuple struct are accessed by their position (index) rather than by name.It isnt different from a tuple other than to give more meaning to grouped data.it also makes it more typesafe to work with

*associated types are like the generics of traits

*in rust,you can create functionality on operators for your types by using operator overloading.You do this by implementing traits while in python,you do this by using dunder methods.js doesnt support operator overloading.

*in rust and python,operators are actually syntatic sugar over function calls only for user defined types while operators on default types like integers gets compiled directly to a cpu instructions.

*the deref trait allows one to write code that uses a smart pointer as readably as a regular reference.it is called when the * operator is used on the type

*deref coercion is when rust cnverts a ref on one type to a ref of another.When you have a type T that implements the Deref trait, Rust can automatically convert a reference of type &T to a reference of type &U, where U is the target type defined by Deref.The Target associated type defines what type the Deref implementation will convert to when dereferenced.

*When you have a function defined to take a reference of one type, and you provide a reference to another type that implements the Deref trait to convert to the expected type, Rust will automatically perform this conversion behind the scenes.

*the drop trait is automatically called when a struct goes out of scope.cleanup code in python is done with the with block which is a context manager while rust uses the drop trait while in js,its done manually.the resources that needs to be managed by the drop trait is not just memory in the case of smart pointers but also other resources like file handlers,network sockets 

*rust doesnt allow one to call the drop method manually as its done automatocally when a variable goes out of scope and if you call the drop method,rust will still call it when the scope ends,causing a double free

* the term destructor, which is the general programming term for a function that cleans up an instance. A destructor is analogous to a constructor, which creates an instance. The drop function in Rust is one particular destructor.

*so i can implement my own smart pointers in rust

*if a function doesnt use a variable,the compiler doesnt see the need to invoke the drop function but it still enforces its ownership rules but it wont bother calling the drop trait

*copy is a trait and move is a trait

*if multiple variables use the same data and we knew the last user of the data in advance,we wont have to use rc as we can just make the last person the owner and the owenrship rules will apply

*Box::new takes ownership

*in rust,if variable b is dependent on variable a either by ref or for assignment,there is no way b will outlive a because b cant be initialized before a since it depends on it and b wont be able to use the value of a outside of the scope of a as a will be invalidated so the only way around this is to declare b without a value outside of the scope of a and modify it in the scope of a so that b,the dependent will outlive a

*Rc doesnt allow the owners to mutate the data as it will cause data races so the owners can only read the data.it doesnt feel much like a difference from immutable refs except that each owner is a pointer to the address of one owner but each owner is a direct pointer to the data on the heap meaning that it wont get dropped until all the owners are out of scope

*Ref cell uses unsafe code to perform interior mutability which is mutating data with immutable refs

*structs are stored on the stack and rust needs to know the memory to allocate to that struct at compile time and if a struct uses itself in its field,rust will have to calculate the size that that struct will take and again and again that will lead to a recursion so Box solves the problem of recursive type moving data to the heap which means that rust doesnt have to calculate the size all at once,it just stores a pointer to the field of the struct that refs the struct an since its a pointer,the data is shifted to the heap which allows for rust to opt in more memory blocks as more structs are added but Box requires that the data must have a single owner so if two structs ref themselves,Box wont decide who owns who to decide who is responsible for deallocating the memory once out of scope so Rc fixes this by doing what the Box does but also allowing multiple owmers of data to coexist by using ref counting.this ensures that the data is only dropped when all the owners go out of scope but to prevent memory leaks from cyclic ref,one can use a weak ref which wont affect the ref count

*a declared variable is not mutable because its value hasnt been decided yet

*Rc and refcell are only single threaded scenarios
*Because RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.Mutating the value inside an immutable value is the interior mutability pattern.Using RefCell<T> is one way to get the ability to have interior mutability, but RefCell<T> doesn’t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you’ll get a panic! instead of a compiler error.