a thunk is a function that returns another function instead of a state.Its used for performing side effects

ill use a progressive optimization technique where the core functionality is written in js at first using thunks and the code in the thunks is gradually replaced with rust calls

decoupling the implementation from the application

*local file manager
*cloud file manager

redux thunks for client side processing with side effects
rtk query for communicating with server side processing

redux state
reducers manages the state of the app
thunks orchestrates state and call side effect functions
side effect functions/utilities are separate and decoupled from the thunks

components dispatch thunks

undefined: Typically indicates that a variable has not been initialized. This can lead to ambiguous situations where itâ€™s unclear whether the absence of a value is intentional or accidental.
using null union ensures that a value can never be accidentally undefined

switch on union for safety similar to match enum case in rust

variables with no values leads to ambiguity about whether its intentional or by accident.so using null where possible is better so that you can clear this ambiguity and save productivity time from false bug hunting


async thunks and create async thunks

thunks dont return values.just dispatch actions

^react,tauri,pouch db,tailwind,daisy ui,redux,chart js,react-toastify,uuid

hello pangea dnd,react router,framer motion,gsap,three js,
next js,auth js,paystack,prisma,postgres sql,mongoose,mongo db
formik,zod
web3forms
jotai
backend as a service or a nest js server

^uno edit funk download
^Conquest edit,invincible season 3 edit

relative ui sizes only makes layout responsive and not content 

client side apps--tauri with react,vue,svelte,rust for performance critical parts
server side apps--tauri wrapper,next js,nuxt js,sveltekit
client side with server side functionality---client side app with rtk query,Backend as a service/nest js server
server side app with client side functionality----server side app but with (redux,client components,pouch db)

implementation,interface,controller
database,file system,app state


TODO:download some assets
TODO:finish the layout of the ui

Todo:Art styles
3d illustration art
neumorphism and skeuomorphism art
minimal ui art
vibrant
animated
infographics
svg art
lottie animation

todo:resizable panels

3d illustration ai generator

fixed units---requires manual responsiveness,is faster:%,vh/vw,rem
relative units--constant calculations makes it automatic,slows perfromance:px

relative unit for layout
fixed units for content

safe assignment


*so components gets rerendered across updates and only app state is saved across rerenders.return values from function calls arent saved but rather recalled on rerender and since uniqueid isnt a pure function because of the unpredictability of output,the previous ids get lost on rerenders and thus the need to cache their iutputs using useMemo is required

*i could have made the conditional class logic inline by using the ternary operator but doing so will become catastrophic as the component grows because i will have to check each element that manages their own classes that they apply.moving it to a function that an element calls even if its one element makes it easier to reason about.the jsx shouldnt make any decisions on the app state or which classes to apply.they should just render ui.the only decision it makes is on what ui to render based on a condition it doesnt even check but one returned by a function.

*sub functions are the functions within the component function that handles component state management logic.They often read from or modify component state without directly embedding that logic in the JSX.sub functions only make decisions based on the component state but when it comes to the app state or global state,they only dispatch thunks that handle that logic and they dont decide which thunks to dispatch conditionally because they will be influencing the global state.The subfunction determines which ui to render and the jsx follows.

*jsx are no decision makers .the decision making is by sub functions even what to render is by a subfunction so a jsx rendering something conditionally is as directed by a subfunction.the subfunction will return its decision as either true or false and the jsx obeys.

*operations are better centralized than decentralized,have only one responsibility
*components are functions that return jsx.

*reusable styles will require a css file and not necessarily a style component or a string variable
*reusabel jsx can be done with components and props

*useMemo a hook for memoizing values in components.It helps optimize performance by recalculating values only when their dependencies change.Ideal for expensive calculations or derived data that you want to cache during component re-renders or for retaining the values of impure functions like a unique id generator

*React.memo is a higher-order component that memoizes the entire component. It prevents re-renders of the component if its props have not changed.Ideal for optimizing functional components that do not depend on internal state and only rely on props for rendering.stateless child components can be memoized

*regular function defintions for reusable logic and arrow functions for callbacks in hof
*another use case of arrow functions i found is that it looks cleaner for components that accepts props.they are also used for type annotating functions in interfaces

*most of the time,i dont use props because state can do everything i need but i think the ideal use case of props is for pure components.that is components that always return the same output from a given prop.unlike their parents,they dont have subfunctions to make any decision for themselves.they just take the sub functions of their parents and call them where appropriate non conditionally.They are mostly used to prevent rewriting jsx across a component.If they do make decisions,its only based on their own state.they dont make decisions about their parent state so they shouldnt directly have setters but rather subfunctions of the parents that do the decision when it comes to the parent state

*arrow functions,props and memoization for child components

*Child components--they are the same but they dont affect the state of their parents directly but rather use wrappers around setters provided by the parent and it should be changed non conditionally


^fs,path and os,win api
the os module is used to request general os services
win api is specifically for window services

todo:safe mode--changes to the fs through the app doesnt directly affect the real fs.this is to ensure the app safely access the fs.It will require a diffing algorithm and diff files that are loaded in memory.any attempt to write a file,writes to a diff file

design merging
primary-complementary design


lasnguage service provider--intellisense
linter---real time analysis
lexer---breaks the code into tokens
parser---constructs the ast from tokens
semantic analyzer--checks if the ast is syntatically correct
ir code generator
ir optimizer
asm code genrator
assembler
binary

?does php compile to html

software architecture
design architecture
algorithm design

*---------------------------------------------------------------------------------
implementation,utiilities
safe interface
selectors,reducers
thunks
components--state getter and setter,sub functions and jsx
Child components

higher order components
toast component

custom hooks
higher order thunks
*------------------------------------------------------------------------------------------

app state is global,component state is local

stateful child,
stateless child

custom hooks for reusable component logic
stateless child components for optimization and reusable jsx

anything that should cuase it to render when memoizing,should be passed a prop and checked for changes

ui framework compatibility tools-mitosis,astro

tauri uses wry as the webview library

todo:how to embed external binaries like node js into tauri
calling rust from frontend
calling frontend from rust
bidirectional communication

delayed runtime error--error-prone code may not immediately cause runtime errors till they are called.This is because writing error-prone code doesnt cause anything till you use them at runtime.

^with wasm,you can interop any programming language with js.so i will use tauri or was to bridge rust with js

unsafe but protected like for a new unsafe block,a new process is spawned and if it crashes,the program skips it

todo:vfs feature that uses a diffing algorithm
todo:virtual folder

frontend dev--content but exhaustive
backend dev--content but repetitive
cyber security--new content generated every day because of emerging threats
game dev--you can create any thing you can imagine as long as you can code it
data science programmer--new content because data changes per business
scientific programmer
cloud developer

the reason we use state on react instead of local variables for storing data is because components i react are functions and functions are stateless so when they rerender,the variable information gets reset but using state from a state hook ensures that the value persists across rerenders

you can return jsx with or without () because () is for grouping data but since jsx only has a single parent,there is no difference in using it or not but using () allows you to indent it below the return.

for a toast component that notifies the app on an error,define th error in the component and bind it to a use effect that calls the toast function to show the error but you should define the toast function in the use effect hook or it will always cause a rerender.you can define it outside of the hook but it will be more complex as you have to use useCallback to prevent unnecessary rerenders

everything used in a use effect hook thats outside of its definition must be a dependency so that it accurately reflects the current data.if a variable isnt tied to rendering of the hook logically,its better to define it within th euse effec hook to prevent it from being a dependency

*ui configuration to component with set attributes

toast emmitter is a local change while toast container is a global change to all toasts

*The toast component works by listening to a variable on the app state that keeps errors,infos or messages and when it changes,it uses a useEffect hook to respond to it.The problem is that the same error message wont popup again after it does once even if the error occurs twice.this is because the same error message means the state of the error didnt change for the useEffect to listen to but by using an id property that has its value generated by a unique id function at runtime,the same errors will popup twice even though the messages are the same because their ids are different.This is for incase someone spams something that gets an error and they need to know it gets an error each time and when they want to redo the same command for refreshing the component

?errors can be handled,transported or both

objects are for centralizing related data into a single variable

because the ids are supposed to be unique even for the same message,it has to be recomputed unlike elements in react list components that requires caching for the components to be properly tracked

type safety,memory safety,runtime safety
difference between it will not x and it can never x
notes in my jotter
difference between safety and security
builder mindset vs the engineer mindset

even though thunks look like regular functions,they can only be called by dispatchong them even by other thunks


*error transports---log files,console,toasts
*safe interface,centralized error management,transport layer
*capturing the error,handling the error,shipping the error